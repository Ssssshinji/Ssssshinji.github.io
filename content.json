{"meta":{"title":"inside","subtitle":"","description":"","author":"zyt","url":"http://Ssssshinji.github.io","root":"/"},"pages":[],"posts":[{"title":"问题精析：PBR:BRDF","slug":"问题精析：PBR-BRDF","date":"2020-07-10T07:53:16.000Z","updated":"2020-07-10T12:10:35.590Z","comments":false,"path":"2020/07/10/问题精析：PBR-BRDF/","link":"2020/07/10/问题精析：PBR-BRDF","permalink":"http://ssssshinji.github.io/2020/07/10/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR-BRDF/","excerpt":"","text":"我们看到一个表面，实际上是周围环境的光照射到表面上，然后表面将一部分光反射到我们眼睛里。双向反射分布函数BRDF（Bidirectional Reflectance Distribution Function）就是描述表面入射光和反射光关系的。BRDF就是一个描述光如何从给定的两个方向（入射光方向l和出射方向v）在表面进行反射的函数。 BRDF的精确定义是出射辐射率的微分（differential outgoing radiance）和入射辐照度的微分（differential incoming irradiance）之比： $$ f(l,v) = \\frac{dL_o(v)}{dE(l)} $$ 其中f就是BRDF，l是入射光方向，v是观察方向，也就是我们关心的反射光方向。 \\(f(l,v)\\)是表面反射到\\(v\\)方向的反射光的微分辐射率。表面反射到\\(v\\)方向的反射光的辐射率为\\(L_o(v)\\)，来自于表面上半球所有方向的入射光线的贡献，而微分辐射率\\(dL_o(v)\\)特指来自方向\\(l\\)的入射光贡献的反射辐射率。 \\(dE(l)\\)是表面上来自入射光方向\\(l\\)的微分辐照度。表面接收到的辐照度为\\(E\\)，来自上半球所有方向的入射光线的贡献，而微分辐照度\\(dE(l)\\)特指来自于方向\\(l\\)的入射光。 相关物理量（辐射度量学） 辐射通量/光通量 Radiant Flux 功率（Power），单位瓦特（Watts），或者焦耳／秒。辐射度学中，辐射功率也被称为辐射通量（Radiant Flux）或者通量（Flux）。描述的是在单位时间穿过截面的光能，或每单位时间的辐射能量，通常用Φ来表示。 $$ \\phi = dQ/dt $$ 其中的Q表示辐射能(Radiant energy)，单位是J，焦耳。 辐射强度/发光强度 Radiant Intensity 指通过单位立体角的辐射通量。用符号I表示，单位\\(W \\cdot sr^-1\\)，瓦特每球面度。之所以引入辐射强度，是因为有时候要度量通过一个点的通量的密度，但因为点的面积是0，无法使用辐照度。辐射强度不会随距离变化而变化，不像点光源的辐照度会随距离增大而衰减，这是因为立体角不会随距离变化而变化。 $$ I = d\\phi/d\\omega $$ 辐照度/辉度Irradiance 辐照度（Irradiance，又译作辉度，辐射照度，用符号E表示），指入射表面的辐射通量，即单位时间内到达单位面积的辐射通量，或到达单位面积的辐射通量，也就是辐射通量对于面积的密度，用符号E表示，单位\\(W \\cdot m^-2\\)，瓦特每平方米。 $$ E = d\\phi/dA $$ 也可以写成辐射率(Radiance)在入射光所形成半球上的积分： $$ \\frac{d\\phi}{dA} = E = \\int_{\\Omega} L(\\omega)cos\\theta d\\omega $$ 假定不垂直于光线传输方向的表面面积为\\(A\\)，将它投影到垂直于光线方向得到一个虚拟表面，这个虚拟表面的面积为\\(A^ \\bot = Acos \\theta _i\\)，通过这两个面积的通量是相同的，均为\\(\\phi\\)，则表面接收到的辐照度\\(E = \\phi/A\\)，虚拟表面上的辐照度\\(E_L = \\phi/Acos \\theta_i\\)，于是\\(E = E_Lcos \\theta_i\\)。 辐射率/光亮度Radiance 我们常需要度量从一个微小面积表面出发，射向某个微小方向的通量（或者来自某个微小方向，照射到微小面积表面的通量），辐射率就是度量这种情况的量。辐射率（Radiance），指每单位面积每单位立体角的辐射通量密度。用符号L表示，单位\\(W \\cdot sr^-1 \\cdot m^-2\\)。需要注意的是，辐射率使用物体表面沿目标方向上的投影面积，而不是面积。 $$ L = \\frac{d^2\\phi}{dAcos \\theta d\\omega} $$ 辐射率实际上可以看成是我们眼睛看到（或相机拍到）的物体上一点的颜色。在基于物理着色时，计算表面一点的颜色就是计算它的辐射率。辐射率不会随距离变化而衰减，这和我们日常感受一致，在没有雾霾的干扰时，我们看到的物体表面上一点的颜色并不会随距离变化而变化。为什么辐照度会随距离增大而衰减，但是我们看到的颜色却不会衰减呢？这是因为随着距离变大，我们看到的物体上的一块区域到达视网膜的通量密度会变小，同时这块区域在视网膜表面上的立体角也会变小，正好抵消了通量密度的变化。 Lambert模型的BRDF 如图，设Lambert面元获得入射照度Ei，各方向均匀释放亮度，每个方向释放的亮度都是Lo。 又设此表面反射率为Albedo，根据反射率定义: $$ \\begin{align} Albedo &amp;= Eo/Ei \\\\&amp;= \\frac{\\int_{\\Omega} L(\\omega)cos\\theta d\\omega}{E_i} \\\\&amp;=\\frac{Albedo}{\\pi} \\end{align} $$ 所以 $$ brdf=Lo/Ei=Albedo/pi $$ 半球cos积分等于pi的计算过程：作代换dw=sin(theta)dthetadphi，则 $$ \\begin{align} \\int_{\\Omega} cos\\theta d\\omega &amp;= \\int_{0}^{2\\pi}d\\phi \\int_{0}^{\\pi/2}cos\\theta sin\\theta d\\theta \\end{align} $$ 参考资料 1. 基于物理着色：BRDF 1. brdf为什么要定义为一个单位是sr-1的量？ 1. Lambert漫反射的BRDF","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：PBR:三种反射模型","slug":"问题精析：PBR-三种反射模型","date":"2020-07-09T18:35:40.000Z","updated":"2020-07-10T07:52:56.364Z","comments":false,"path":"2020/07/10/问题精析：PBR-三种反射模型/","link":"2020/07/10/问题精析：PBR-三种反射模型","permalink":"http://ssssshinji.github.io/2020/07/10/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR-%E4%B8%89%E7%A7%8D%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"PBR是近来一个新的，有意思的实时渲染方式。这个术语已经被传播得很广泛，但他的真实含义往往是混淆的。简单的回答是：这意味着很多。或者：这得看情况。这种回答并不能使人满意。所以我尝试着将PBR的真实含义，和它与传统的流程详细的解释清楚。这个文档主要是针对美术人员而非工程师。不会涉及数学或者代码类的东西。 PBR和传统流程最主要的区别在于他更详细和科学的还原了光照和物理表面的关系原理。他的纹理系统已经大大的进化。而旧的生产流程和近似的表达方式可以安全的抛弃了。这代表着无论是工程师还是美术工作人员都需要理解这些变化的动机在哪里。 我们需要从一些最基础的东西开始。这样我们可以在讲一些新东西之前对一些基本的概念有清楚的认识。你可能会觉得我讲的这些部分太枯燥乏味，但读过之后你会知道这些东西是值得的。你也可以了解一下Joe Wilson的文章：creating PBR artwork。 散射(Diffusion) 也称为散射，漫反射是最容易模拟的模型，现实中的例子也很多，例如石头，水泥，砖块等。最简单的Lambertian很简单粗暴的认为光线被均匀的反射到表面上方的半球中。 表面散射的性质通常用BRDF（双向反射分布函数）来表示。一句话不严谨的概括BRDF既是输入一个入射的方向和一个出射的方向，输出一个出射光线和入射光线能量的比值。不想细扣公式，直接上代码。（BRDF之后详述，记住散射是BRDF负责的） 12345float Lambertian(Vector3 In, Vector3 Out)&#123; &#x2F;&#x2F; 乘以PI的倒数是因为BRDF在半球内的积分需要为1，满足能量守恒 return INV_PI;&#125; 因为Lambertian模型均匀的反射出能量，所以返回值是一个常量和出射入射方向无关。下面是一个用Lambertian材质渲染的图片。 Lambertian并不能很好的模拟现实中的许多漫反射材质，现实中完美的均匀反射当然几乎是不存在的，有些现实中的材质会在视线方向接近和表面平行的时候反射更多的光线等。所以当然有一些更复杂的数学模型去模拟更复杂的漫反射，例如Oren Nayar模型。 Disney的Principled BRDF简单的用两个Fresnel项来增加入射角度低时反射的光线能量强度来模拟这种效果。好处是计算量相对小而且能打到足够的近似。贴一个我自己实现的伪代码，公式在最上面文档的链接5.3章节有，自行查阅。 1234567891011121314float DisneyDiffuse(Vector3 In, Vector3 Out)&#123; float oneMinusCosL &#x3D; 1.0f - AbsCosTheta(In); float oneMinusCosLSqr &#x3D; oneMinusCosL * oneMinusCosL; float oneMinusCosV &#x3D; 1.0f - AbsCosTheta(Out); float oneMinusCosVSqr &#x3D; oneMinusCosV * oneMinusCosV; &#x2F;&#x2F; Roughness是粗糙度，IDotH的意思会在下一篇讲Microfacet模型时提到 float IDotH &#x3D; Dot(In, Normalize(In + Out)); float F_D90 &#x3D; 0.5f + 2.0f * IDotH * IDotH * Roughness; return INV_PI * (1.0f + (F_D90 - 1.0f) * oneMinusCosLSqr * oneMinusCosLSqr * oneMinusCosL) * (1.0f + (F_D90 - 1.0f) * oneMinusCosVSqr * oneMinusCosVSqr * oneMinusCosV);&#125; 光滑镜面反射(Specular) 最常见的就是镜子和玻璃一类的材质了，他们分别为导体和电介材质。镜面反射就只是将入射光线根据表面法线反射，并且只在反射方向有能量其他方向均为0。对玻璃这种电介材质则除了反射之外还有根据物体的折射率一部分光线会折射进入物体之中。 最常见的就是镜子和玻璃一类的材质了，他们分别为导体和电介材质。镜面反射就只是将入射光线根据表面法线反射，并且只在反射方向有能量其他方向均为0。 对玻璃这种电介材质则除了反射之外还有根据物体的折射率一部分光线会折射进入物体之中。反射和折射能量的多少是根据菲涅尔定律决定（Fresnel’s Law）。图形学中常常使用用Schlock的近似Fresnel，伪代码如下。 12345678910float Fresnel_Schlick(float InCosine, float normalReflectance)&#123; &#x2F;&#x2F; InCosine是入射光线和法线的夹角，normalReflectance是入射光线和法线垂直时的反射能量大小 float oneMinusCos &#x3D; 1.0f - InCosine; float oneMinusCosSqr &#x3D; oneMinusCos * oneMinusCos; float fresnel &#x3D; normalReflectance + (1.0f - normalReflectance) * oneMinusCosSqr * oneMinusCosSqr * oneMinusCos; return fresnel;&#125; 值得一提的是在离线渲染，光线追踪里这两种材质本身的着色很容易，只用根据反射和折射的方向射出新的光线然后递归的着色即可。在游戏实时渲染中反射通常是用屏幕空间的反射（Screen Space Reflection）和环境光照贴图两者结合实现的，折射也通常是用扭曲屏幕空间像素的方法。都会有一些Artifact，目前没有完美的解决方案。 对于电介材质来说，除了本身的颜色以外，折射率是决定外观的另一个重要因素。折射率决定了折射光线的方向以及全反射的临界角度，上面的图片采用的折射率是1.5，也就是常见的玻璃的折射率，下面这张图则是用折射率2.42的渲染结果，对应的材质是钻石。根据菲涅尔定律，折射率越高的物体反射光线与折射光线的比值也越大，所以整个看起来更加Bling Bling了。 当然现实中不存在完美平滑的表面。接下来提高真实感的一个手段就是对材质表面的法线进行扰动。法线贴图是方法之一。(PBR中多用微表面) 参考资料 1. 基于物理着色（一）","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题5：一次编辑","slug":"问题5：一次编辑","date":"2020-07-09T10:54:46.000Z","updated":"2020-07-09T18:34:08.083Z","comments":false,"path":"2020/07/09/问题5：一次编辑/","link":"2020/07/09/问题5：一次编辑","permalink":"http://ssssshinji.github.io/2020/07/09/%E9%97%AE%E9%A2%985%EF%BC%9A%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/","excerpt":"","text":"题目描述 字符串有三种编辑操作：插入一个字符、删除一个字符或者替换一个字符。给定两个字符串，编写一个函数判定它们是否只需要一次（或者零次）编辑。 示例： 1234pale, ple -&gt; truepales, pale -&gt; truepale, bake -&gt; truepale, bake -&gt; flase 个人思路 如果两个字符串长度相等，逐个比较就好，不同的地方最多只能有1处。如果两个字符长度相差1，分别用两个指针指向各自位置，如果出现不同，长的那个字符串的指针往后挪一位。之后再出现不同则返回false。 个人解答 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static bool CanOneEdit()&#123; string[] values &#x3D; Console.ReadLine().Split(&#39;,&#39;); string str1 &#x3D; values[0]; string str2 &#x3D; values[1]; bool oneDiff &#x3D; false; if(Math.Abs(str1.Length - str2.Length) &gt; 1)&#123; return false; &#125; else if(str1.Length &#x3D;&#x3D; str2.Length)&#123; int i &#x3D; 0; int j &#x3D; 0; for(i &#x3D; 0,j &#x3D; 0; i &lt; str1.Length;i++,j++)&#123; if(str1[i] !&#x3D; str2[j])&#123; if(oneDiff)&#123; return false; &#125; else oneDiff &#x3D; true; &#125; &#125; return true; &#125; else if(str1.Length - str2.Length &#x3D;&#x3D; 1)&#123; int i &#x3D; 0; int j &#x3D; 0; while(i &lt; str1.Length &amp;&amp; j &lt; str2.Length)&#123; if(str1[i] !&#x3D; str2[j])&#123; if(oneDiff)&#123; return false; &#125; else oneDiff &#x3D; true; i++; continue; &#125; i++;j++; &#125; return true; &#125; else if(str1.Length - str2.Length &#x3D;&#x3D; -1)&#123; int i &#x3D; 0; int j &#x3D; 0; while(i &lt; str1.Length &amp;&amp; j &lt; str2.Length)&#123; if(str1[i] !&#x3D; str2[j])&#123; if(oneDiff)&#123; return false; &#125; else oneDiff &#x3D; true; j++; continue; &#125; i++;j++; &#125; return true; &#125; return false;&#125; 题目解析 该题目可借助蛮力法。通过移除每一个字符（并比较），替换每一个字符（并比较），插入每一个字符（并比较）等方法，得到所有可能的字符串，然后检查只需一次编辑的字符串。该算法的运行时间过于缓慢，因此不用费尽心思来实现。 对于此类问题，思考一下每一种操作的“意义”大有裨益。两个字符串之间需要一次插入、替换或删除操作意味着什么？ **替换:**设想一下诸如bale和pale这样的两个字符串，它们之间相差一次替换操作。这确实意味着你可以通过替换bale中的一个字母来获得pale，但是更精确的说法是，这两个字符串仅在一个字符位置上有所不同。 **插入:**字符串apple和aple之间相差一次插入操作。这意味着，如果你对比两个字符串，会发现除了在字符串上的某一位置需要整体移动一次以外，它们是完全相同的。 **删除:**字符串apple和aple之间同样也可以表示为相差一次删除操作，因为删除操作只是“插入”的相反操作而已。 标准解答 1&#x2F;&#x2F;和我的解答基本相同，写的更漂亮 复杂度分析 该算法的时间复杂度为O(n)，n是较短字符串的长度（几乎所有合理的算法都为该时间复杂度）。为什么运行时间由较短的字符串决定而不是由较长的字符串决定呢？如果两个字符串长度相同（相差一个字符），那么使用较长的字符串或者较短的字符串定义时间复杂度均可。如果它们的长度大不相同，那么算法会在O(1)的时间内结束。因此，一个非常长的字符串不会极大地增加运行时间。只有当两个字符串都很长的时候，时间复杂度才会增加。 我们或许会注意到代码oneEditReplace和代码oneEditInsert相差无几。因此，可以将二者合并为一个方法。 标准解答（进阶） 12345678910111213141516171819202122232425262728bool oneEditAway(string first, string second)&#123; &#x2F;&#x2F;检查长度 if(Math.Abs(first.Length - second.Length) &gt; 1)&#123; return false; &#125; &#x2F;&#x2F;获取较长或较短字符串 string s1 &#x3D; first.Length &lt; second.Length ? first :second; string s2 &#x3D; first.Length &lt; second.Length ? second :first; int index1 &#x3D; 0; int index2 &#x3D; 0; bool foundDiff &#x3D; false; while(index2 &lt; s2.Length &amp;&amp; index1 &lt; s1.Length)&#123; if(s1[index1] !&#x3D; s2[index2])&#123; if(foundDiff)return false; foundDiff &#x3D; true; if(s1.Length &#x3D;&#x3D; s2.Length)&#123; index1++; &#125; &#125; else&#123; &#x2F;&#x2F;匹配的话才移动较短的指针 index1++; &#125; &#x2F;&#x2F;总是移动较长的指针 index2++; &#125; return true;&#125; 有些人或许会认为第一种方法更好，因为它更为清晰且更易理解。另外一些人则会认为第二种方法更好，因为该方法更加紧凑且重复代码更少（有助于代码的维护）。你并不需要站队，只需和面试官权衡利弊。 反思 思路基本相同，但是代码比我的漂亮多了。切记整洁代码的原则，少参数，少行数，数十行的行代码要分成多个方法。 提示：#23，#97，#130 -从容易的事情开始。你能分别检查一下每一个条件吗？ -“插入字符”选项和“删除字符”选项之间是何关系？这些需要分开检查吗？ -你能一次完成三次检查吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：PBR概述","slug":"问题精析：PBR概述","date":"2020-07-08T14:09:16.000Z","updated":"2020-07-08T14:57:37.957Z","comments":false,"path":"2020/07/08/问题精析：PBR概述/","link":"2020/07/08/问题精析：PBR概述","permalink":"http://ssssshinji.github.io/2020/07/08/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR%E6%A6%82%E8%BF%B0/","excerpt":"","text":"PBR是近来一个新的，有意思的实时渲染方式。这个术语已经被传播得很广泛，但他的真实含义往往是混淆的。简单的回答是：这意味着很多。或者：这得看情况。这种回答并不能使人满意。所以我尝试着将PBR的真实含义，和它与传统的流程详细的解释清楚。这个文档主要是针对美术人员而非工程师。不会涉及数学或者代码类的东西。 PBR和传统流程最主要的区别在于他更详细和科学的还原了光照和物理表面的关系原理。他的纹理系统已经大大的进化。而旧的生产流程和近似的表达方式可以安全的抛弃了。这代表着无论是工程师还是美术工作人员都需要理解这些变化的动机在哪里。 我们需要从一些最基础的东西开始。这样我们可以在讲一些新东西之前对一些基本的概念有清楚的认识。你可能会觉得我讲的这些部分太枯燥乏味，但读过之后你会知道这些东西是值得的。你也可以了解一下Joe Wilson的文章：creating PBR artwork。 散射和反射(Diffusion and Reflection)) Diffusion和Reflection。也被叫做diffuse和specular。是描述光和物体表面互相作用的最基础的两个术语。很多人知道他们在实际应用中是怎么样的。但并不知道他们的物理原理是什么。 当光照射到物体的表面时，他会反射一部分，或者说反弹一部分。从表面的一边反弹到镜像的另一边。就像一个球打在地面上并弹起来一样。在光滑的表面上，会有像镜子一样的效果。单词specular，就是用来描述这种现象的。而specular正是拉丁语中镜子的意思。 然而并不是所有的光线都会从表面直接反射。有些光线会在进入被照射物体的内部。这些进入物体内部的光线有的会被物体吸收（往往会转变为热量消耗掉），而有些散射光线会在物体内散射后又从表面散射出去。然后被我们的肉眼或者摄像机看到。像diffuse，diffsion，3S（SSS）等都是表达的这个物理现象。 对不同波长的光，它的反射和吸收的量是差别很大的。这就让物体有了固有的颜色（例子：如果白光照射在物体上，大部分的光线都被吸收掉了，而只反射出蓝色，那这个物体就是蓝色的）。这种散射是均匀而散乱的往各个向散射过去的。这和镜面反射完全不同。我们在shader上用albedo来表达这些散射颜色。Diffuse color是和这个同义的短语。 半透明和全透明(Translucency and Transparentcy) 有时候diffuse是蛮复杂的。在有些材质中，散射的距离会更广，更远。比如说像皮肤或者蜡这些材质。这时候用一个简单的颜色来表示是不够的。引擎会要计算物体的形状或者厚度。如果物体足够薄，就可以看到光从物体的背面照射出来（就好像光穿过人的手），这就是translucent（半透明）。如果散射更低，比如说玻璃，几乎所有的光线都直接穿过，以至于你可以看到背面的图像。这些属性都和“物体表面的散射”相去甚远。这时引擎需要一个单独的shader来模拟这些现象。 能量守恒(Energy Conservation) 有了这些描述后我们就有足够的信息去得到一个重要的结论：散射diffusion和反射reflection是相互排斥的（要么就散射，要么就反射）这也是传统光照模型所忽略的。。这是因为：如果光要散射，他就必须要在物体表面内传播，也就是不能反射。这就是照明系统中的“能量守恒定理”：从一个物体表面散射或反射的光线永远不会比原本照射他的光线要亮。 这很容易被引擎执行：在diffuse执行之前先把反射的那部分光线减去。这意味着高反射的物体的diffuse会很少很黑，因为大部分的光线都被反射掉了，几乎不能在物体的表面散射。下面这种守恒也是同样成立的：如果一个物体有非常亮的diffuse，那他也不会有什么反射。 这种能量守恒是PBR的一个重要的部分。这让艺术家能够基于物理的原理来调整albedo和reflective的值，而不是违背物理原理（这往往会看起来很low很糟糕）。虽然严格的执行这些规律和创造屌炸天的艺术作品并没有什么必然的联系。但它能起到一个“物理学保姆”（比喻）的角色。这能保护你的作品不会偏离规律太远。或者在不同的光照条件下得到前后矛盾的效果（不同光照下的表现相差很多）。 金属(Metals) 1.首先，导体（金属）会比绝缘体（非金属）的反射要高的多得多得多。导体一般会反射高达60－90%的光线，而绝缘体会少得多，一般在0-20%的范围内。这种高反射避免了光线进入到物体表面内部散射，给金属一种光亮的效果。 2.其次，导体的反射有时会在可见光谱中变化，这意味着他们的反射是有颜色倾向的。这种反射颜色在不同的导体上也是不同的。比如说：金，铜，黄铜，都是不一样的。而绝缘体不会有这种现象，他们的反射是不带颜色的 （一般是某种深度的灰色的）。 3.最后，导体一般会吸收没有反射的光线，而不是在表面散射。这个规律意味着金属是没有diffuse颜色的。但是注意：在现实情况中，金属表面会有一些物体（比如灰尘）和氧化物会产生一些固有色。（这里存疑，因为有的地方讲diffuse和固有色是同一个东西） 菲涅尔(Fresnel) 奥古斯丁菲涅尔第一个准确的描述了菲涅尔这个现象。如果我们要谈论光线的反射，那就绕不开这种现象。 在计算机图形学中，菲涅尔指的是在不同角度下，反射的变化现象。特别是：光在一个小掠角射到一个表面的反射会比垂直照射到一个表面要多得多。这意味着一个有着正确菲涅尔效果的物体，在它的边缘位置反射会比中间位置的反射会强很多。我们已经对这个效果很熟悉了，而在计算机图形学领域中，菲涅尔也不是一个新词。不过，PBR系统对菲涅尔方程式做了几个重要的修正。 首先，对所有的材质，在很小的角度看，反射都会很强烈。在极为边缘或者小角度的地方，任何材质都会反射得像一面镜子一样。是的，任何材质，只要平滑，并从对的角度观察，都会像是一面完美的镜子。这有违常理，不过实际上就是这样子的。 第二个有关于菲涅尔属性的结论是。不同的材质之间，菲涅尔曲线的变化差异并不大。金属的差异大一些，但也还是可以分析和记录的。 那这对于我们意味着，获得一个真实的效果。艺术家应该更少的控制菲涅尔属性，而不是更多的控制它。 这里有个关于菲涅尔效果的警告。在一个表面越粗糙的时候，菲涅尔效果会越不明显。下文会讲述更多的关于这方面的信息。 微表面(Microsurface) 以上对于反射（reflection）和漫反射（diffusion）的描述都是是基于物体表面朝向的。从一个正常的观察尺度来说，这种表面朝向是基于物体的形状的。而法线贴图也会在描述更加小一些的形状细节。渲染引擎能基于这些信息来渲染diffuse和reflection信息。 但是这里还有一个很大的部分被忽略掉了。大部分真实世界的表面都有很多不完美的地方：小凹槽，破损，小突起等细节。这些细节肉眼是看不到的。正常分辨率的法线贴图也不能体现这些小细节。虽然不能被肉眼看到，这种小细节仍然会对光的diffsion和reflection产生影响。 微表面的细节影响最显著的是反射 Specular（次表面散射影响不明显，所以我们不会在这里过多的讨论）。从上面的图我们可以看到平行光线照射到粗糙的表面后会分散的反射开来，因为每一束光和表面碰撞的方向都是不同的。我们用球碰墙的模拟，在一个类似于崖壁或者类似的不平整的表面：当球打到一个表面时，反弹的角度是不可预期的。简单的讲，越是粗糙的表面，越多的反射光线会分散，呈现一种模糊的效果。 可惜的是。定义每一个不同的微表面是不实际的。因为工作流程，内存控制，计算量都做不到。那么咋整呢？我们可以不用直接描述每一个不同的微表面。而是定义一个大概的粗糙程度。那样我们也可以获得一个十分接近而准确的效果。这种值往往叫做Gloss，Smoothness，或者Roughness。你可以通过贴图定义他们，或者给不同的材质定义不同的值。 微表面的细节是一个材质的重要组成部分。因为在实际生活中有大量的，广泛的，不同的微表面特征。光泽度贴图（gloss mapp）不是一个新的概念。但它还是在PBR渲染中扮演了重要的角色。因为微表面细节对光的反射有重大的影响。下面我们马上会讲到PBR系统对微表面属性的若干方面的提升。 守恒定律(包含微表面) 当我们将微表面细节纳入到我们的渲染模型，然后准确的散布反射光线。这时就必须正确地反射光线的量。遗憾的是，很多老的渲染引擎都把这个部分搞错了，基于微表面的粗糙度，不是反射过多就是反射过少。 当方程式准确平衡的时候，一个引擎需要将粗糙表面的高光变得模糊，而将光滑的表面的高光变得小而尖锐。在亮度上的不同表现关键在于：两种材质（光滑和粗糙）都会反射同等量的光线，不过粗糙的表面将它散射到不同的方向，而光滑的表面会变得更加的集中。（不改变反射率便可以使高光的亮度，大小发生改变） 微表面光泽度直接影响了反射亮度的表现。这意味着艺术家可以直接在光泽度贴图直接绘制不同的变化：划痕，凹痕，磨损，磨光，等等。于此同时PBR系统不仅会改变反射的样子，也会相应地改变亮度。再也不需要“spec蒙版”“反射贴图”变化了!（从而决定了PBR和传统渲染有很大程度上的区别） 这意义重大。因为这两个真实世界中的量是基于物理相关的——微表面细节和反射度——现在第一次在艺术领域和渲染流程中被准确地联系在了一起。这十分像我们之前讲的diffusion/reflection平衡：我们可以独立的制定两个独立的值，但一但我们将它们联系起来，区别它们就会变得更加的困难。 进一步说，显示世界中的材质的反射值的变化不会很大（参见之前我们讲的关于导体的部分）。一个很好的例子是水和泥巴。都有相似的反射率，但是泥巴是十分粗糙的，但它上面的积水却很光滑，它们因为反射性不同的原因而看起来十分的不一样。在PBR系统中，艺术家主要通过gloss或者roughness贴图来区别这种不同。而不是调节反射率：就像下面一样。 参考资料 1. 基于物理渲染（PBR）的基础理论","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题3：特定深度结点链表","slug":"问题3：特定深度结点链表","date":"2020-07-08T07:53:49.000Z","updated":"2020-07-08T11:23:44.105Z","comments":false,"path":"2020/07/08/问题3：特定深度结点链表/","link":"2020/07/08/问题3：特定深度结点链表","permalink":"http://ssssshinji.github.io/2020/07/08/%E9%97%AE%E9%A2%983%EF%BC%9A%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E7%BB%93%E7%82%B9%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目描述 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。（提示在页尾） 个人思路 题目只说创建没有说返回，则可以不考虑返回值。可以用BFS遍历所有节点但是怎么样和深度产生联系呢?即使写一个函数求出深度，也不知道怎么和节点联系起来 个人解答 1无解答 题目解析 乍一看，你可能会认为这个问题需要逐一遍历，但其实并无必要。可用任意方式遍历整棵树，只需记住节点位于哪一层即可。 我们可以将前序遍历算法稍作修改，将level+1传入下一个递归调用。下面是使用深度优先搜索的实现代码。 标准解答（DFS） 12345678910111213141516171819void createLevelLinkedList(TreeNode root, ArrayList lists, int level)&#123; if(root &#x3D;&#x3D; null) return; LinkedList&lt;TreeNode&gt; list &#x3D; null; if(lists.Count &#x3D;&#x3D; level)&#123; list &#x3D; new LinkedList&lt;TreeNode&gt;(); lists.Add(list); &#125;else&#123; list &#x3D; (LinkedList&lt;TreeNode&gt;)lists[level]; &#125; list.AddLast(root); createLevelLinkedList(root.left, lists, level+1); createLevelLinkedList(root.right, lists, level+1);&#125;&#x2F;&#x2F;包装函数ArrayList createLevelLinkedList(TreeNode root)&#123; ArrayList lists &#x3D; new ArrayList(); createLevelLinkedList(root,lists,0); return lists;&#125; 另一种做法是对广度优先搜索稍加修改，即从根节点开始迭代，然后第2层，第3层，以此类推。处于第i层时，则表明我们已访问过第i-1层的所有节点，也就是说，要得到i层的节点，只需直接查看i-1层节点的所有子节点即可。 标准解答（BFS） 1234567891011121314151617181920ArrayList createLevelLinkedList(TreeNode root, int level)&#123; if(root &#x3D;&#x3D; null) return null; ArrayList result &#x3D; new ArrayList(); LinkedList&lt;TreeNode&gt; list &#x3D; new LinkedList&lt;TreeNode&gt;(); list.AddLast(root); while(list.Count !&#x3D; 0)&#123; result.Add(list); LinkedList&lt;TreeNode&gt; parents &#x3D; list; list &#x3D; new LinkedList&lt;TreeNode&gt;(); foreach(TreeNode node in parents)&#123; if(node.left !&#x3D; null)&#123; list.AddLast(node.left); &#125; if(node.right !&#x3D; null)&#123; list.AddLast(node.right); &#125; &#125; &#125; return result;&#125; 复杂度分析 两者的时间复杂度皆为O(N)，那么空间效率呢？乍一看，我们可能会以为第二种解法的空间效率更高。在某种意义上，这么说也对。第一种解法会用到O(logN)次递归调用（在平衡树中），每次调用都会在栈里增加一级。第二种解法采用迭代遍历法，不需要这部分额外空间。不过，两种解法都要返回O(N)的数据，因此，递归实现所需的额外的O(logN)空间，跟必须传回的O(N)数据相比，并不算多。虽然第一种解法确实使用了较多的空间，但从大O记法的角度来看，两者效率是一样的。 反思 这种BFS的变形是我怎么也没想到了，再看了一遍后边回忆边写还是会出错。 提示：#107，#123，#135 -尝试修改图形搜索算法，从根开始追踪深度。 -从层号映射到该层节点的散列表或数组也许有些用处。 -你应该能够提出一个既包括深度优先搜索又包含广度优先搜索的算法。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"问题精析：透明物体渲染","slug":"问题精析：透明物体渲染","date":"2020-07-07T18:01:28.000Z","updated":"2020-07-07T18:25:11.619Z","comments":false,"path":"2020/07/08/问题精析：透明物体渲染/","link":"2020/07/08/问题精析：透明物体渲染","permalink":"http://ssssshinji.github.io/2020/07/08/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E6%B8%B2%E6%9F%93/","excerpt":"","text":"丢弃片段(Discard) 些图片并不需要半透明，只需要根据纹理颜色值，显示一部分，或者不显示一部分，没有中间情况。比如说草，如果想不太费劲地创建草这种东西，你需要将一个草的纹理贴在一个2D四边形(Quad)上，然后将这个四边形放到场景中。然而，草的形状和2D四边形的形状并不完全相同，所以你只想显示草纹理的某些部分，而忽略剩下的部分。 下面这个纹理正是这样的，它要么是完全不透明的（alpha值为1.0），要么是完全透明的（alpha值为0.0），没有中间情况。你可以看到，只要不是草的部分，这个图片显示的都是网站的背景颜色而不是它本身的颜色。 所以当添加像草这样的植被到场景中时，我们不希望看到草的方形图像，而是只显示草的部分，并能看透图像其余的部分。我们想要丢弃(Discard)显示纹理中透明部分的片段，不将这些片段存储到颜色缓冲中。在此之前，我们还要学习如何加载一个透明的纹理。 要想加载有alpha值的纹理，我们并不需要改很多东西，stb_image在纹理有alpha通道的时候会自动加载，但我们仍要在纹理生成过程中告诉OpenGL，我们的纹理现在使用alpha通道了： 1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); 同样，保证你在片段着色器中获取了纹理的全部4个颜色分量，而不仅仅是RGB分量： 1234567891011121314#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main()&#123; vec4 texColor &#x3D; texture(texture1, TexCoords); if(texColor.a &lt; 0.1) discard; FragColor &#x3D; texColor;&#125; 这里，我们检测被采样的纹理颜色的alpha值是否低于0.1的阈值，如果是的话，则丢弃这个片段。片段着色器保证了它只会渲染不是（几乎）完全透明的片段。 注意，当采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE。 混合 OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。 虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用混合(Blending)。和OpenGL大多数的功能一样，我们可以启用GL_BLEND来启用混合： 1glEnable(GL_BLEND); 启用了混合之后，我们需要告诉OpenGL它该如何混合。OpenGL中的混合是通过下面这个方程来实现的： $$ C_result=C_source∗F_source+C_destination∗F_destination $$ Csource：源颜色向量。这是源自纹理的颜色向量。 Cdestination：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。 Fsource：源因子值。指定了alpha值对源颜色的影响。 Fdestination：目标因子值。指定了alpha值对目标颜色的影响。 片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。我们先来看一个简单的例子： 我们有两个方形，我们希望将这个半透明的绿色方形绘制在红色方形之上。红色的方形将会是目标颜色（所以它应该先在颜色缓冲中），我们将要在这个红色方形之上绘制这个绿色方形。 问题来了：我们将因子值设置为什么？嘛，我们至少想让绿色方形乘以它的alpha值，所以我们想要将Fsrc设置为源颜色向量的alpha值，也就是0.6。接下来就应该清楚了，目标方形的贡献应该为剩下的alpha值。如果绿色方形对最终颜色贡献了60%，那么红色方块应该对最终颜色贡献了40%，即1.0 - 0.6。所以我们将Fdestination设置为1减去源颜色向量的alpha值。这个方程变成了： $$ \\begin{pmatrix} 0.0 &amp; \\\\ 1.0 &amp; \\\\ 0.0 &amp; \\\\ 0.6 &amp; \\\\ \\end{pmatrix} * 0.6 + \\begin{pmatrix} 1 &amp; \\\\ 0 &amp; \\\\ 0 &amp; \\\\ 1 &amp; \\\\ \\end{pmatrix} * (1-0.6) $$ 结果就是重叠方形的片段包含了一个60%绿色，40%红色的一种脏兮兮的颜色： 最终的颜色将会被储存到颜色缓冲中，替代之前的颜色。 glBlendFunc(GLenum sfactor, GLenum dfactor)函数接受两个参数，来设置源和目标因子。OpenGL为我们定义了很多个选项。 半透明物体遮挡问题 最前面窗户的透明部分遮蔽了背后的窗户？这为什么会发生呢？ 深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。 所以我们不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题了。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，我们需要首先绘制背后的这部分窗户。这也就是说在绘制的时候，我们必须先手动将窗户按照最远到最近来排序，再按照顺序渲染。 注意，对于草这种全透明的物体，我们可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）。 要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下： 1.先绘制所有不透明的物体。 2.对所有透明的物体排序。 3.按顺序绘制所有透明的物体。(从远到近，右手坐标系来说是-z到+z) 参考资料 1. 混合","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题3：删除中间节点","slug":"问题3：删除中间节点","date":"2020-07-07T16:46:15.000Z","updated":"2020-07-07T17:17:00.831Z","comments":false,"path":"2020/07/08/问题3：删除中间节点/","link":"2020/07/08/问题3：删除中间节点","permalink":"http://ssssshinji.github.io/2020/07/08/%E9%97%AE%E9%A2%983%EF%BC%9A%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目描述 实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。示例：（提示在页尾） 示例： 12输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c结果：不返回任何数据，但链表变为a-&gt;b-&gt;d-&gt;e-&gt;f 个人思路 删除操作需要知道被删除节点前面和后面的两个节点。由题意可知是单向链表，只能得知后面的节点。如果链表长度已知，则可以记录该节点之后的节点数目，长度减去该数目，可以计算出前面的节点。不过要求输入的参数为单个节点c，如何知道c和链表之间，头节点之间的联系呢？百思不得 个人解答 1无思路 题目解析 在这个问题中，你访问不到链表的首节点，只能访问那个待删除节点。解法很简单，直接将后继节点的数据复制到当前节点，然后删除这个后继节点。 标准解答 123456789 void DeleteMidNode(LinkedListNode&lt;T&gt; node)&#123; if(node &#x3D;&#x3D; null || null.next &#x3D;&#x3D; null)&#123; return false; &#125; LinkedListNode&lt;T&gt; next &#x3D; node.next; node.data &#x3D; next.data; node.next &#x3D; next.next; &#125;&#125; 复杂度分析 O(1)。 反思 思考的时候是从list的api入手的，只想着如何得到前一个结点。思维太固化了，应该还是积累不够的原因。 提示：#72 -列出清单1-&gt; 5-&gt; 9-&gt; 12。删除9会使它看起来像1-&gt; 5-&gt; 12。你只能访问9节点。你能让它看起来像正确的答案吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"问题精析：View矩阵的推导","slug":"问题精析：View矩阵的推导","date":"2020-07-06T16:48:32.000Z","updated":"2020-07-06T17:48:05.359Z","comments":false,"path":"2020/07/07/问题精析：View矩阵的推导/","link":"2020/07/07/问题精析：View矩阵的推导","permalink":"http://ssssshinji.github.io/2020/07/07/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AView%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"概念 观察空间(view space)也被称为摄像机空间，在观察空间中，摄像机位于原点，它决定了我们渲染游戏所使用的视角。前面说过，观察空间采用的是右手坐标系，所以+z轴指的是摄像机后方。（摄像机看着-z。unity和OpenGL都采用这种右手坐标系。顺带一提，unity里除了观察空间，都是左手坐标系。OpenGL则是除了NDC，都是右手坐标系。）顶点变化的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换叫观察变换(view transform)。 为了得到顶点在观察空间的位置，我们可以有两种方法。 一种方法是计算观察空间的三个坐标轴在世界空间的表示，然后按照“坐标空间的变换”的方法算出观察空间到世界空间的变换矩阵，再求逆得住世界空间到观察空间的变换矩阵。 第二种方法是平移整个观察空间，让摄像机原点位于世界空间原点，坐标轴与世界空间坐标轴重合。两种方法得到的变换矩阵是一样的。(一般采取第二种，比较直观) 第一种方法 UVN系统：本身是一个基。如下图所示，三个基向量U，V，N分别指向相机的右方、上方和后方从而构成右手坐标系，相机则处于坐标原点。 在参考系下（这里是世界坐标系），我们给定相机的位置——eye，被观察的小人的位置——lookat，以及一个辅助向量——参考系中表示“上方”的向量up，这个向量会影响U和V的生成，因为以后求出的V向量会在up和N向量所决定的平面上，所以可以通过这个向量让相机产生不同的偏转。 首先我们求出向量\\vec {N}： $$ \\vec {N} = lookat - eye $$ 然后，我们求出向量\\vec {U}。这一步需要使用辅助向量up，如果不希望相机产生偏转，一般取(0, 1, 0)： $$ \\vec {U} = \\vec {up} \\times \\vec {N}; $$ U使用向量的叉乘实现。最后，使用N和U计算出向量\\vec {V}： $$ \\vec {V} = \\vec {N} \\times \\vec {U}; $$ 按照“坐标空间的变换”的方法进行坐标系转换，并配合平移矩阵，便得到了观察矩阵。 第二种方法 要理解这个方法，重要的一点是，想象摄像机和场景中的每个物体都有一根棍子连接在一起，所谓的平移整个观察空间，是指摄像机带动场景内的物体一起移动，直到摄像机移动到坐标原点（屏幕中央），这时我们看到的屏幕就是摄像机的视角了。 举例：摄像机在世界空间中的变换是按(30,0,0)进行旋转，然后按(0,10,-10)进行了平移。那么，为了把摄像机重新移动回初始状态。（指原点位于世界坐标的原点，坐标轴和世界空间的坐标轴重合）我们需要进行逆向变换，即先按(0，-10，10)平移，以便摄像机回到原点，再按(-30,0,0)进行旋转，以便让坐标轴重合。因此，变换矩阵就是： $$ \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; cos\\theta &amp; -sin\\theta &amp; 0 \\\\ 0 &amp; sin\\theta &amp; cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; 0 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{pmatrix} $$ 如果在unity中，因为左右手坐标系的变化，还需要对z轴取负。 $$ \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; 0 &amp; t_y \\\\ 0 &amp; 0 &amp; -1 &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{pmatrix} $$ 参考资料 1. Unity Shader 入门精要 冯乐乐著 2. JungHyun Han - 3D Graphics for Game Programming-CRC Press (2011) 2. 观察矩阵推导","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题4：回文排列","slug":"问题4：回文排列","date":"2020-07-06T15:33:45.000Z","updated":"2020-07-06T16:48:09.065Z","comments":false,"path":"2020/07/06/问题4：回文排列/","link":"2020/07/06/问题4：回文排列","permalink":"http://ssssshinji.github.io/2020/07/06/%E9%97%AE%E9%A2%984%EF%BC%9A%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/","excerpt":"","text":"题目描述 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。 示例： 12输入:Tact Coa输出:True(排列有&quot;taco cat&quot;,&quot;atco cta&quot;,等等) 个人思路 和判断是否为回文字符串的题目有所区别，这道题的范围更广，要分辨其是否能重新排列成回文字符串。也可以利用数组，记录每个字符的出现次数，应该都是偶数次或者有一个为奇数次。 个人解答 1234567891011121314bool IsPermutationOfPalindrome(string str)&#123; char [] charSet &#x3D; new char[128]; for(int i &#x3D; 0; i &lt; str.Length; i++)&#123; charSet[str[i]] ++; &#125; int count &#x3D; 0; for(int i &#x3D; 0; i &lt; charSet.Length;i++)&#123; if(charSet[i]%2 &#x3D;&#x3D; 1)&#123; count ++; &#125; if(count &gt; 1)return false; &#125; return true;&#125; 题目解析 怎样才能给出一个正、反两个方向都一致的字符序列呢？对于大多数的字符，都必须出现偶数次，这样才能使得其中一半构成字符串的前半部分，另一半构成字符串的后半部分。至多只能有一个字符（即中间的字符）可以出现奇数次。例如，我们知道tactcoapapa是一个回文排列，因为该字符串有2个t、4个a、2个c、2个p以及1个o，其中o将会成为潜在的回文串的中间字符。 更准确地说，所有偶数长度的字符串（不包括非字母字符）所有的字符必须出现偶数次。奇数长度的字符串必须刚好有一个字符出现奇数次。当然，偶数长度的字符串不可能只包括一个出现奇数次的字符，否则其不会为偶数长度（一个出现奇数次的字符+若干个出现偶数次的字符=奇数个字符）。以此类推，奇数长度的字符串不可能所有的字符都出现偶数次（偶数的和仍然是偶数）。因此我们可以得知，一个回文串的排列不可能包含超过一个“出现奇数次的字符”。该推论同时涵盖了奇数长度和偶数长度字符串的例子。 标准解答 1234567891011121314&#x2F;&#x2F;和我的解答基本相同，多了对大小写的不敏感&#x2F;&#x2F;检查奇数个数的方法写的更简洁bool checkMaxOneOdd(int[] charSet)&#123; bool foundOdd &#x3D; false; foreach(int count in charSet)&#123; if(count % 2 &#x3D;&#x3D; 1)&#123; if(foundOdd)&#123; return false; &#125; foundOdd &#x3D; true; &#125; &#125; return true;&#125; 复杂度分析 O(n)。 解法2：任何算法都要遍历整个字符串，因此，无法对时间复杂度再进行优化，但可稍作优化。因为该题目相对简单，所以有必要对其稍作优化或调整。可以在遍历的同时检查是否有字符只出现了奇数次，而不需要在遍历结束时再进行检查。因此，在一次遍历结束时，我们即有了答案。 标准解答 1234567891011121314bool IsPermutationOfPalindrome(string str)&#123; int countOdd &#x3D; 0; int[] table &#x3D; new int[(int)(Char.GetNumericValue(&#39;z&#39;) - Char.GetNumericValue(&#39;a&#39;)+1)]; foreach(char c in str.ToCharArray())&#123; int x &#x3D; getCharNumber(c);&#x2F;&#x2F;使大小写不敏感的函数 if(x !&#x3D; -1)&#123; table[x]++; if(table[x] % 2 &#x3D;&#x3D; 1)&#123; countOdd++; &#125;else&#123;countOdd--;&#125; &#125; &#125; return countOdd &lt;&#x3D; 1;&#125; 需要清楚说明的是，该算法并不一定更优。该算法有着相同的时间复杂度，而且可能还会稍慢一些。我们最终没有遍历散列表，但是对于单个字符加入了几行额外的代码。你应该将该算法作为备选项而非最优解与面试官进行讨论。 解法3:如果你能更深入地思考该问题，或许会注意到字符出现的个数无关紧要。重要的是，字符出现是偶数次还是奇数次。你可以将其想象为开灯与关灯的操作（初始状态下灯是关着的）。如果灯最后是关闭状态，并不需要知道对其进行了多少次的开关操作，只需知道操作的次数是偶数次的。 因此，可以在本题中使用一个整数数值（或者位向量）。每当看到一个字符，就将其映射到0与26之间的一个数值（假设所有字符都是英语字母），然后切换该数值对应的比特位。在遍历结束后，需要检查是否最多只有一个比特位被置为1。 判断整数数值中没有比特位为1易如反掌，只需将整数数值与0进行比较。判断整数数值中是否刚好有一个比特位为1，则有一个很巧妙的办法。 例如有一个整数数值00010000。我们当然可以通过重复的移位操作判断是否只有一个比特位为1。另一种方法是，如果将该数字减1，则会得到00001111。可以发现，这两个数字之间比特位没有重叠（而对于00101000，将其减1会得到00100111，比特位发生了重叠）。因此，判断一个数是否刚好有一个比特位为1，可以通过将其减1的结果与该数本身进行与操作，如果其结果为0，则比特位中1刚好出现一次。 反思 对算法的优化以及位运算还不是很熟悉。 提示：#106，#121，#134，#136 -不必且也不应该生成所有的排列。这将极为低效。 -作为回文排列的字符串有什么特征？ -你试过散列表吗？你应该能把它降到O(N)的时间。 -使用位向量可以减少空间使用吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：Mipmap","slug":"问题精析：Mipmap","date":"2020-07-05T18:08:36.000Z","updated":"2020-07-05T18:17:48.009Z","comments":false,"path":"2020/07/06/问题精析：Mipmap/","link":"2020/07/06/问题精析：Mipmap","permalink":"http://ssssshinji.github.io/2020/07/06/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AMipmap/","excerpt":"","text":"概念 想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。 OpenGL使用一种叫做**多级渐远纹理(Mipmap)**的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的： 手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。 在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式： 过滤方式 描述 GL_NEAREST_MIPMAP_NEAREST 使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样 GL_LINEAR_MIPMAP_NEAREST 使用最邻近的多级渐远纹理级别，并使用线性插值进行采样 GL_NEAREST_MIPMAP_LINEAR 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样 GL_LINEAR_MIPMAP_LINEAR 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。 GL_TEXTURE_MIN_FILTER方式下，param有6种:不过上述4种都必须定义了Mipmap才能使用 如何选择合适的mipmap层？ 计算一个像素与其所覆盖的纹理区域的面积比例（取x,y方向上的最大缩放值），由此选定mipmap层。 如何生成Mipmap纹理？ 可以自己程序来生成，或者: 1.自己调用gluScaleImage()来逐级生成； 2.然后通过glTexImage2D(GLenum target,GLint level,…);进行加载 OpenGL3.0及以后，可使用glGenerateMipmap(GLenum target)来生成当前纹理的mipmap。也就是将mipmap从glu库中提到了核心库中！（现在常用此方法） Mipmap存在的问题 如果覆盖区域非常狭长，与正方形相差较大，效果不好。 克服方法：各向异性滤波 非均向性（anisotropy),或作各向异性，与各向同性相反，指问题的全部或部分物理、化学等性质方向的不同而有所变化的特性，例如石墨单晶的电导率在不同方向的差异可达到数千倍，又如天文学上，宇宙微波背景辐射亦拥有些微的非均向性。许多的物理量都具有非均向性，如弹性模量、点导率、在酸中的溶解速度等。 各向异性扩散滤波主要是用来平滑图像的，克服了高斯模糊的缺陷，各向异性扩散在平滑图像时是保留图像边缘的，和双边滤波很像。 参考资料 1. 纹理 2. 《图形编程技术学习》（五十一）Mipmap","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：URL编码规则与规范","slug":"问题精析：URL编码规则与规范","date":"2020-07-05T17:02:43.000Z","updated":"2020-07-05T17:59:47.185Z","comments":false,"path":"2020/07/06/问题精析：URL编码规则与规范/","link":"2020/07/06/问题精析：URL编码规则与规范","permalink":"http://ssssshinji.github.io/2020/07/06/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AURL%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99%E4%B8%8E%E8%A7%84%E8%8C%83/","excerpt":"","text":"为什么要编码？ **通常如果一样的东西需要编码，就说明这样的东西并不适合传输。**URL只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。 RFC 1738 规定 &quot;…Only alphanumerics [0-9a-zA-Z], the special characters &quot;$-.+!*'(),&quot; [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.&quot; “只有字母和数字[0-9a-zA-Z]、一些特殊符号“$-.+!*'(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。” (RFC3986文档规定，URL中只允许包含英文字母（a-zA-Z）、数字（0-9）、- _ . ~4个特殊字符以及所有的保留字符。) 这意味着如果URL存在汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致“URL编码”成为了一个混乱的领域。(之后详述) 另一方面，如果我的参数值中就包含=或者&amp;这样的特殊子字符的时候，该怎么办。比如说“name1=value1”,其中value1的值是“va&amp;lu=e1”，那么在传输过程中就会变成“name1=va&amp;lu=e1”。用户传输的本意是只有一个键值对，但是服务器端会解析成两个键值对，这样就自然的产生了歧义。 为了解决上述问题，我们就需要对URL进行编码。 URL 是如何编码的？ URL 编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。 URL编码只是简单的在特殊字符的各个字节（16进制）前加上”%”即可。例如，我们对上述会产生歧义的字符进行编码后的结果：name1=va%26lu%3D，这样服务器会把紧跟在”%”后的字节当成普通的字节，不会把它当成各个参数或键值对的分隔符。 首先需要把该字符的 ASCII 的值表示为两个16进制的数字，然后在其前面放置转义字符(“%”)，置入 URL 中的相应位置。(对于非 ASCII 字符, 需要转换为 UTF-8(或其他编码方式) 字节序, 然后每个字节按照上述方式表示。) 另外一个问题是，为什么要用ASCII码传输，可不可以用别的编码？ 当然可以用别的编码，你可以自己开发一套编码然后自己进行解析。就像大部分国家都有自己的语言一样。但是国家之间要怎么进行交流呢，用英语吧，英语的使用范围最广。 URL编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符 哪些字符需要编码？ US-ASCII字符集中没有对应的可打印字符 URL中只允许使用可打印的字符。US-ASCII码中的10-7F字节全都表示控制字符，这些字符不能直接出现在URL中。同时对于80-FF字节，由于已经超出了ASCII码定义字符的范围，因此也不能放在URL中。 保留字符:RFC3986中指定了以下字符为保留字符： ！ * ’ ( ) ; : @ &amp; = + $ , / ? # [ ] URL可以划分为干了组件，协议、主机、路径等。有一些字符（： / ? # [ ] @）是用作分隔不同组件的。例如：冒号用于分隔协议和主机组件，斜杠用于分隔主机和路径，问号用于分隔路径和查询参数，等等。还有一些字符（! $ &amp; * + , ; =）用于在每个组件中起到分隔作用，如等号用于表示查询参数中的键值对，&amp;符号用于分隔查询多个键值对。当组件中的普通数据包含这些特殊字符时，需要对其进行编码。 不安全字符 还有一些字符，当他们直接放在URL中的时候，可能会引起解析程序的歧义。这些字符被视为不安全的字符，原因有很多。 空格：URL在传输的过程，或者用户在排版的过程中，或者文本处理程序在处理URL的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。 引号 以及 &lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔URL的作用。 #：通常用于表示书签或者锚点。 %：百分号本身用作对不安全的字符进行编码是使用的特殊字符，因此本身需要编码。 { } | \\ ^ [ ] ’ ~：某一些网关或者传输代理会篡改这些字符 空格编码问题 一个URL的基本组成部分包括协议(scheme),域名，端口号，路径和查询字符串（路径参数和锚点标记就暂不考虑了）。路径和查询字符串之间用问号?分离。例如http://www.example.com/index?param=1，路径为index，查询字符串(Query String)为param=1。URL中关于空格的编码正是与空格所在位置相关：空格被编码成加号+的情况只会在查询字符串部分出现，而被编码成%20则可以出现在路径和查询字符串中。 造成这种混乱局面的原因在于：W3C标准规定，当Content-Type为application/x-www-form-urlencoded时，URL中查询参数名和参数值中空格要用加号+替代，所以几乎所有使用该规范的浏览器在表单提交后，URL查询参数中空格都会被编成加号+。而在另一份规范(RFC 2396，定义URI)里, URI里的保留字符都需转义成%HH格式(Section 3.4 Query Component)，因此空格会被编码成%20，加号+本身也作为保留字而被编成%2B，对于某些遵循RFC 2396标准的应用来说，它可能不接受查询字符串中出现加号+，认为它是非法字符。所以一个安全的举措是URL中统一使用%20来编码空格字符。 Java中的URLEncoder本意是用来把字符串编码成application/x-www-form-urlencoded MIME格式字符串，也就是说仅仅适用于URL中的查询字符串部分，但是URLEncoder经常被用来对URL的其他部分编码，它的encode方法会把空格编成加号+，与之对应的是，URLDecoder的decode方法会把加号+和%20都解码为空格，这种违反直觉的做法造成了当初我对空格URL编码问题的困扰。因此后来我的做法都是，在调用URLEncoder.encode对URL进行编码后(所有加号+已被编码成%2B)，再调用replaceAll(“\\+”, “%20″)，将所有加号+替换为%20。 中文编码问题 如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致“URL编码”成为了一个混乱的领域。 下面就让我们看看，“URL编码”到底有多混乱。我会依次分析四种不同的情况，在每一种情况中，浏览器的URL编码方法都不一样。把它们的差异解释清楚之后，我再说如何用Javascript找到一个统一的编码方法。 情况1：网址路径中包含汉字 打开IE（我用的是8.0版），输入网址“http://zh.wikipedia.org/wiki/春节 ”。注意，“春节”这两个字此时是网址路径的一部分。查看HTTP请求的头信息，会发现IE实际查询的网址是“http://zh.wikipedia.org/wiki/春节 ”。也就是说，IE自动将“春节”编码成了“%E6%98%A5%E8%8A%82”。 我们知道，“春”和“节”的utf-8编码分别是“E6 98 A5”和“E8 8A 82”，因此，“%E6%98%A5%E8%8A%82”就是按照顺序，在每个字节前加上%而得到的。 结论1就是，网址路径的编码，用的是utf-8编码。 情况2：查询字符串包含汉字 在IE中输入网址“http://www.baidu.com/s?wd=春节 ”。注意，“春节”这两个字此时属于查询字符串，不属于网址路径，不要与情况1混淆。查看HTTP请求的头信息，会发现IE将“春节”转化成了一个乱码。切换到十六进制方式，才能清楚地看到，“春节”被转成了“B4 BA BD DA”。 我们知道，“春”和“节”的GB2312编码（我的操作系统“Windows XP”中文版的默认编码）分别是“B4 BA”和“BD DA”。因此，IE实际上就是将查询字符串，以GB2312编码的格式发送出去。“%E6%98%A5%E8%8A%82”就是按照顺序，在每个字节前加上%而得到的。Firefox的处理方法，略有不同。它发送的HTTP Head是“wd=%B4%BA%BD%DA”。也就是说，同样采用GB2312编码，但是在每个字节前加上了%。 结论2就是，查询字符串的编码，用的是操作系统的默认编码。 情况3：Get方法生成的URL包含汉字 前面说的是直接输入网址的情况，但是更常见的情况是，在已打开的网页上，直接用Get或Post方法发出HTTP请求。 根据台湾中兴大学吕瑞麟老师的试验 ，这时的编码方法由网页的编码决定，也就是由HTML源码中字符集的设定决定。 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=xxxx\"&gt; 如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。举例来说，百度是GB2312编码，Google是UTF-8编码。因此，从它们的搜索框中搜索同一个词“春节”，生成的查询字符串是不一样的。 结论3就是，GET和POST方法的编码，用的是网页的编码。 情况4：Ajax调用的URL包含汉字 前面三种情况都是由浏览器发出HTTP请求，最后一种情况则是由Javascript生成HTTP请求，也就是Ajax调用。还是根据吕瑞麟老师的文章，在这种情况下，IE和Firefox的处理方式完全不一样。 举例来说，有这样两行代码： 12url &#x3D; url + &quot;?q&#x3D;&quot; +document.myform.elements[0].value; &#x2F;&#x2F; 假定用户在表单中提交的值是“春节”这两个字http_request.open(&#39;GET&#39;, url, true); 那么，无论网页使用什么字符集，IE传送给服务器的总是“q=%B4%BA%BD%DA”，而Firefox传送给服务器的总是“q=%E6%98 %A5%E8%8A%82”。也就是说，在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。这就是我们的结论4。 参考资料 1. URL 如何编码解码？为什么要编码？ 2. 为什么要进行URL编码 3. 关于URL编码 对空格的处理问题 4. URL中文编码问题","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"问题2：返回倒数第k个节点","slug":"问题2：返回倒数第k个节点","date":"2020-07-05T15:51:27.000Z","updated":"2020-07-05T17:00:59.821Z","comments":false,"path":"2020/07/05/问题2：返回倒数第k个节点/","link":"2020/07/05/问题2：返回倒数第k个节点","permalink":"http://ssssshinji.github.io/2020/07/05/%E9%97%AE%E9%A2%982%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目描述 返回倒数第k个节点。实现一种算法，找出单向链表中倒数第k个节点。（提示在页尾） 个人思路 经典双指针问题。 个人解答 123456789101112131415Node FindLast_Kth(List list,int k)&#123; if(list.Length &lt; k)&#123; return null; &#125; Node first &#x3D; list.head; Node second &#x3D; list.head; for(int i &#x3D; 0; i &lt; k; i++)&#123; first &#x3D; first.next; &#125; while(first.next !&#x3D; null)&#123; first &#x3D; first.next; second &#x3D; second.next; &#125; return second;&#125; 题目解析 下面会以递归和非递归的方式解决这个问题。一般来说，递归解法更简洁，但效率低下。例如，就这个问题来说，递归解法的代码量大概只有迭代解法的一半，但要占用O(n)的空间，其中n为链表中节点个数。 注意，在下面的解法中，k定义如下：传入k=1将返回最后一个节点，k=2返回倒数第二个节点，以此类推。当然，也可以将k定义为k=0返回最后一个节点。 解法1：链表长度已知 若链表长度已知，那么，倒数第k个节点就是第(length - k)个节点。直接迭代访问链表就能找到这个节点。不过，这个解法太过简单了，不大可能是面试官想要的答案。 解法2：递归 这个算法会递归访问整个链表，当抵达链表末端时，该方法会回传一个设置为0的计数器。之后的每次调用都会将这个计数器加1。当计数器等于k时，表示我们访问的是链表倒数第k个元素。 实现代码简洁明了，前提是我们要有办法通过栈“回传”一个整数值。可惜，无法用一般的返回语句回传一个节点和一个计数器，那该怎么办？ 方法A:不返回该元素 一种方法是对这个问题略作调整，只打印倒数第k个节点的值。然后，直接通过返回值传回计数器值。 标准解答 12345678910int printKthToLast(Node head, int k)&#123; if(head &#x3D;&#x3D; null)&#123; return 0; &#125; int index &#x3D; printKthToLast(head.next, k)+1; if(index &#x3D;&#x3D; k)&#123; System.Console.WriteLine(k+&quot;th to last node is&quot; + head.data); &#125; return index;&#125; 当然，只有得到面试官的首肯，这个解法才算有效。 方法B:使用C++ 另一种方法是使用C++，并通过引用传值。这样一来，就可以返回节点值，而且也能通过传递指针更新计数器。 方法C:使用包裹类 前面提到，这里的难点在于无法同时返回计数器和索引值。如果用一个简单的类（或一个单元素数组）包裹计数器值，就可以模仿如何通过引用传递。 标准解答 12345678910111213141516class Index&#123; public int value &#x3D; 0;&#125;Node kthTolast(Node head, int k)&#123; Index idx &#x3D; new Index(); return kthTolast(head,k,idx);&#125;Node kthTolast(Node head, int k, Index idx)&#123; if(head &#x3D;&#x3D; null) return null; Node node &#x3D; kthTolast(head.next,k,idx); idx.value &#x3D; idx.value + 1; if(idx.value &#x3D;&#x3D; k)&#123; return head; &#125; return node;&#125; 因为有递归调用，这些递归解法都需要占用O(n)的空间。 解法3：迭代 同个人思路。 反思 这次有记得处理边界情况。不过因为遇到过类似的题，没有去思考有没有别的做法。递归的解法又给了我一些启发。 提示：#8，#25，#41，#67，#126 -如果你知道链表大小，会怎么样？找到最后第k个元素和找到第x个元素有何区别？ -如果你不知道链表的大小，你能计算它吗？这将如何影响运行时间？ -尝试用递归法实现。如果你能找到(k-1)到最后一个元素，可以找到第k个元素吗？ -你可能会发现返回多个值大有用处。有些语言不直接支持这一点，但基本上使用任何语言都有解决方法。这些解决方法有哪些？ -你能通过递归做到吗？想象一下，如果有两个指针指向相邻节点，它们通过链表以相同的速度移动。当一个到达链表的结尾时，另一个在哪里？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"问题3：URL化","slug":"问题3：URL化","date":"2020-07-05T05:42:41.000Z","updated":"2020-07-05T15:44:32.698Z","comments":false,"path":"2020/07/05/问题3：URL化/","link":"2020/07/05/问题3：URL化","permalink":"http://ssssshinji.github.io/2020/07/05/%E9%97%AE%E9%A2%983%EF%BC%9AURL%E5%8C%96/","excerpt":"","text":"题目描述 编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。） 示例： 12输入:&quot;Mr John Smith &quot;,13输出:&quot;Mr%20John%20Smith&quot; 个人思路 主要的是知道URL编码的转换规则，以及对一些特殊字符的转义处理。 个人解答 1无思路 题目解析 处理字符串操作问题时，常见做法是从字符串尾部开始编辑，从后往前反向操作。该做法是上佳之选，因为字符串尾部有额外的缓冲，可以直接修改，不必担心会覆写原有数据。 我们将采用上面这种做法。该算法会进行两次扫描。第一次扫描先数出字符串中有多少空格，从而算出最终的字符串长度。第二次扫描才真正开始反向编辑字符串。如果检测到空格，就将%20复制到下一个位置；若不是空格，就复制原先的字符。 标准解答 123456789101112131415161718192021222324public static void replaceSpaces(char[] str, int trueLength)&#123; int spaceCount &#x3D; 0,index &#x3D; 0,i; for(i &#x3D; 0;i&lt;trueLength;i++)&#123; if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123; spaceCount++; &#125; &#125; index &#x3D; trueLength + 2*spaceCount; char[] result &#x3D; new char[index]; for(i &#x3D; trueLength - 1; i &gt;&#x3D; 0; i--)&#123; System.Console.WriteLine(&quot;index:&quot; + index); System.Console.WriteLine(&quot;i:&quot; + i); if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123; result[index - 1] &#x3D; &#39;0&#39;; result[index - 2] &#x3D; &#39;2&#39;; result[index - 3] &#x3D; &#39;%&#39;; index &#x3D; index - 3; &#125;else&#123; result[index - 1] &#x3D; str[i]; index--; &#125; System.Console.WriteLine(result); &#125;&#125; 复杂度分析 O(n)。 反思 忽略了在进行编码后数组长度会有所改变。不过原书算法好像有点问题，偶尔会数组溢出，这里为自己写的版本。顺便一提c#中string和char[]做参数的区别: 用string[]表示字符串中相应位置的字符时，仅可读，而char[]是可读写的。并且string和char[]在形参中不能互相转换，要利用string.ToCharArray()和char[].ToString()。 提示：#53，#118 -从尾到头开始修改字符串通常最容易。 -你可能需要知道空格的数量。你能数一下吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：OpenGL纹理采样模式","slug":"问题精析：OpenGL纹理采样模式","date":"2020-07-03T14:09:53.000Z","updated":"2020-07-05T17:07:37.234Z","comments":false,"path":"2020/07/03/问题精析：OpenGL纹理采样模式/","link":"2020/07/03/问题精析：OpenGL纹理采样模式","permalink":"http://ssssshinji.github.io/2020/07/03/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AOpenGL%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"背景及概念 我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。 为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。 纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。 我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。 对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉OpenGL该怎样对纹理采样。 纹理环绕方式 环绕方式 描述 GL_REPEAT 对纹理的默认行为。重复纹理图像。 GL_MIRRORED_REPEAT 和GL_REPEAT一样，但每次重复图片是镜像放置的。 GL_CLAMP_TO_EDGE 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。 GL_CLAMP_TO_BORDER 超出的坐标为用户指定的边缘颜色。 前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT); 第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。 如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值： 12float borderColor[] &#x3D; &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); 纹理过滤 纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。 Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。 GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色： GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色： GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 参考资料 1. 纹理","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：递归和迭代","slug":"问题精析：递归和迭代","date":"2020-07-03T10:12:32.000Z","updated":"2020-07-05T17:07:45.617Z","comments":false,"path":"2020/07/03/问题精析：递归和迭代/","link":"2020/07/03/问题精析：递归和迭代","permalink":"http://ssssshinji.github.io/2020/07/03/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3/","excerpt":"","text":"递归(recursion) 简而言之就是一种函数调用函数自身来完成算法设计的方法。是把问题转化为规模缩小了的同类问题的子问题。然后递归调用函数（或过程）来表示问题的解。 递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。 递归的标准模式（有可对函数的入口进行测试的基本情况） 1234if (条件) return (不需要递归的简单答案);else return (递归调用同一函数)； - 必须有递归终止的条件。 - 函数决定终止的参数有规律地递增或递减。 在数据结构中，链表和二叉树都具备鲜明的递归特性。 直接递归 也即是普通递归，单向递归，线性递归函数的最后一步操作不是递归操作，而是其他的操作。当数据量很大的时候，会造成栈溢出，这是因为，在每次递归调用时，递归函数中的参数，局部变量等都要保存在栈中，如果数据量很大的话，便可能会溢出。 尾递归 也即是线性迭代，尾递归函数的最后一步操作是递归，也即在进行递归之前，把全部的操作先执行完，这样的好处是，不用花费大量的栈空间来保存上次递归中的参数、局部变量等，这是因为上次递归操作结束后，已经将之前的数据计算出来，传递给当前的递归函数，这样上次递归中的局部变量和参数等就会被删除，释放空间，从而不会造成栈溢出。但是很多编译器并没有自动对尾递归优化的功能，也即当编译器判断出当前所执行的操作是递归操作时，不会理会它究竟是线性递归还是尾递归，这样也就不会删除掉之前的局部变量和参数等。另外，尾部递归一般都可转化为循环语句。 尾递归的原理：当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。 直接递归与尾递归的对比 一般来说，线性递归和尾递归的时间复杂度相差不大（当然也有例外情况，比如斐波拉契数列，这是因为其线性递归的实现，产生了大量冗余的计算，它的时间复杂度为指数级，而其尾递归的实现只需要线性级别的时间复杂度）。线性递归容易理解，尾部递归性能比较好。 但尾递归的空间复杂度比较小（这是在假定尾递归被优化的前提下）。尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如sum(n) = f(n) = f(n-1) + value(n) ;会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。 123456789线性递归int fact(int n) &#123; if (n &lt; 0) return 0; else if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return 1; else return n * fact(n - 1);&#125; 123456789101112尾递归int facttail(int n, int res)&#123; if (n &lt; 0) return 0; else if(n &#x3D;&#x3D; 0) return 1; else if(n &#x3D;&#x3D; 1) return res; else return facttail(n - 1, n *res);&#125; 在每次函数调用计算n倍的(n－1)!的值，让n=n－1并持续这个过程直到n=1为止。这种定义不是尾递归的，因为每次函数调用的返回值都依赖于用n乘以下一次函数调用的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。 函数比代码1多个参数res，除此之外并没有太大区别。res（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令res=n*res并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回res即可。 迭代(iteration) 重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B） 迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。 迭代的准备工作（同循环语句类似）： - 确定迭代变量； - 建立迭代关系式； - 对迭代过程进行控制。 递归与迭代对比 - 迭代程序复杂，但效率高。 - 递归程序逻辑清晰，但往往效率较低(空间复杂度高)。 迭代和递归均包括终止条件测试，迭代在循环继续条件失败时终止，递归在达到基本情况时终止。计数器控制的循环和迭代和递归都是逐步达到终止的。迭代修改计数器直到计数器的值使循环条件不满足；递归产生比原来的问题简单的版本直到达到基本情况。 递归与迭代相互转换 理论上递归和迭代可以相互转换，但实际从算法结构来说，递归声明的结构并不总能转换为迭代结构（原因有待研究）。迭代可以转换为递归，但递归不一定能转换为迭代。 将递归算法转换为非递归算法有两种方法，一种是直接求值（迭代/循环），不需要回溯；另一种是不能直接求值，需要回溯。前者使用一些变量保存中间结果，称为直接转换法；后者使用栈保存中间结果，称为间接转换法，下面分别讨论这两种方法。 直接转换法 直接转换法通常用来消除尾递归（tail recursion）和单向递归，将递归结构用迭代结构来替代。（单向递归 → 尾递归 → 迭代） 斐波那契数列的递归求解： 1234 int Fib(int n) &#123; if(n &lt;&#x3D; 1) return n; else return Fib(n - 1) + Fib(n - 2); &#125; 转化为迭代求解： 123456789101112int Fib(int n) &#123; if(n &lt;&#x3D; 1) return n; int twoBack &#x3D; 0; int oneBack &#x3D; 1; int cur; for(int i &#x3D; 2;i &lt; &#x3D; n; i++) &#123; cur &#x3D; twoBack + oneBack; twoBack &#x3D; oneBack; oneBack &#x3D; cur; &#125; return cur;&#125; 间接转换法 递归实际上利用了系统堆栈实现自身调用，我们通过使用栈保存中间结果模拟递归过程，将其转为非递归形式。 12345678910将初始状态s0进栈 while (栈不为空) &#123; 退栈，将栈顶元素赋给s; if (s是要找的结果) 返回; else &#123; 寻找到s的相关状态s1; 将s1进栈 &#125; &#125; 间接转换法在数据结构中有较多实例，如二叉树遍历算法的非递归实现、图的深度优先遍历算法的非递归实现等等。 参考资料 1. 浅析线性递归和尾递归 2. 递归和尾递归的区别和原理 3. 经典算法｜递归和递归消除的迭代法 4. 递归算法转换为非递归算法 5. 递归与迭代的区别","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题1：三合一","slug":"问题1：三合一","date":"2020-07-03T07:35:04.000Z","updated":"2020-07-03T10:10:25.183Z","comments":false,"path":"2020/07/03/问题1：三合一/","link":"2020/07/03/问题1：三合一","permalink":"http://ssssshinji.github.io/2020/07/03/%E9%97%AE%E9%A2%981%EF%BC%9A%E4%B8%89%E5%90%88%E4%B8%80/","excerpt":"","text":"题目描述 描述如何只使用一个数组来实现三个栈（提示在页尾） 个人思路 最简单的想法是把一个数组分成三个部分。一：将新元素放在a[0]，并将已有元素往后移动。二：将新元素放在a[n]，并将已有元素往前移动。三：放在中间位置并向左或向右移动？或者按kn,k(n+1),k(n+2)的分类方法将数组分成三个部分，每一个部分存储一个栈。 题目解析 和许多问题一样，这个问题的解法基本上取决于你要对栈支持到什么程度。若每个栈分配的空间大小固定，就能满足需要，那么照做便是。不过，这么做的话，有可能其中一个栈的空间不够用了，其他的栈却几乎是空的。另一种做法是弹性处理栈的空间分配，但这么一来，这个问题的复杂度又会大大增加。 方法1：固定分割： 将整个数组划分为三等份，并将每个栈的增长限制在各自的空间里。注意：记号[表示包含端点，（表示不包含端点。 栈1，使用[0, n/3) 栈2，使用[n/3, 2n/3) 栈3，使用[2n/3, n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class FixedMultiStack&#123; private int numberOfStacks &#x3D; 3; private int stackCapacity; private int[] values; private int[] sizes; public FixedMultiStack(int stackSize)&#123; stackCapacity &#x3D; stackSize; values &#x3D; new int[stackSize * numberOfStacks]; sizes &#x3D; new int[numberOfStacks]; &#125; &#x2F;&#x2F;压栈 public void push(int stackNum, int value)&#123; if(isFull(stackNum))&#123; throw new Exception(&quot;空间不足&quot;); &#125; &#x2F;&#x2F;对栈顶指针加1并更新顶部的值 sizes[stackNum]++; values[indexOfTop(stackNum)] &#x3D; value; &#125; &#x2F;&#x2F;出栈 public int pop(int stackNum)&#123; if(isEmpty(stackNum))&#123; throw new Exception(&quot;栈为空&quot;); &#125; int topIndex &#x3D; indexOfTop(stackNum); int value &#x3D; values[topIndex];&#x2F;&#x2F;获取顶部元素 values[topIndex] &#x3D; 0;&#x2F;&#x2F;清零 sizes[stackNum]--; return value; &#125; &#x2F;&#x2F;返回顶部元素 public int peek(int stackNum)&#123; if(isEmpty(stackNum))&#123; throw new Exception(&quot;栈为空&quot;); &#125; return values[indexOfTop(stackNum)]; &#125; &#x2F;&#x2F;检查是否栈空 public Boolean isEmpty(int stackNum)&#123; return sizes[stackNum] &#x3D;&#x3D; 0; &#125; &#x2F;&#x2F;检查栈是否为满 public Boolean isFull(int stackNum)&#123; return sizes[stackNum] &#x3D;&#x3D; stackCapacity; &#125; &#x2F;&#x2F;返回栈顶元素的索引 private int indexOfTop(int stackNum)&#123; int offset &#x3D; stackNum * stackCapacity; int size &#x3D; sizes[stackNum]; return offset + size - 1; &#125;&#125; 方法2：弹性分割： 第二种做法是允许栈块的大小灵活可变。当一个栈的元素个数超出其初始容量时，就将这个栈扩容至许可的容量，必要时还要搬移元素。此外，我们会将数组设计成环状的，最后一个栈可能从数组末尾处开始，环绕到数组起始处。请注意，这种解法的代码远比面试中常见的要复杂得多。你可以试着提供伪码，或是其中某几部分的代码，但要完整实现的话，难度就有点大了。 反思 用一个数据结构实现另一个数据结构时，不光要想怎么完成空间上的划分和基本逻辑的实现，还要根据所求数据结构的API，尽量做到易维护，可读性强。 提示：#2，#12，#38，#58 -栈只是一个数据结构，其中最近添加的元素首先被删除。你能用一个数组来模拟单个栈吗？请记住，有很多可能的解法且每个解法都有其利弊。 -我们可以通过将数组的前三分之一分配到第一个栈、第二个三分之一分配到第二个栈、最后的第三个三分之一分配到第三个栈，来模拟数组中的三个栈。然而，实际上某个栈可能比其他的大得多。能更灵活地分配吗？ -如果你想考虑灵活划分，可以移动栈。你能保证使用所有可用的容量吗？ -试着把数组看作是循环的，这样数组的结尾就“环绕”到了数组的开始部分。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"http://ssssshinji.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"}]},{"title":"问题2：最小高度树","slug":"问题2：最小高度树","date":"2020-07-01T04:29:57.000Z","updated":"2020-07-03T07:57:56.748Z","comments":false,"path":"2020/07/01/问题2：最小高度树/","link":"2020/07/01/问题2：最小高度树","permalink":"http://ssssshinji.github.io/2020/07/01/%E9%97%AE%E9%A2%982%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/","excerpt":"","text":"题目描述 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。（提示在页尾） 个人思路 从叶子节点往上，依次让每个节点都尽量平衡。但是不知道要怎么写，看了提示也没有思路。试试连续用二分查找写一写吧。 个人解答 1234567static Node CreateNode(int[] a,int low, int high)&#123; int mid &#x3D; (low + high)&#x2F;2; Node root &#x3D; new Node(a[mid]); root.left &#x3D; CreateNode(a,low, mid-1); root.right &#x3D; CreateNode(a,mid+1, high); return root;&#125; 题目解析 要创建一棵高度最小的树，就必须让左右子树的节点数量尽量接近，也就是说，我们要让数组中间的值成为根节点，这么一来，数组左边一半就成为左子树，右边一半成为右子树。 然后，我们继续以类似方式构造整棵树。数组每一区段的中间元素成为子树的根节点，左半部分成为左子树，右半部分成为右子树。 一种实现方式是使用简单的root.insertNode(int v)方法，从根节点开始，以递归方式将值v插入树中。这么做的确能构造最小高度的树，但不太高效。每次插入操作都要遍历整棵树，用时为O(NlogN)。另一种做法是以递归方式运用createMinimalBST方法，从而删去部分多余的遍历操作。这个方法会传入数组的一个区段，并返回最小树的根节点。 标准解答（BFS） 12345678910static Node CreateNode(int[] a,int low, int high)&#123; if(low &lt; high)&#123; return null; &#125; int mid &#x3D; (low + high)&#x2F;2; Node root &#x3D; new Node(a[mid]); root.left &#x3D; CreateNode(a,low, mid-1); root.right &#x3D; CreateNode(a,mid+1, high); return root;&#125; 复杂度分析 递归的时间复杂度往往是（偶尔不是）O(分支数^数的深度)，本题为O(2^N); 反思 又忘记了边界检查。 （提示：#19，#73，#116） -最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？ -你可以通过找到“理想”的下一个要添加的元素和多次调用insertValue来实现。这样效率会有点儿低，因为你必须反复遍历树。尝试用递归代替。你能把这个问题分解为子问题吗？ -最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"问题精析：渲染管线","slug":"问题精析：渲染管线","date":"2020-06-30T18:32:28.000Z","updated":"2020-07-05T17:07:49.498Z","comments":false,"path":"2020/07/01/问题精析：渲染管线/","link":"2020/07/01/问题精析：渲染管线","permalink":"http://ssssshinji.github.io/2020/07/01/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/","excerpt":"","text":"概念 渲染管线的主要功能是决定在给定虚拟相机、三维物体、光源、照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。 步骤 应用程序阶段 Application 几何阶段 Geometry Processing 顶点着色器 Vertex Shader 变换 MVP Transformation 投影 Projection 图元装配 Primitive Assembly （在顶点着色器之后进行，容易记不清楚） 可选阶段 Optional Stage 表面细分 Tessellation 几何着色器 Geometry Shader 流输出 Stream Output 裁剪与屏幕映射 Clipping &amp; Screen Mapping 光栅化阶段 The Rasterizer Stage 三角形设定 Triangle Setup 三角形遍历 Triangle Traversal 像素处理 Pixel Processing 像素着色器 Pixel Shader 合并 Merging 应用程序阶段 应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件基础上，因此要改变实现过程会非常困难。 应用程序阶段通常实现的方法有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。 几何阶段 输入是顶点与图元的顶点索引，输出是屏幕空间的顶点。简单来说，几何阶段就是负责把顶点都转换到屏幕空间，以便光栅化阶段处理。 顶点着色器的输入是顶点和顶点属性，顶点着色器负责将顶点的位置从局部空间转换到齐次剪切空间 (Homogeneous Clipping Space)，顶点着色器还可以操作顶点相关的属性，比如颜色，法线，纹理坐标等，一般会在顶点着色器会计算逐顶点的光照。 还会在顶点着色器做其他一些操作，比如 Instancing (将同一个物体的顶点绘制在多个地方)，或者做关节动画，蒙皮，顶点动画。 可选阶段 Optional Stage 表面细分 Tessellation：主要用来做面的细分，可以将现有的面数拆分得更多，提供更多得细节。这个阶段常用来生成更精细的地形或其他表面。 几何着色器 Geometry Shader：几何着色器的输入是整个图元，还可以获得邻接图元的信息。几何着色器可以丢弃一些图元，还可以生成新的图元。这个阶段可以简化图元，例如用来做细节等级 (Level of detail，LOD)。也可以用来生成图形，例如用来做粒子生成。 与 Tessellation 相比，几何着色器可以丢弃图元，也可以将现有的图元转换成其他图元。而 Tessellation 只能增加面数。 流输出 Stream Output：在几何着色器中生成的顶点数据可以流输出到 GPU Memory 。这些数据可以再次放到流水线里，或者被 CPU 读取。这种方式可以迭代处理数据，常用来做水流模拟，或者粒子效果。 光栅化阶段 The Rasterizer Stage 经过裁剪和挑选剩下的多边形必须被光栅化。光栅化是一个决定哪些像素被几何图元覆盖的过程。多边形、线段和点根据为每种图元指定的规则分别被光栅化。光栅化的结果是像素位置的集合和片段的集合。当光栅化后，一个图元拥有的顶点数目和产生的片段之间没有任何关系。例如，一个由三个顶点组成的三角形占据整个屏幕，因此需要生成上百万的片段。 片段和像素之间的区别变得非常重要。术语像素（Pixel）是图像元素的简称。一个像素代表帧缓存中某个指定位置的内容，例如颜色，深度和其它与这个位置相关联的值。一个片段（Fragment）是更新一个特定像素潜在需要的一个状态。 之所以术语片段是因为光栅化会把每个几何图元（例如三角形）所覆盖的像素分解成像素大小的片段（扫描转换）。一个片段有一个与之相关联的像素位置、深度值和经过插值的参数，例如颜色，第二（反射）颜色和一个或多个纹理坐标集。这些各种各样的经过插值的参数是来自变换过的顶点，这些顶点组成了某个用来生成片段的几何图元。你可以把片段看成是潜在的像素。如果一个片段通过了各种各样的光栅化测试（在光栅操作将做讨论），这个片段将被用于更新帧缓存中的像素。 三角形设定 Triangle Setup（有些不清楚） 之前得到的都是三角形的顶点，而之后要计算屏幕上三角形会覆盖那些像素。三角形设定阶段会计算三角形边上 (及内部？)的像素坐标及相关的属性。 (推测：应该是在这个阶段进行 反面剔除 (Backface Culling)，将反面朝向相机的三角形扔掉。) 另一种说法是三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用。该过程在专门为其设计的硬件上执行。 三角形遍历 Triangle Traversal（有些不清楚） 这个阶段会进行逐像素检查，检查每个像素 (或采样点)是否被三角形覆盖，如果覆盖则生成一个片元 (Fragment)。这一阶段也被称为扫描转换 (Scan Conversion)。 另一种说法在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成片段（fragment）。找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。每个三角形片段的属性均由三个三角形顶点的数据插值而生成（在第五章会有讲解）。这些属性包括片段的深度，以及来自几何阶段的着色数据。 像素处理 Pixel Processing 像素着色器 Pixel Shader：也被叫做片元着色器 (Fragment Shader)，用来逐像素的计算着色使用插值得来的着色数据作为输入，输出结果为一种或多种将被传送到下一阶段的颜色信息。纹理贴图和纹理过滤一般都是在这个阶段进行的。 像素着色器的输入是逐像素的属性，这些属性是根据上个阶段中的顶点插值而得到的，插值一般使用透视纠正插值 (Perspective Correct Interpolation)由硬件完成，需要借助深度值才能正确地插值。 像素着色器还可以获取邻近像素插值的变化量，可以进行梯度计算，这个特性主要用来做纹理过滤。 像素着色器会输出一个该像素 (片元)的颜色，也可以选择不输出。像素着色器还可以修改深度缓冲 (Depth Buffer)，甚至是模板缓冲 (Stencil Buffer)的值。 在现代 GPU 上，像素着色器 可以将进行不同类型的输出，并写入多重渲染目标 (Multiple Render Targets，MRT)，一个 RT 就是一个 buffer，可以将不同的信息写入不同的 RT，然后在下个阶段合成 合并 Merging 这个阶段主要是将目前这一帧计算出来的 Fragment 颜色和系统中所有的 buffer 合并（合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色），得到最终的颜色值。合并阶段不可编程，但是高度可配置。 通常会在这个阶段根据 Z-buffer 进行 可见性测试 (Depth test，深度测试)，只渲染能看见的片元。也会进行透明度测试 (Alpha Test)，混合半透明物体与透明物体的颜色。模板缓冲也会用来控制颜色合并。 经过合并阶段就可以得到最终屏幕显示的颜色了。 参考资料 1. 《Real-Time Rendering 3rd》 提炼总结 2. 3D图形渲染管线 3. 图形渲染管线简介","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题2：判定是否互为字符重排","slug":"问题2：判定是否互为字符重排","date":"2020-06-30T17:35:53.000Z","updated":"2020-06-30T18:12:32.871Z","comments":false,"path":"2020/07/01/问题2：判定是否互为字符重排/","link":"2020/07/01/问题2：判定是否互为字符重排","permalink":"http://ssssshinji.github.io/2020/07/01/%E9%97%AE%E9%A2%982%EF%BC%9A%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/","excerpt":"","text":"题目描述 实现一个算法，确定一个字符串的所有字符是否不全都不同。假使不允许使用额外的数据结构，又该如何处理？（提示在页尾） 个人思路 和前一个问题一样，可以使用字符数组来解决。搜索第一个字符串时，每遇到一个字符，相应数组位置加1，搜索第二个字符串时，每遇到一个字符，相应数组位置减1。如果两个互为字符重排的话，数组的每一个元素应该为0。 个人解答 1234567891011121314151617181920static bool IsAnagram(string str1, string str2)&#123; if(str1.Length !&#x3D; str2.Length)&#123; return false; &#125; int[] char_set &#x3D; new int[128]; for(int i &#x3D; 0; i &lt; str1.Length; i++)&#123; int val &#x3D; str1[i]; char_set[val] +&#x3D; 1; &#125; for(int i &#x3D; 0; i &lt; str2.Length; i++)&#123; int val &#x3D; str2[i]; char_set[val] -&#x3D; 1; &#125; for(int i &#x3D; 0; i &lt; char_set.Length; i++)&#123; if(char_set[i] !&#x3D; 0)&#123; return false; &#125; &#125; return true;&#125; 时间复杂度 经典O(n)。 题目解析 -若两个字符串互为重排字符串，那么它们拥有同一组字符，只不过顺序不同。因此，对字符串排序，组成这两个重排字符串的字符就会有相同的顺序。我们只需比较排序后的字符串。 -还可以充分利用变位词的定义——组成两个单词的字符数相同——来实现这个算法。创建一个类似于散列表的数组（从第4行到第7行），将其每个字符映射到其字符出现的次数。增加第一个字符串，然后减少第二个字符串，如果两者互为重排，则该数组最终将为0。若值为负值（一旦为负，则值将永为负值，不会为非0），就提早终止。若不这样做，则数组就会为0。原因在于，字符串长度相同，增加的次数与减少的次数也相同。若数组无负值，则不会有正值。（和我想得一模一样，优秀） 标准解答 1234567891011static string Sort(string s)&#123; char[] content &#x3D; s.ToCharArray(); Array.Sort(content); return new string(content);&#125;bool Permutation(string s, string t)&#123; if(s.Length !&#x3D; t.Length)&#123; return false; &#125; return Sort(s).Equals(Sort(t));&#125; 标准解答（进阶） 123456789101112131415161718static bool IsAnagram(string str1, string str2)&#123; if(str1.Length !&#x3D; str2.Length)&#123; return false; &#125; int[] char_set &#x3D; new int[128]; for(int i &#x3D; 0; i &lt; str1.Length; i++)&#123; int val &#x3D; str1[i]; char_set[val] +&#x3D; 1; &#125; for(int i &#x3D; 0; i &lt; str2.Length; i++)&#123; int val &#x3D; str2[i]; char_set[val] -&#x3D; 1; if(char_set[val] &lt; 0)&#123; return false; &#125; &#125; return true;&#125; 复杂度分析 可以认为在内省排序中时间复杂度是O(nlogn)。 这题解的比较顶了，不过还是忽略了可以优化的地方。 提示：#1，#84，#122，#131 -描述两个字符串是否互为字符重排的含义。现在，看看你提供的定义，你能否根据这个定义检查字符串？ -有一种解法需要O(NlogN)的时间。另一种解法需要使用一些空间，但需要运行时间为O(N)。 -散列表有用吗？ -两个重排的字符串应该具有相同的字符，但顺序不同。你可以让它们的顺序一样吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：延迟着色（deferred Shading）","slug":"问题精析：延迟着色（deferred Shading）","date":"2020-06-29T18:42:23.000Z","updated":"2020-07-05T17:07:52.958Z","comments":false,"path":"2020/06/30/问题精析：延迟着色（deferred Shading）/","link":"2020/06/30/问题精析：延迟着色（deferred Shading）","permalink":"http://ssssshinji.github.io/2020/06/30/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E5%BB%B6%E8%BF%9F%E7%9D%80%E8%89%B2%EF%BC%88deferred%20Shading%EF%BC%89/","excerpt":"","text":"背景以及概念 我们现在一直使用的光照方式叫做正向渲染(Forward Rendering)或者正向着色法(Forward Shading)，它是我们渲染物体的一种非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此类推。它非常容易理解，也很容易实现，但是同时它对程序性能的影响也很大，因为对于每一个需要渲染的物体，程序都要对每一个光源每一个需要渲染的片段进行迭代，这是非常多的！因为大部分片段着色器的输出都会被之后的输出覆盖，正向渲染还会在场景中因为高深的复杂度(多个物体重合在一个像素上)浪费大量的片段着色器运行时间。 延迟着色法(Deferred Shading)，或者说是延迟渲染(Deferred Rendering)，为了解决上述问题而诞生了，它大幅度地改变了我们渲染物体的方式。这给我们优化拥有大量光源的场景提供了很多的选择，因为它能够在渲染上百甚至上千光源的同时还能够保持能让人接受的帧率。 延迟着色法基于我们延迟(Defer)或推迟(Postpone)大部分计算量非常大的渲染(像是光照)到后期进行处理的想法。它包含两个处理阶段(Pass)：在第一个几何处理阶段(Geometry Pass)中，我们先渲染场景一次，之后获取对象的各种几何信息，并储存在一系列叫做G缓冲(G-buffer)的纹理中；想想位置向量(Position Vector)、颜色向量(Color Vector)、法向量(Normal Vector)和/或镜面值(Specular Value)。场景中这些储存在G缓冲中的几何信息将会在之后用来做(更复杂的)光照计算。G缓冲，G-Buffer，全称Geometric Buffer ，译作几何缓冲区，它主要用于存储每个像素对应的位置（Position），法线（Normal），漫反射颜色（Diffuse Color）以及其他有用材质参数。根据这些信息，就可以在像空间（二维空间）中对每个像素进行光照处理。（G缓冲中的内容不是固定的，是可以根据需要来增删的。比如说OpenGL教程中就多存储了镜面值 Specular Value） 我们会在第二个光照处理阶段(Lighting Pass)中使用G缓冲内的纹理数据。在光照处理阶段中，我们渲染一个屏幕大小的方形，并使用G缓冲中的几何数据对每一个片段计算场景的光照；在每个像素中我们都会对G缓冲进行迭代。我们对于渲染过程进行解耦，将它高级的片段处理挪到后期进行，而不是直接将每个对象从顶点着色器带到片段着色器。光照计算过程还是和我们以前一样，但是现在我们需要从对应的G缓冲而不是顶点着色器(和一些uniform变量)那里获取输入变量了。 片元着色器代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D gPosition;uniform sampler2D gNormal;uniform sampler2D gAlbedoSpec;struct Light &#123; vec3 Position; vec3 Color; float Linear; float Quadratic;&#125;;const int NR_LIGHTS = 32;uniform Light lights[NR_LIGHTS];uniform vec3 viewPos;void main()&#123; // // 从G缓冲中获取数据 vec3 FragPos = texture(gPosition, TexCoords).rgb; vec3 Normal = texture(gNormal, TexCoords).rgb; vec3 Diffuse = texture(gAlbedoSpec, TexCoords).rgb; float Specular = texture(gAlbedoSpec, TexCoords).a; // 然后和往常一样地计算光照 vec3 lighting = Diffuse * 0.1; // hard-coded ambient component vec3 viewDir = normalize(viewPos - FragPos); for(int i = 0; i &lt; NR_LIGHTS; ++i) &#123; // Diffuse vec3 lightDir = normalize(lights[i].Position - FragPos); vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * lights[i].Color; // Specular vec3 halfwayDir = normalize(lightDir + viewDir); float spec = pow(max(dot(Normal, halfwayDir), 0.0), 16.0); vec3 specular = lights[i].Color * spec * Specular; // Attenuation float distance = length(lights[i].Position - FragPos); float attenuation = 1.0 / (1.0 + lights[i].Linear * distance + lights[i].Quadratic * distance * distance); diffuse *= attenuation; specular *= attenuation; lighting += diffuse + specular; &#125; FragColor = vec4(lighting, 1.0);&#125; 优点 Deferred Rendering 的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开。也就是说场景中不管是一个三角形还是一百万个三角形，最后的复杂度不会随光源数目变化而产生巨大变化。 一些要点： - 复杂度仅O(n+m)。 - 只渲染可见的像素，节省计算量。 - 用更少的shader（也算缺点，见缺点4）。 - 对后处理支持良好。 - 在大量光源的场景优势尤其明显。 缺点 一些要点： - 内存开销较大。 - 读写G-buffer的内存带宽用量是性能瓶颈。 - 对透明物体的渲染存在问题。在这点上需要结合正向渲染进行渲染（因为不能使用混合 Blending）。 - 对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启MRT。 - 迫使你对大部分场景的光照使用相同的光照算法，你可以通过包含更多关于材质的数据到G缓冲中来减轻这一缺点。 与正向渲染比较 正向渲染 - 正向渲染（Forward Rendering），先执行着色计算，再执行深度测试。 - 正向渲染渲染n个物体在m个光源下的着色，复杂度为O(n*m)次。 - Forward Rendering，光源数量对计算复杂度影响巨大，所以比较适合户外这种光源较少的场景。 - Forward Rendering的核心伪代码可以表示为： 123For each light: For each object affected by the light: framebuffer +&#x3D; object * light - Forward Rendering的管线流程如下：顶点 -&gt; 图元 -&gt; 光栅化 -&gt; 片元 -&gt; 可选帧缓冲（实现后处理之类） -&gt; 帧缓冲 延迟渲染 - 延迟渲染( Deferred Rendering)，先执行深度测试，再执行着色计算。 - 将光源的数目和场景中物体的数目在复杂度层面上完全分开。 - 延迟渲染渲染n个物体在m个光源下的着色，复杂度为O(n+m)次。 - Deferred Rendering的核心伪代码可以表示如下： 123For each object: Render to multiple targets For each light: Apply light as a 2D postprocess - Deferred Rendering的管线流程如下：顶点 -&gt; 图元 -&gt; 光栅化 -&gt; 几何着色器 -&gt; 可选帧缓冲（实现后处理之类） -&gt; 着色（shading） -&gt; 帧缓冲 参考资料 1. 《Real-Time Rendering 3rd》 提炼总结 2. 延迟着色法","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题2：迷路的机器人","slug":"问题2：迷路的机器人","date":"2020-06-29T17:06:28.000Z","updated":"2020-06-29T18:38:01.800Z","comments":false,"path":"2020/06/30/问题2：迷路的机器人/","link":"2020/06/30/问题2：迷路的机器人","permalink":"http://ssssshinji.github.io/2020/06/30/%E9%97%AE%E9%A2%982%EF%BC%9A%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA/","excerpt":"","text":"题目描述 设想有个机器人坐在一个网格的左上角，网格r行c列。机器人只能向下或向右移动，但不能走到一些被禁止的网格。设计一种算法，寻找机器人从左上角移动到右下角的路径。（提示在页尾） 个人思路 这个应该属于动态规划的范围内，从最后一步往前倒着思考试试。想了想好像能结合DFS写出来。 个人解答 12345678910111213141516171819202122232425262728static ArrayList FindPath(bool[][] maze)&#123; if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123; return null; &#125; ArrayList path &#x3D; new ArrayList(); if(maze.Length &#x3D;&#x3D; 1)&#123; path.Add(new Point(0,0)); return path; &#125; if(FindPath(maze,maze.Length-1,maze[0].Length-1,path))&#123; return path; &#125; return null;&#125;static bool FindPath(bool[][] maze,int row, int col,ArrayList path)&#123; if(isAtOrigin())&#123; return true; &#125; if(FindPath(maze,row-1,col,path))&#123; path.Add(new Point(row,col)); return true; &#125; if(FindPath(maze,row,col-1,path))&#123; path.Add(new Point(row,col)); return true; &#125; return false;&#125; 复杂度分析 O(2^(r+c))。 标准解答 123456789101112131415161718192021222324252627static ArrayList FindPath(bool[][] maze)&#123; if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123; return null; &#125; ArrayList path &#x3D; new ArrayList(); if(maze.Length &#x3D;&#x3D; 1)&#123; path.Add(new Point(0,0)); return path; &#125; if(FindPath(maze,maze.Length-1,maze[0].Length-1,path))&#123; return path; &#125; return null;&#125;static bool FindPath(bool[][] maze,int row, int col,ArrayList path)&#123; &#x2F;&#x2F;边界检查 if(col &lt; 0 || row &lt; 0 || !maze[row][col])&#123; return false; &#125; bool isAtOrigin &#x3D; (row &#x3D;&#x3D; 0) &amp;&amp; (col &#x3D;&#x3D; 0); if(isAtOrigin||FindPath(maze,row-1,col,path)||FindPath(maze,row,col-1,path))&#123; path.Add(new Point(row,col)); return true; &#125; return false;&#125; 复杂度分析 O(2^(r+c))。 题目解析 -如果把网格画出来，你会发现移动到位置(r,c)的唯一方式，就是先移动到它的相邻点，即(r-1,c)或(r,c-1)。因此，我们需要找到一条移至(r-1,c)或(r,c-1)的路径。 -怎么才能找出前往这些位置的路径呢？要找出前往(r-1,c)或(r,c-1)的路径，我们需要先移至其中一个相邻点。因此，要找到一条路径移动到(r-1,c)的相邻点，坐标为(r-2,c)和(r-1,c-1)或(r,c-1)的相邻点，其坐标为(r-1,c-1)和(r,c-2)。注意，坐标(r-1,c-1)一共出现了两次。 -理想情况下，我们应该能记住访问过(r-1,c-1)节点以节省时间。 标准解答（进阶） 12345678910111213141516171819202122232425262728293031323334static ArrayList FindPath(bool[][] maze)&#123; if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123; return null; &#125; ArrayList path &#x3D; new ArrayList(); HashSet&lt;Point&gt; failedPoints &#x3D; new HashSet&lt;Point&gt;(); if(maze.Length &#x3D;&#x3D; 1)&#123; path.Add(new Point(0,0)); return path; &#125; if(FindPath(maze,maze.Length-1,maze[0].Length-1,path,failedPoints))&#123; return path; &#125; return null;&#125;static bool FindPath(bool[][] maze,int row, int col,ArrayList path,HashSet&lt;Point&gt; failedPoints)&#123; &#x2F;&#x2F;边界检查 if(col &lt; 0 || row &lt; 0 || !maze[row][col])&#123; return false; &#125; Point p &#x3D; new Point(row,col); if(failedPoints.Contains(p))&#123; return false; &#125; bool isAtOrigin &#x3D; (row &#x3D;&#x3D; 0) &amp;&amp; (col &#x3D;&#x3D; 0); if(isAtOrigin||FindPath(maze,row-1,col,path,failedPoints)||FindPath(maze,row,col-1,path,failedPoints))&#123; path.Add(p); return true; &#125; failedPoints.Add(p); return false;&#125; 反思 又忘记了边界检查，有先后顺序的if可以利用||运算符写在一个if里,在完成算法之后尽量优化。 提示：#331，#360，#388 -为了让机器人到最后一个格子，必须找出到倒数第二个格子的路径。为了到倒数第二个格子，必须找出到倒数第三个格子的路径。 -首先明确是否有路径，以便稍微简化这个问题。然后，修改你的算法跟踪路径。 -再考虑一下你算法的效率。你能优化它吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"递归与动态规划","slug":"递归与动态规划","permalink":"http://ssssshinji.github.io/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"问题1：三步问题","slug":"问题1：三步问题","date":"2020-06-28T04:55:16.000Z","updated":"2020-06-28T05:53:46.797Z","comments":false,"path":"2020/06/28/问题1：三步问题/","link":"2020/06/28/问题1：三步问题","permalink":"http://ssssshinji.github.io/2020/06/28/%E9%97%AE%E9%A2%981%EF%BC%9A%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98/","excerpt":"","text":"题目描述 有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。（提示在页尾） 个人思路 经典斐波拉契数列问题的变形。 个人解答 1234567int Count(int n)&#123; if(n &lt; 0)return 0; else if(n &#x3D;&#x3D; 0)&#123; return 1; &#125; else return count(n-1)+count(n-2)+count(n-3);&#125; 复杂度分析 每次都有3个分支，经典O(3^n)。 题目解析 -蛮力法: 用递归法可以很容易就实现这个算法，只需要遵循如下思路，即countWays(n-1)+countWays(n-2)+countWays(n-3)。 -制表法: 记录已经计算过的结果方式重复计算。（原来也遇到过，又给忘了） 重要的一点是，无论是否使用制表法，注意上楼梯的方式总数很快就会突破整数（int型）的上限而溢出。当n=37时，结果就会溢出。使用long可以撑久一点儿，但也不能从根本上解决问题。 标准解答（制表法） 12345678910111213141516171819static int CountWay(int n)&#123; int[] memo &#x3D; new int[n+1]; for(int i &#x3D; 0; i &lt; memo.Length; i++)&#123; memo[i] &#x3D; -1; &#125; return CountWay(n,memo); &#125;static int CountWay(int n, int[] memo)&#123; if(n &lt; 0)return 0; else if(n &#x3D;&#x3D; 0)return 1; else if(memo[n] &gt; -1)&#123; return memo[n]; &#125; else&#123; memo[n] &#x3D; CountWay(n-1,memo) + CountWay(n-2,memo) + CountWay(n-3,memo); return memo[n]; &#125; &#125; 复杂度分析 也是经典O(3^n)，不过会快很多。 反思 对性能以及算法的可行性不敏感，没有考虑边界问题。 提示：#152，#178，#217，#237，#262，#359 -自上而下地处理这个问题。小孩的最后一跳是什么？ -如果知道跳到第100级台阶之前的每一级台阶的跳法数量，可以计算第100级台阶的跳法数量吗？ -可以通过步数99、98、97的数量，来计算100步的数量。这对应孩子最后迈1步、2步或3步。我们把它们加起来还是相乘？也就是说，它是f(100)=f(99)+f(98)+f(97)或者f(100)=f(99)×f(98)×f(97)吗？ -当“我们这样做然后那样做”时，将这些值相乘。当“我们这样做或者那样做”时，将这些值相加。 -这个方法的运行时间是多少？仔细想想。你能优化它吗？ -尝试用制表法的方式优化效率低下的递归过程。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"递归与动态规划","slug":"递归与动态规划","permalink":"http://ssssshinji.github.io/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"问题合集：逻辑类","slug":"问题合集：逻辑类","date":"2020-06-28T04:08:30.000Z","updated":"2020-07-10T07:51:47.738Z","comments":false,"path":"2020/06/28/问题合集：逻辑类/","link":"2020/06/28/问题合集：逻辑类","permalink":"http://ssssshinji.github.io/2020/06/28/%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86%EF%BC%9A%E9%80%BB%E8%BE%91%E7%B1%BB/","excerpt":"","text":"题目描述 较重的药丸。有20瓶药丸，其中19瓶装有1.0克的药丸，余下1瓶装有1.1克的药丸。给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次。（提示在后面） 个人思路 只能称重一次，可能的操作无非就是分成两组称重罢了。分成2组，一组10个药丸。这时候一边重一边轻。依次对调两边相同位置的药丸，比较重的药丸在对调后使轻的那一侧变重。 题目解析 -有时候，严格的限制条件反倒能提供解题的线索。在这个问题中，限制条件是天平只能用一次。天平只能用一次，从而得出一个有趣的事实，即一次必须同时称很多药丸，其实更准确地说，是必须从19瓶中拿出药丸进行称重。否则，如果跳过2瓶或更多瓶药丸，又该如何区分没称过的那几瓶呢？别忘了，天平只能用一次。 那么，该怎么称重取自多个药瓶的药丸，并确定哪一瓶装有比较重的药丸？假设只有2瓶药丸，其中一瓶的药丸比较重。每瓶取出一粒药丸，称得重量为2.1克，但无从知晓这多出来的0.1克来自哪一瓶。我们必须设法区分这些药瓶。 如果从药瓶#1取出一粒药丸，从药瓶#2取出两粒药丸，那么，称得重量为多少呢？结果要依情况而定。如果药瓶#1的药丸较重，则称得重量为3.1克。如果药瓶#2的药丸较重，则称得重量为3.2克。这就是这个问题的接替窍门。 称一堆药丸时，我们会有个“预期”重量。借由预期重量和实测重量之间的差别，就能得出哪一瓶药丸比较重，前提是从每个药瓶取出不同数量的药丸。 将之前两瓶药丸的解法加以推广，就能得到完整解法，即从药瓶#1取出一粒药丸，从药瓶#2取出两粒，从药瓶#3取出三粒，以此类推。如果每粒药丸均重1克，则称得总重量为210克（1+2+…+20=20×21/2=210），“多出来的”重量必定来自每粒多0.1克的药丸。 药瓶的编号可由下列算式得出： $$\\frac{weight - 210grams} {0.1grams}$$ 因此，若这堆药丸称得重量为211.3克，则药瓶#13装有较重的药丸。 反思 自己的思路实际上是用了多次天平，违背了题意。忽略了重量与数量之间的，预期重量与实际重量之间的关系。 提示 -你只能使用天平一次。这意味着必须使用所有或几乎所有的药瓶。还必须使用不同的处理方法，否则你无法将它们区分开来。 -如果你把每个瓶子中的一粒药丸放在天平上，会怎么样？如果你从每个瓶子中取两粒药丸放在天平上，又会如何？ -想象一下只有3个瓶子，其中一瓶中有更重的药丸。假设你从每个瓶子中分别取出不同数量的药丸放在天平上（例如，从药瓶#1中取出5粒药丸，从药瓶#2中取出2粒药丸，从药瓶#3中取出9粒药丸），天平会怎样？ -你应该能得到一个会告诉你哪一个是重瓶子的基于重量的方程。 题目描述 有个篮球框，下面两种玩法可任选一种。 玩法1：一次出手机会，投篮命中得分。 玩法2：三次出手机会，必须投中两次。 如果p是某次投篮命中的概率，则p的值为多少时才会选择玩法1或玩法2？（提示在后面） 个人思路 第一种玩法得分的概率和第二种玩法得分的概率比较即可。第一种是\\(p\\),第二种是\\(1-c_3^1 p^1(1-p)^2\\)。 题目解析 与个人思路基本相同 提示 -分别计算赢得第一场比赛和赢得第二场比赛的概率，然后对其进行比较。 -要计算玩法2获胜的概率，首先要计算第1、2次投中，第3次未投中的概率。 -如果两个事件是互斥的（它们不能同时发生），你可以将它们的概率加在一起。你能找到一组互斥的事件，代表三次投篮中的两次吗？ -三投两中的概率为：（第1、2次投中，第3次未投中）的概率+（第1、3次投中，第2次未投中）的概率+（第1次未投中，第2、3次投中）的概率+（3次全投中）的概率。 题目描述 有个8×8棋盘，其中对角的角落上，两个方格被切掉了。给定31块多米诺骨牌，一块骨牌恰好可以覆盖两个方格。用这31块骨牌能否盖住整个棋盘？请证明你的答案（提供范例或证明为什么不能）。 个人思路 从2*2的棋盘开始试验，试到5*5发现好像都没有办法铺满。看了提示后意识到，一个多米诺骨牌会占据一个黑色格子和一个白色各自，而对角的两个格子始终是同一种颜色的，会出现一种格子比另一种多两个的情况，则永远没有办法铺满整个棋盘。 题目解析 乍一看，似乎是可以盖住的。棋盘大小为8×8，共有64个方格，但其中两个方格已被切掉，因此只剩62个方格。31块骨牌应该刚好能盖住整个棋盘，对吧？ 尝试用骨牌盖住第1行，而第1行只有7个方格，因此有一块骨牌必须铺至第2行。而用骨牌盖住第2行时，我们又必须将一块骨牌铺至第3行。 要盖住每一行，总有一块骨牌必须铺至下一行。无论尝试多少次，使用多少种方法，我们都无法成功铺下所有骨牌。 其实，可以更简洁而严谨地证明为什么不可能。棋盘原本有32个黑格和32个白格。将对角角落上的两个方格（相同颜色）切掉，棋盘只剩下30个同色的方格和32个另一种颜色的方格。为了方便论证，我们假定棋盘上剩下30个黑格和32个白格。 放在棋盘上的每块骨牌必定会盖住一个白格和一个黑格。因此，31块骨牌正好盖住31个白格和31个黑格。然而，这个棋盘只有30个黑格和32个白格，所以，31块骨牌盖不住整个棋盘。 提示：#367，#397 -想象一块多米诺骨牌放在棋盘上。它盖住了多少个黑色方格？多少个白色方格？ -棋盘上有多少个黑色方格？多少个白色方格？ 题目描述 三角形的三个顶点上各有一只蚂蚁。如果蚂蚁开始沿着三角形的边爬行，两只或三只蚂蚁撞在一起的概率有多大？假定每只蚂蚁会随机选一个方向，每个方向被选到的概率相等，而且三只蚂蚁的爬行速度相同。 个人思路 只有都同向的时候才不会相撞。 $$ 1-(1/2)^3 - (1/2)^3 $$ 题目解析 与个人思路基本相同。 若要将这个方法推广至n个顶点的多边形，同样地，蚂蚁也只有以顺时针或逆时针同方向。 $$ P_(碰撞)= 1-P_(同方向)=1-(1/2)^(n-1) $$ 提示：#157，#195，#296 -在什么情况下其不会碰撞？ -只有三只蚂蚁都向同一个方向爬行，它们才不致相撞。三只蚂蚁都按顺时针爬行的概率是多少？ -你可以认为这是概率（3只蚂蚁走顺时针方向）+概率（3只蚂蚁走逆时针方向）。或者，你可以把它看作：第一只蚂蚁选择了一个方向。其他蚂蚁选择同一方向的概率是多少？ 题目描述 有两个水壶，容量分别为3夸脱[插图]和5夸脱，若水的供应不限量（但没有量杯），怎么用这两个水壶得到刚好4夸克的水？注意，这两个水壶呈不规则状，无法精准地装满“半壶”水。 个人思路 倒一倒就出来了。装满5夸克容器，倒进3夸克容器，5夸克容器剩余2夸克，3夸克容器清空，将2夸克水倒进3夸克容器，重新装满5夸克容器，用其装满3夸克容器，5夸克容器中剩余即为4夸克。 题目解析 5夸克水壶 3夸克水壶 5 0 2 3 2 0 0 2 5 2 4 3 提示：#149，#379，#400 -把玩水壶，来回倒水，看看你能否测量3夸脱或5夸脱以外的东西。这是一个开始。 -如果你装满5夸脱的水壶，再用它装满3夸脱的水壶，那么5夸脱的水壶里就剩下2夸脱了。你可以把这2夸脱放在那里，也可以把小水壶里的水倒干净，然后倒入这2夸脱。 -一旦你找到一个解决这个问题的方法，就可以从更具普遍意义的角度去考虑它。如果给你一个大小为X的水壶和另一个大小为Y的水壶，你能用它们来测量出Z吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数学与逻辑题","slug":"数学与逻辑题","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E5%AD%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E9%A2%98/"}]},{"title":"面试经验汇总","slug":"面试经验汇总","date":"2020-06-27T14:12:05.000Z","updated":"2020-06-29T09:02:21.543Z","comments":false,"path":"2020/06/27/面试经验汇总/","link":"2020/06/27/面试经验汇总","permalink":"http://ssssshinji.github.io/2020/06/27/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/","excerpt":"","text":"腾讯IEG 技术美术 准备资料 简历+作品集（ai&amp;ps、blender&amp;3dsmax、ae、unity shader样例、unity shader综合场景） 面试官提问（一面） 1.自我介绍 2.对PBR的理解 3.迪士尼pbr材质实现方式 4.有没有做过pbr样例（衣服、头发、皮肤），遇到过什么难题 5.挑了几个shader，讲一下具体代码实现，如何优化 6.法线贴图的原理 7.写过什么配合dcc的脚本 8.假如ik骨模型，手臂末端出现扭曲，原因是、如何解决、有没有写过处理模型骨骼错误的脚本 9.比较喜欢什么风格的游戏？具体是什么游戏？假如实现某个游戏里某个效果，怎么写shader 10.在网易实习的时候负责的游戏项目是？项目中遇到的难点、如何解决 11.对TA各个方面学习的规划是什么、通过什么途径进行学习 受验者提问 1.进组之后，会负责的游戏是？什么风格？答： 秦时明月（ARPG） 2.在项目中，期望我主攻的方向是？答：看你的想法。 面试官提问（二面） 1.渲染管线的流程 2.对PBR的看法（问题重复了，这个问题感觉是必问的了，注意一定要回答的全面一些，不要局限于材质） 3.对作品集里比较复杂一些的shader问了一些实现原理 反思 每个作品都应该是你的脸，给别人看的脸要是丑陋的话，只能认为自己的审美问题很大。问题里PBR应该是标配。我的理解里PBR是：尝试用计算机，呈现一个符合现实世界中物理定律的画面。那这里就包含：美术资源，摄像机，光照，渲染管线，Shader，后期。并不只是一个材质，一个光照算法，而且综合起来的所有种种。看到一句话感触很深：**瓶颈的存在更多的是因为自身知识的匮乏。**你不了解它或者你自以为了解它，就是最大的瓶颈。 网易互娱 游戏研发 面试官提问 1.介绍一下自己吧 2.说一说你实习期间做过的具体内容，以及部分的实现（包括常规的Unity客户端开发、引擎小工具插件的制作、渲染和优化相关） 3.你觉得自己在实习期间解决的最难的一个问题是什么，以及如何解决的 4.你觉得自己在项目组里面自身水平能占前百分之多少 5.你觉得自己和正式员工相比，最大的差距是什么 6.你有和团队合作的经验吗，期间碰到的问题是怎么一起解决的 7.讲一讲你在校期间的项目（主要讲楼主本科期间做过的一个游戏Demo和研究生期间的一个图形学项目） 8.最近有在看一些什么东西吗，分享一个相关内容？ 中间的技术问题（基本都是图形学基础相关的问题）： 1.描述一下渲染管线 2.几何着色器和细分着色器的作用（这里着重问了几何着色器） 3.几何着色器可以实现细分着色器的功能吗 4.顶点着色器的作用、细分着色器的作用 5.一个几何体会走几次顶点着色器 6.深度测试有办法提前吗，为什么要提前，怎么提前的（Early-Z） 7.Early-Z有使用限制吗（一般不能与AlphaTest混用），为什么不能 7.几何着色器处理的对象是什么，片元着色器处理的对象是什么 8.多个不透明几何体在摄像机前完全重叠会渲染几次（非透明物体的渲染顺序） 9.非透明物体是怎么实现从前往后渲染的 10.透明物体的渲染顺序，为什么透明物体要从后往前渲染 11.顶点光照和像素光照是怎么做的，假如要用高质量的光照用哪个 12.SSAO具体说一下，其中SS是什么意思，为什么叫SS 13.假如一个场景很复杂且有很多个光源，如何优化（延迟渲染，以及具体的实现） 14.NormalMap了解吗，有没有在不使用NormalMap的情况下计算出法线 后面的一个算法问题： 1.手写push_back 2.针对写出的代码的一些问题（楼主一开始写的代码用了memcpy，就问了用memcpy会出现什么问题，主要是浅拷贝和深拷贝的问题。还包括对push_back的时间复杂度的分析） 最后的一些HR问题： 1.有其他想问的吗 2.给了offer有多大把握会去 3.手上有其他offer吗 4.对来上海工作有问题吗 腾讯 游戏客户端开发 字节跳动 游戏引擎研发 面试官提问(一面) C++基础： 1.stl的vector和list的区别，增删分别的时间复杂度 2.虚函数机制 3.C11的新特性 计算机网络： 1.解释TCP3次握手 图形学： 1.速度过快/体积过小导致物理引擎检测不到碰撞，如何解决 开放性问题： 1.如何优化内存，实际开发过程中用过什么优化内存的方法 2.如果有对象要频繁创建和删除，用什么减少开销。(对象池) 3.对象池的大小通常如何决定 面试官提问(二面) 二面面试官给我发了一个腾讯文档，考8道C++基础题，涉及到C++自定义类的大小如何决定(默认大对齐)、右值引用、模板类、STL的iterator使用等等，在面试官纠正下我勉勉强强做出了7道，感觉还是蛮难的。题就不公开放了，有小伙伴需要的话私信我单独发吧。 三面给我印象不是很深，好像是问了问我简历里的项目，然后我叽里咕噜跟面试官说了一堆，说了啥我已经忘了，毕竟面试里说的那些高大上的话太羞耻了根本不敢回忆😂 字节 游戏引擎研发 面试官提问(一面) C++基础： 1.几个stl容器的底层实现 2.右值引用和move构造 3.const、static关键字 4.C++里的lambda函数 5.指针和引用的区别 软件工程： 1.介绍几个设计模式 2.C++里的面向对象 图形学： 1.介绍渲染管线 2.解释纹理采样的两个模式 手撕代码：前序遍历 面试官提问(二面) C++基础： 1.解释C++的多态如何实现 2.解释类模板和模板类的区别 3.右值引用、move语义 图形学： 1.介绍顶点处理中涉及到的矩阵变换 2.介绍一个光照渲染模型(我介绍的是冯氏光照) 3.介绍一个消除隐藏面的算法(我介绍的是Z缓存) 4.如何解决因为顶点过近和浮点数的精度不足带来的穿模问题 手撕代码：快排 面试官提问(三面) 开放性问题： 1.在特定场景如何选择stl容器，以什么为标准？你最近一个应用到这个容器的场景是什么？ 2.在N*N棋盘地图上放一个圆形技能，检测影响到的玩家对象，用什么数据结构实现？ 3.不关心顺序的数组如何实现O(1)的删除操作 4.以上3个是我印象比较深的问题，后面是一些关于项目经历的提问了，比如有没有值得分享的优化点，最有成就感的是哪个等等。 反思 字节的面试是体验最好的，一个下午就连续完成了3面，第二天就完成了HR面，几天后就来了OC，可以说是非常省时间了。暂且不论最后结果，我在面试的过程也学到了很多东西，面试官很看重思考能力和算法数据结构功底，我问的一些问题面试官也回答得非常有干货。 网易 客户端引擎 面试官提问(一面) 1.自我介绍 2.一道简单的概率题 3.一段c语言指针字符串拷贝程序找bug 4.法线矩阵和模型矩阵的关系 5.列举了解的反走样算法 6.TAA实现原理相关的一些问题 7.次表面散射怎么做的 8.虚拟视点方法的原理，怎么计算透射 9.了解商业引擎中透射是怎么做的吗 10.HIVE渲染引擎里面支持多线程吗 11.shadertoy中的体积云怎么实现的 面试官提问(二面) 1.主要做什么东西？做实时渲染多久了？ 2.介绍一下半透明材质渲染项目 3.虚拟视点的缺陷 4.虚拟视点怎么计算透射厚度的 5.怎么进行采样计算的 6.介绍一下HIVE渲染引擎项目 7.HIVE引擎具体提供了什么样的功能？实验室使用HIVE一般用来做什么？ 8.关于opengl和vulkan的shader的区别 9.有考虑过引擎怎么支持DX吗 10.介绍一下峨眉山渲染项目 11.TAA怎么解决重影问题 12.SSAO、Bloom、树叶透光的一些原理介绍 13.为什么需要HDR和Tone mapping 14.介绍一下VR照片墙项目 15.用unity用了多久了，做过什么 16.如何用程序帮助美术实现雪的绘制效果 17.了解AI算法吗 18.关于寻路的一些问题 19.平面中有很多矩形，给出一个坐标，如何快速找出该坐标属于哪个矩形 面试官提问（三面） 1.在家还是在学校？实习会受疫情影响吗？能实习多久？ 2.介绍一个你觉得比较好的项目？ 3.关于虚拟视点原理的解释 4.为什么要计算透射厚度 5.SSSS算法最普适的原理是什么 6.项目能否用于布料绘制相关的一些问题 7.解释PBR中用到的公式原理 8.TAA的原理 9.为什么shading时纹理颜色要转换到线性空间 10.reflect反射公式底层怎么写 11.空间中怎么判断直线与圆是否想交 12.空间中点到直线距离公式 13.有什么了解动画相关的？比如骨骼动画？ 14.一个矩阵插值问题，记不清楚了 15.在构造函数里面调用delete this，然后printf(“xxxxx”)，会不会崩溃？ 为什么不会崩溃？“xxxx”在什么内存区? 16.二维数组按行打印与按列打印那个更快？ 17.解释一下cache？cache line有多大？ 18.a++是线程安全的吗？为什么不是线程安全？ a++翻译成汇编是什么能写出来吗？ 19.有什么问题要问吗？ 面试官提问(HR面) 1.自我介绍 2.关于学校的问题 3.想做哪方面的东西？ 4.平时学习什么东西，怎么学习的？ 5.介绍一下你做的小游戏？ 6.怎么学习c++的？ 7.介绍一个最有成就感的项目？ 8.遇到过什么困难，怎么解决的？ 9.工作时对团队与项目有什么要求？ 10.有什么兴趣爱好？ 11.平时怎么安排学习时间的？ 12.目前投了哪些公司？投的什么岗位？ 13.为什么要来网易？ 14.之前对网易有什么了解吗？ 15.为什么想去杭州？ 16.能实习多久？ 17.有什么问题吗？ 腾讯IEG光子 游戏引擎研发 面试官提问（提前批一面） 1.Blinn-Phong原理 2.Shadow Mapping原理 3.Perlin噪声原理 4.碰撞检测方法 5.碰撞检测中高速物体直接穿过包围盒问题 6.平滑纹理双线性插值，三线性插值 原理 7.为什么uv是在区间[0,1] 8.纹理环绕模式有哪些 uv大于1怎么处理 9.tcp/udp区别 用途 10.排序有哪些，有什么区别 11.算法题 单调栈 12.玩过哪些游戏 面试官提问（提前批二面） 1.网络有哪几层？ 2.tcp/udp区别 3.为什么会有丢包，丢包时发生了什么？ 4.在游戏运行时，从服务器发来一段编译好的二进制程序，要怎么在客户端中使用它（非脚本语言）？ 5.运行时动态链接的原理，过程？ 6.介绍一下c++的面向对象？ 7.多态的实现方式？ 8.虚指针虚表，虚表存在哪里？ 9.设计一个数据结构，使得两个线程一个写入一个读出互不影响，但是不能用锁？（怎么实现无锁数据结构） 10.链表和线性表实现队列的区别？ 11.说一下A* 算法？ 12.A* 算法的复杂度？ 面试官提问（正式批一面） 1.虚函数多态 2.虚表存在哪里 3.拷贝构造函数和赋值函数的区别 4.Blinn-Phong原理 5.渲染管线 6.骨骼蒙皮原理 7.骨骼动画插值 8.渲染方程 9.图的存储方式 10.寻路方法有哪些 11.聊一下A*算法 12.聊项目 面试官提问（正式批二面） 1.问项目 2.带有深度图片中的像素到空间中坐标的变换 3.点到平面距离 4.碰撞检测 5.Shadow Mapping 6.阴影失真的解决方案 7.齐次坐标的作用 8.实例化渲染，降低渲染调用 9.基于物理的渲染PBR 10.10万个数据选出最大的1万个 11.二叉树最近公共祖先 12.什么时候能来实习 面试官提问（HR面） 1.自我介绍 2.游戏经历 3.社团经历 4.为什么读双学位 5.学习的方法 6.什么时候来实习 7.有什么其他offer 整体总结 游戏引擎岗位 面试官提问 C++： 1.new和malloc区别 2.STL中map的实现原理，怎么解决hash冲突 3.STL迭代器失效的情况 4.右值引用的作用？std::move怎么实现的？ 5.三个智能指针说一下，weak_ptr如何判断是否失效？sizeof(shared_ptr)多少？ 6.如何将C++类设置为不可继承 7.能否将构造函数设为虚函数 8.继承下虚表的变化情况？ 9.sizeof空结构体 10.register变量可以取地址吗？ 11.指针和引用的区别 12.深拷贝和浅拷贝 13.函数如何返回多个值（引用或者std::pair,std::tuple) 14.C++ UB说几个 15.带有虚继承的子类内存分布 16.C99变长数组是堆还是栈实现的？ 操作系统&amp;&amp;计算机网络&amp;&amp;多线程: 1.线程和进程的区别 2.多发射了解吗 3.C++中多线程库实现PV操作用什么？ 4.TCP/IP三次握手，拥塞处理，滑动窗口 5.指令重排发生在编译阶段还是运行阶段？ 6.智能指针是线程安全的吗？ (这部分感觉问的比较少，也没啥印象了，也都是基础了) Lua： 1.lua的index和newindex是什么？ 2.lua的垃圾回收机制？是否存在互相引用现象？ 3.lua的元表怎么重载运算符？ 4.lua怎么实现面向对象的机制？ 5.lua的table底层是怎么存储的？ 6.lua对栈的操作比较麻烦，有优化方法吗？ 7.lua和C++怎么绑定，有什么库？ 8.lua的pairs和ipairs有什么区别? 图形学&amp;&amp;管线: 1.渲染管线说一下，前向渲染&amp;&amp;延迟渲染 2.延迟渲染的缺点，分块延迟渲染知道吗？为什么延迟渲染带宽会那么大? 3.SSAO原理，除了SSAO还有哪些AO？ 4.阴影贴图原理 PCF是什么 PCF的卷积核有什么？ CSM？ 5.PBR说一下，几何函数的意义,IBL主要是针对高光还是漫反射光？ 6.Lod是什么？除了通过摄像机和物体距离判断Lod等级，还有什么方法？ 7.DrawCall的开销体现在哪里，就是你调用DrawCall,具体干了什么？ 8.Bloom效果怎么实现？ 9.描边算法说一下？怎么不用后处理的卷积算子做描边？卡通化渲染呢？ 10.DX12大概是怎么减少开销的，说一下 11.mipmap说一下？它对带宽有什么影响？ 12.压缩纹理有什么格式？ 13.Unity外部调试工具有哪些？ 14.UE4渲染过程大概说一下，随便说几个Pass？ 15.为什么延迟渲染不能开MSAA？ 16.有什么方法能降低一个场景中的渲染开销吗？说的越多越好 17.纹理数组知道吗？ 18.实例化是怎么做的？说一下流程和好处 19.说一下常见的遮挡剔除算法？ 20.纹理在移动设备上存储在哪里？ 21.全局光照能说一下吗？SH也说一下? 22.如果把近处平面去掉了会怎么样 23.OpenGL的VAO和VBO 24.GBuffer一般里面有什么，GBuffer要不要存储position信息，如果不存储，怎么用深度信息进行推导 25.卷积知道吗？说一下，模糊呢，为什么需要模糊？ 26.次表面反射知道吗？ 27.透明度测试和深度测试的关系？ 28.法线贴图说一下，切线空间呢？ 29.移动设备怎么减少DrawCall Overload? 30.各向异性在光照模型中如何实现？ 31.opengl中顶点数据被送入顶点缓冲区时api做了什么？ 32.phong和billn-phong区别是什么？ 33.ray marching 知道吗？ 34.opengl和dx有什么数学上的差别？ 35.Alpha Blend和Alpha Test在性能上有什么不同？ 36.光源剔除怎么做？ 37.遮挡剔除怎么做？知道Mesh Shader吗？ 38.CS知道吗？为什么有些pass放到cs而不是ps做？ 游戏数学&amp;&amp;算法： 1.点沿任意轴旋转的矩阵怎么推导 2.怎么判断一个物体是不是在你面前还是身后？ 3.A*算法说一下，它的最大缺点是什么？ 4.八叉树算法说一下，它用在哪里居多，物体运动了咋办？ 5.kd-tree和bsp说一下 6.推导View矩阵 7.如何判断射线和三角形相交 8.如何判断两个立方体是否相交(AABB包围盒相交问题) 9.如何判断点是在多边形里面还是外面？ 10.如何判断三角形和三角形相交? 11.说一下点积和乘积的几何意义？ 12.矩阵左乘和右乘区别？ 游戏开发： 1.帧同步中的帧是什么意思？ 2.常见的设计模式说一下 3.Unity的awake,enable,start 4.UE4的垃圾回收怎么实现？不会？那说说反射吧 5.UE4蓝图和C++代码通信的几个方法？ 6.ECS框架有什么好处？ 手撕算法： 游戏引擎岗对手撕算法，很多公司不怎么要求，很多根本不手撕，因为挖项目会占用很久时。但也有一些公司要，但即使有的话也不难，力扣的变形题或者 一些常见的算法题，比如考察回溯法，随便刷点就行了，难度easy到middle之间。我刷了300道力扣两遍，朋友没咋刷，没啥太大问题。 其它问题: 1.为什么不读研了?(成绩不太理想，自己早点工作也不是坏事) 2.家住在哪里，来这边会不习惯吗？ 3.咋会对游戏感兴趣，玩过什么手游端游吗？（对前后端都不熟，接触过图形，游戏也是第九艺术嘛，玩过点3A,吃鸡,MMORPG） 4.学校里面教图形吗？（不教，自学了点），本科同学里面有多少人研究图形游戏？（两百人大概两三个人） 5.有女朋友吗？（没），家里支持你来这个城市吗？（支持） 6.必问问题：你有什么想问我的？(问一两个即可) 总结 图形学相关的问题又多又杂，除了最基本的理论，还会和项目，游戏引擎，优化等结合。没有项目经验只能通过做题来勉强弥补一下。计算机基础知识除了算法和数据结构之外都不需要花太多功夫，c++的特性需要有较深入的理解。","categories":[{"name":"monolog","slug":"monolog","permalink":"http://ssssshinji.github.io/categories/monolog/"}],"tags":[{"name":"不想却又不得不工作","slug":"不想却又不得不工作","permalink":"http://ssssshinji.github.io/tags/%E4%B8%8D%E6%83%B3%E5%8D%B4%E5%8F%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%B7%A5%E4%BD%9C/"}]},{"title":"问题1：节点间通路","slug":"问题1：节点间通路","date":"2020-06-27T07:39:32.000Z","updated":"2020-07-08T10:51:08.785Z","comments":false,"path":"2020/06/27/问题1：节点间通路/","link":"2020/06/27/问题1：节点间通路","permalink":"http://ssssshinji.github.io/2020/06/27/%E9%97%AE%E9%A2%981%EF%BC%9A%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/","excerpt":"","text":"题目描述 给定有向图，设计一个算法，找出两个节点之间是否存在一条路径（提示在页尾） 个人思路 题目含义很明确，就是让手写DFS和BFS。而对于寻找路径来说，BFS是更好的选择。 个人解答 1太久没写我居然写不出来BFS，很难受。 题目解析 -无解析 标准解答（BFS） 12345678910111213141516171819202122232425static bool Search(Graph g, Vertex start, Vertex end)&#123; if(start &#x3D;&#x3D; end)return true; foreach(Vertex v in g.GetVertexs())&#123; v.state &#x3D; State.Unvisited; &#125; Queue&lt;Vertex&gt; q &#x3D; new Queue&lt;Vertex&gt;(); start.State &#x3D; State.Visiting; q.Enqueue(start); while(q.Count !&#x3D; 0)&#123; Node u &#x3D; q.Dequeue(); if(u !&#x3D; null)&#123; foreach(Vertex v in u.GetAdjacent())&#123; if(v.state &#x3D;&#x3D; State.Unvisited)&#123; if(v &#x3D;&#x3D; end)return true; else&#123; v.state &#x3D; State.Visiting; q.Enqueue(v); &#125; &#125; &#125; u.state &#x3D; State.Visted; &#125; &#125; return false; &#125; 复杂度分析 如果是单链表实现的队列，其入队时间复杂度为O(n),出队为O(1)。这段代码的时间复杂度为O(n)。双链表则为O(1)。 反思 基础知识不扎实，越是耳熟能详的算法越要自己亲手实现过才算是真正掌握了。 提示 -有两个众所周知的算法可以做到这一点，其利弊是什么？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"求职岗位调研（渲染相关）","slug":"求职岗位调研（渲染相关）","date":"2020-06-26T14:47:36.000Z","updated":"2020-06-26T16:59:18.975Z","comments":false,"path":"2020/06/26/求职岗位调研（渲染相关）/","link":"2020/06/26/求职岗位调研（渲染相关）","permalink":"http://ssssshinji.github.io/2020/06/26/%E6%B1%82%E8%81%8C%E5%B2%97%E4%BD%8D%E8%B0%83%E7%A0%94%EF%BC%88%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3%EF%BC%89/","excerpt":"","text":"字节跳动相关职位 渲染引擎研发工程师-抖音/抖音火山版/直播 职位描述 1.参与开发面向移动端的特效引擎项目； 2.参与特效引擎的核心模块开发； 3.支持特效业务的实现和落地； 4.支持特效工具链的建设。 职业要求 1.图像处理或图形学相关专业或主修过相关课程，2021届获得本科及以上学历； 2.熟练掌握C++，熟悉C11标准相关特性； 3.熟悉图形开发相关技术（OPENGL，DirectX，METAL，VULCAN）和GPU架构优先； 4.有商业引擎的实践经验优先，如：Unity，UE，CryEngine, GamePlay3D等； 5.对技术有极大的热情，学习能力强，责任心强，工作认真细致，具备良好的服务意识，具有良好的团队沟通与协作能力。 游戏引擎开发工程师 职位描述 1.参与引擎和游戏基础组件和工具的研发； 2.帮助项目组解决引擎，组件和工具问题； 3.帮助项目组研究解决方案，优化性能问题。 职业要求 1.大学本科及以上学历，计算机软件专业或数学专业优先，2021年毕业； 2.至少熟练掌握一⻔计算机语言； 3.计算机基础素养优秀，熟悉语言，数据结构，操作系统，计算机网络等； 4.熟悉Unity或Unreal引擎，熟悉计算机图形学，熟悉Shader开发； 5.有较强的学习能力，能够熟练阅读英文技术文档，具有较强的分析与解决问题能力； 6.熟悉OpenGL、DirectX、Metal或Vulkan等技术的优先； 7.熟悉移动端开发经验者优先； 游戏技术美术-游戏业务 职位描述 1.成为国内一流游戏研发团队的一员，和国内顶级的研发团队一起工作，完成挑战； 2.研究业界领先的渲染,物理，动画等技术，与美术大牛一起推动各种新技术在项目中应用落地； 3.探索游戏行业先进的技术和工具，完善项目的内容制作流程与内容生产管线，不断完善游戏的开发效率和品质体验； 4.针对各个软硬件平台进行游戏性能和表现的极致优化； 5.提取项目中的最佳实践，推动优秀技术方案的普及和广泛应用。 职业要求 1.大学本科及以上学历，2021年毕业； 2.熟悉shader，能制作符合美术需求的shader，有shader性能优化经验； 3.有良好的审美和逻辑思维能力，具备独立解决美术向技术问题的能力； 4.积极主动，能承受一定的工作压力，对游戏开发充满热情。 以下是加分项 5.热爱：热爱游戏，体验过大量且多种类型游戏，对游戏制作拥有极大热情； 6.技术：熟悉一款主流美术软件3dMax、Maya、Zbrush、Substance Painter等，熟悉Unity、Unreal等主流商业引擎； 7.奖项：在GameJam比赛中斩获过奖项； 8.积累：有自己的技术博客、开源项目者，有过海外留学经历者，或有游戏公司实习经验。 完美世界相关职位 游戏技术美术工程师 职位描述 1.负责引擎相关工具的开发与维护； 2.根据美术需求编写相关shader； 3.对美术工作中遇到的问题提供技术支持； 4.制定美术资源制作规范； 5.优化效率，了解相关性能分析工具。 岗位要求 1.热爱生活、热爱游戏，对玩游戏和做游戏充满激情，并渴望做出成功的游戏； 2.熟练掌握C#语言，了解或者熟悉MaxScript、JavaScript、Python； 3.熟悉计算机图形渲染管线和基础知识；能根据需求独立编写shader； 4.了解3D美术相关工具，包括：3DMax、Substance Painter、Photoshop等； 5.熟悉Unity3D相关知识，有实际开发经验者优先考虑。 引擎开发程师 职位描述 1.负责3D游戏引擎和工具的开发； 2.对渲染关技术进行前瞻性研究； 3.负责引擎的改进和维护工作。 岗位要求 1.熟练掌握C++知识与多线程技术 ； 2.熟练掌握3D数学、渲染相关算法与数据结构 ； 3.掌握D3D或OpenGL渲染管线流程 ； 4.掌握图形API和Shader语言（D3D hlsl 或 OpenGL glsl）； 5.有性能优先的开发思路，懂得基本的代码优化技巧； 6.独立思考和分析能力，面对复杂问题能够快速找到答案 ； 7. 熟练的沟通与表达能力，有团队合作精神 。 巨人网络 游戏引擎开发工程师 职位描述 1.负责3D引擎的相关开发，如场景管理，人物动画，特效，SHADER，动作融合，粒子等; 2.负责游戏美术相关插件编写； 3.负责引擎相关工具开发，优化3D引擎的性能。 岗位要求 1.计算机基础知识扎实，有一定的编程经验； 2.熟悉C++、STL及各种设计模式,熟悉各种数据结构和算法； 3.熟悉3D图形学原理,熟悉3d图形的常用技术,有较强的数学功底； 4.熟悉HLSL,Shader编写； 5.具备良好的逻辑思维、综合分析能力，以及团队协作能力。有主动学习的能力和意愿，对技术研究有热情; 6.硕士及以上学历，计算机或相关专业。 IGG 高级技术美术 职位描述 1.和美术人员、引擎程序员一起设计渲染方案，负责Shader编写，实现优秀的美术效果 2.充分全面了解美术流程各环节的需求和问题，及时高质量地提供开发工具，技术指导和解决方案； 3.制定美术资源规范，监督项目人员规范执行； 4.对游戏性能进行Profiling，设计优化方案； 岗位要求 1.熟悉计算机图形学，包括图形管线及图形API，着色器语言，有渲染器设计经验者加分； 2.熟练精通Unity游戏引擎，有Unreal或其他商业游戏引擎经验者加分； 3.熟悉编程和脚本语言：Maxscript, Mel, Python至少一项，C#/C++至少一项，有美术软件工具集或引擎开发经验者加分； 4.熟悉常用美术工具，如Max/Maya，Photoshop，Substance，ZBrush等，并具备较好的审美能力和美术功底； 5.熟悉常用的PC及移动端Profiling工具，GPA，Renderdoc，Nsight，SnapdragonProfiler等； 6.良好的沟通交流能力，工作积极主动，能承受一定的工作压力，有英文交流能力者加分； 7.8+年游戏开发经验，5+年技术美术相关经验，具备次世代游戏项目开发经验者加分。 分析及总结 渲染相关的工作大致分为两种，第一个方向是研发引擎类，该类除了图形学的技术，还重视个人的编程能力和计算机基础知识（尤其是数据结构）的扎实程度。作为应对，刷题是一个很好的选择。另一个方向是技美，该类稍微放宽了计算机基础知识及编程能力的门槛，但相对的，需要对shader有更好的掌握，并且至少熟悉一种商业3D软件，同时对美术素养也有一定要求。平时自己制作shader和捏人对这方面是个不错的锻炼。 可以选择的有各个游戏公司（技美），视频处理相关的公司（渲染引擎研发），想研发自己渲染/游戏引擎的公司。总的来说，就职范围不广，市场需求较少，且要求较高。感觉基本是凉了 1. 2. 3. 4.对游戏性能进行Profiling，设计优化方案； 5. 6. 7.","categories":[{"name":"monolog","slug":"monolog","permalink":"http://ssssshinji.github.io/categories/monolog/"}],"tags":[{"name":"不想却又不得不工作","slug":"不想却又不得不工作","permalink":"http://ssssshinji.github.io/tags/%E4%B8%8D%E6%83%B3%E5%8D%B4%E5%8F%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%B7%A5%E4%BD%9C/"}]},{"title":"问题1：移除重复节点","slug":"问题1：移除重复节点","date":"2020-06-26T13:27:58.000Z","updated":"2020-07-05T16:38:33.654Z","comments":false,"path":"2020/06/26/问题1：移除重复节点/","link":"2020/06/26/问题1：移除重复节点","permalink":"http://ssssshinji.github.io/2020/06/26/%E9%97%AE%E9%A2%981%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目描述 编写代码，移除未排序链表中的重复节点。进阶：如果不得使用临时缓冲区，该怎么解决？（提示在页尾） 个人思路 新建一个字典(dictionary)，依次把每个节点的value当作键添加到字典中，字典的值随便取。每次碰到新节点时先调用CintainsKey(key)方法，因为字典中键的唯一性，返回true时说明该节点重复。不使用缓冲区不会做。 个人解答 123456789101112void deleteDups(LinkedListNode node)&#123; Dictionary&lt;key,value&gt; dic &#x3D; new Dictionary&lt;key,value&gt;(); LinkedListNode previous &#x3D; null; while(node !&#x3D; null)&#123; if(dic.ContainsKey(node.value))&#123; previous.Next &#x3D; node.next; &#125; else &#123; dic.Add(node.value); previous &#x3D; node; &#125; node.next; &#125; 题目解析 -要想移除链表中的重复节点，需要设法记录有哪些是重复的。这里只要用到一个简单的散列表。 标准解答 12345678910111213void deleteDups(LinkedListNode node)&#123; HashSet&lt;item&gt; set &#x3D; new HashSet&lt;item&gt;(); LinkedListNode previous &#x3D; null; while(node !&#x3D; null)&#123; if(set.Contains(node.value))&#123; previous.Next &#x3D; node.next; &#125; else &#123; set.Add(node.value); previous &#x3D; node; &#125; node.next; &#125; &#125; 复杂度分析 这段代码的时间复杂度为O(n),n为链表节点数目。 不使用临时缓冲区的情况 如果不使用额外的缓冲区，可以使用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的节点时候重复。 标准解答（不使用临时缓冲区） 1234567891011121314void deleteDups(LinkedListNode head)&#123; LinkedListNode current &#x3D; head; while(current !&#x3D; null)&#123; LinkedListNode runner &#x3D; current; while(runner.next !&#x3D; null)&#123; if(current.value &#x3D;&#x3D; runner.next.value)&#123; runner.next &#x3D; runner.next.next; &#125; else&#123; runner &#x3D; runner.next; &#125; &#125; current &#x3D; current.next; &#125; 复杂度分析 这段代码的空间复杂度为O(1)，但时间复杂度为O(N^2)。 反思 第一问基本思路相同，刚好复习一下dictionary和hashSet的区别。对于不使用缓冲区的情况，老想着怎么样轻易解决，却忘了大部分算法都是先用最简单的方式得出结果再慢慢优化的，忽略了双指针循环。 提示 -你有没有试过一个散列表？你应该可以通过一次链表遍历做到这一点。 -没有额外的空间，你需要O(N^2)的时间。尝试使用两个指针，其中第二个指针在第一个指针之前搜索。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"问题1：判定字符是否唯一","slug":"问题1：判定字符是否唯一","date":"2020-06-25T07:36:02.000Z","updated":"2020-06-30T18:05:34.910Z","comments":false,"path":"2020/06/25/问题1：判定字符是否唯一/","link":"2020/06/25/问题1：判定字符是否唯一","permalink":"http://ssssshinji.github.io/2020/06/25/%E9%97%AE%E9%A2%981%EF%BC%9A%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/","excerpt":"","text":"题目描述 实现一个算法，确定一个字符串的所有字符是否不全都不同。假使不允许使用额外的数据结构，又该如何处理？（提示在页尾） 个人思路 如果可用其他的数据结构，创建一个list，逐个将字符加入到list中。在加入前调用List.Contains()查询是否已经有该字符，有则报错。如果不可用别的数据结构，按照ASCII码排序，再看是否有相邻字符相等，或者拿每一个和剩下的字符比较。 个人解答（使用数据结构） 1234567891011121314151617Boolean isUnique(string str)&#123; ArrayList list &#x3D; new ArrayList(); for (int i &#x3D; 0; i &lt; str.Length; i++) &#123; if (!list.Contains(str[i])) &#123; list.Add(str[i]); &#125; else &#123; return false; &#125; &#125; return true;&#125; 题目解析 -要关注字符串是ASCII串还是Unicode串，这关系到你需要使用的数组大小（在标准解答中，按照ASCII处理） -如果字符串长度超过了字母表中不同字符的个数(ASCII:128)，直接返回false 标准解答（使用数据结构） 1234567891011121314Boolean isUnique(string str)&#123; if(str.Length &gt; 128)return false; bool[] char_set &#x3D; new bool[128]; for(int i &#x3D; 0; i &lt; str.Length; i++)&#123; int val &#x3D; str[i]; &#x2F;&#x2F;在字符串中已找到过 if(char_set[val])&#123; return false; &#125; char_set[val] &#x3D; true; &#125; return true;&#125; 复杂度分析 这段代码的时间复杂度为O(n)，其中n为字符串长度。空间复杂度为O(1)。你也可以认为时间复杂度是O(1)，因为for循环的迭代永远不会超过128次。如果不想假设字符集是恒定的，也可以认为空间复杂度是O(c )，时间复杂度是O(min(c,n))或者O(c )，其中c是字符集的大小。 不使用数据结构的情况 思路和自己的思路相同，无代码解析。 反思 没有注意到字符数量是有限的，从而利用数组解决问题。类似的使用数组的方式还有很多，需要注意。 提示 -用散列表试试 -位向量有用吗 -你能用O(NlogN)的时间复杂度解决它吗","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"算法常见面试题1-5","slug":"算法常见面试题1-5","date":"2020-06-24T13:14:39.000Z","updated":"2020-06-25T07:42:03.548Z","comments":false,"path":"2020/06/24/算法常见面试题1-5/","link":"2020/06/24/算法常见面试题1-5","permalink":"http://ssssshinji.github.io/2020/06/24/%E7%AE%97%E6%B3%95%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%981-5/","excerpt":"","text":"1.算法的几个特征是什么？ 1.有穷性 (Finiteness) 指算法必须在执行有限个步骤之后终止。 2.确切性 (Definiteness) 算法的每一步骤必须有确切的定义。 3.输入项 (Input) 一个算法有0个或者多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。 4.输出项 (Output) 一个算法有一个或者多个输出，以反映对输入数据加工后的结果。没有输出的算法毫无意义。 5.可行性 (Effectiveness) 算法中执行的任何计算步骤都可以被分解为基本的可执行操作，即每个计算步骤都可以在有限时间内完成，也称之为有效性。 2.算法复杂性的定义。大O、θ、Ω、小o分别表示的含义是什么？ 算法复杂度分为空间复杂度S(n)和时间复杂度T(n)。 空间复杂度指在运行过程中为局部变量分配的存储空间的大小，它包括参数列表中的形参变量和函数体中定义的局部变量两个部分，记作S(n) = O(f(n))。时间复杂度定性描述了该算法的运行时间，记作T(n) = O(f(n))。 如果算法A需要的时间与f(n)成正比，则称算法A为f(n)阶，记为O(f(n))。函数f(n)称为算法的增率函数(growth-rate function)。该表示法使用大学字母O(Order)来表示，故称为大O表示法。若规模为n的问题需要的时间与n成正比，则问题表示为O(n),即n阶。若需要的时间与\\(n^2\\)成正比，则问题表示为O(\\(n^2\\)),以此类推。**O并不是一个函数。**他的属性有： 1.可忽略算法增率函数的低阶项 2.可忽略算法增率函数中高阶项的倍输常量 3.O(f(n)) + O(g(n))=O(f(n)+g(n))可组合增率函数 形式化定义： 给定2个正值函数f和g，定义：f(n) = O(g(n)),条件为：存在正实数c和N，使得对于所有的n\\(\\ge\\)N,有|f(n)|\\(\\le\\)|cg(n)|。上述的定义表明，当n足够大，大过一个特定的N时，且存在一个正数c，使得|f(n)|不大于|cg(n)|,则f是g的O表示。关系可以解释为g(n)是f(n)的一个上界，也可以理解为f增长的速度最多和g一样快，而不会超过g。 名称 表示法 定义 Tilde f(n)~g(n) $$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 1$$ Big Oh f(n) is O(g(n)) $$\\exists c \\gt 0, n_0 \\ge 0$$such that \\( 0 \\le f(n) \\le c \\cdot g(n)\\) for all \\(n \\ge n_0\\) Big Omega f(n) is \\(\\Omega\\)(g(n)) g(n) is O(f(n)) Big Theta f(n) is \\(\\Theta\\)(g(n)) f(n) is both O(g(n)) and \\(\\Omega\\)(g(n)) Little oh f(n) is o(g(n)) $$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0$$ Little omega f(n) is \\(\\omega\\)(g(n)) g(n) is o(f(n)) 3.递归算法的定义，及其两要素。 递归就是循环定义，对于一个方法来说，就是自己调用自己。 两要素： -终止条件 -递推公式 经典汉诺塔问题(c#实现) 1234567891011121314151617181920212223using System;namespace Hanoi_Tower&#123; class Program &#123; static void Main(string[] args) &#123; int n &#x3D; Int32.Parse(Console.ReadLine()); Hanoi(n,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#125; private static void Hanoi(int n, string a,string b, string c)&#123; if(n &#x3D;&#x3D; 1)Move(a,c); else &#123; Hanoi(n-1, a, c, b); Move(a,c); Hanoi(n-1, b, a, c); &#125; &#125; private static void Move(string origin, string des)&#123; Console.WriteLine(origin+ &quot;---&gt;&quot; + des); &#125; &#125;&#125; 4.分治算法的思想，经典的分治算法(全排列、二分搜索、归并排序、快速排序、线性时间选择、最接近点对问题)。","categories":[],"tags":[]},{"title":"求职之前","slug":"求职之前","date":"2020-06-24T10:31:25.000Z","updated":"2020-06-25T09:20:26.342Z","comments":true,"path":"2020/06/24/求职之前/","link":"","permalink":"http://ssssshinji.github.io/2020/06/24/%E6%B1%82%E8%81%8C%E4%B9%8B%E5%89%8D/","excerpt":"","text":"一些思考 找工作真的是件非常困难的事啊，动不动就会和人生目标啦理想啦联合在一起。虽然很赞同“世界是荒谬的”这一观点，不过人不给自己找个目标就难以生活下去啊。真是麻烦死了。 话说回来我也没想过实现什么伟业，自己能有个感兴趣的小目标，实现了之后能有小小的自我满足，就够了。那么来检讨一下目前可选择的方案。 读博士教书 说到底外人说的博士起点高，层次高之类的老生常谈对我而言都是虚的。我只是构思了一个工作轻松，闲暇时间可以打打游戏，搞搞创作之类的轻松生活而已。搞科研，传道授业解惑之类的，有兴趣，但是不大，也没那个倔强劲。 工作 读博的话还能从目前的人生中稍微取取经，思考工作真是让人无从下手。做都没做过的事情，要怎么来评判啊。按着兴趣排序的话，第一应该是渲染工程师吧。面试看重的是扎实的计算机基础，shader的编写能力，最好再对一两个软件得心应手。说实话应该是最接近我目前现状的职位要求了，而且感觉能从中得到自我满足，还不错。接着是引擎开发工程师吗？兴趣还可以，困难应该会比较多，比前一个职位更加看重编程能力。主要在于架构的设计，代码的调试，以及你脑中的代码量够不够你想到解决问题的方法。我不知道我目前的兴趣能不能撑很久。3D模型师？总是看网上太太们的作品看得津津有味，跃跃欲试，如果当成工作的话会怎么样呢。个人感觉和之前的职业对比区别较大，需要培养的是设计的思维和美感，经过大量的练习来提高自己的软件熟练度。在我心里已经把她归到属于设计类的行业了。那么，果然还是当作自己的业余爱好比较好吧，不然读计算机干嘛呢。。换句话说，凭什么竞争的过专业的3D设计师呢。 有时候列举出来才懂排除法的妙。基本就只有第一条路可以走了，那么要做的准备就很明确了。提高专业素养保证自己的基础知识储备和计算机图形学相关的知识储备，了解渲染前沿的技术以及成熟程度，最好多手写shader的代码，3D软件的使用是个加分项，可以适当的看一看，不过还是别太花时间比较好。科研什么的，还是往后放一放吧（虽然本来也拖得够久了。。。）","categories":[{"name":"自白","slug":"自白","permalink":"http://ssssshinji.github.io/categories/%E8%87%AA%E7%99%BD/"}],"tags":[{"name":"对工作的牢骚","slug":"对工作的牢骚","permalink":"http://ssssshinji.github.io/tags/%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%89%A2%E9%AA%9A/"}]},{"title":"图片测试","slug":"image","date":"2020-06-20T11:53:43.000Z","updated":"2020-06-24T10:50:10.571Z","comments":false,"path":"2020/06/20/image/","link":"2020/06/20/image","permalink":"http://ssssshinji.github.io/2020/06/20/image/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"幸运星 第一话（外链视频测试）","slug":"video","date":"2020-06-20T09:32:57.000Z","updated":"2020-06-24T12:33:37.079Z","comments":false,"path":"2020/06/20/video/","link":"2020/06/20/video","permalink":"http://ssssshinji.github.io/2020/06/20/video/","excerpt":"","text":"","categories":[{"name":"动漫","slug":"动漫","permalink":"http://ssssshinji.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"幸运星","slug":"幸运星","permalink":"http://ssssshinji.github.io/tags/%E5%B9%B8%E8%BF%90%E6%98%9F/"}]}],"categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"},{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"name":"monolog","slug":"monolog","permalink":"http://ssssshinji.github.io/categories/monolog/"},{"name":"自白","slug":"自白","permalink":"http://ssssshinji.github.io/categories/%E8%87%AA%E7%99%BD/"},{"name":"动漫","slug":"动漫","permalink":"http://ssssshinji.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"},{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"栈与队列","slug":"栈与队列","permalink":"http://ssssshinji.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"name":"递归与动态规划","slug":"递归与动态规划","permalink":"http://ssssshinji.github.io/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数学与逻辑题","slug":"数学与逻辑题","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E5%AD%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E9%A2%98/"},{"name":"不想却又不得不工作","slug":"不想却又不得不工作","permalink":"http://ssssshinji.github.io/tags/%E4%B8%8D%E6%83%B3%E5%8D%B4%E5%8F%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%B7%A5%E4%BD%9C/"},{"name":"对工作的牢骚","slug":"对工作的牢骚","permalink":"http://ssssshinji.github.io/tags/%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%89%A2%E9%AA%9A/"},{"name":"幸运星","slug":"幸运星","permalink":"http://ssssshinji.github.io/tags/%E5%B9%B8%E8%BF%90%E6%98%9F/"}]}