{"meta":{"title":"inside","subtitle":"","description":"","author":"zyt","url":"http://Ssssshinji.github.io","root":"/"},"pages":[],"posts":[{"title":"问题精析：柏林噪声代码实现","slug":"问题精析：柏林噪声代码实现","date":"2020-07-29T04:51:47.000Z","updated":"2020-07-29T05:05:16.557Z","comments":false,"path":"2020/07/29/问题精析：柏林噪声代码实现/","link":"2020/07/29/问题精析：柏林噪声代码实现","permalink":"http://ssssshinji.github.io/2020/07/29/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344&#x2F;&#x2F;类似与哈希函数，根据输入的顶点得到一个伪随机的梯度向量 private static readonly int[] permutation &#x3D; &#123; 151,160,137,91,90,15, 131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23, 190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33, 88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166, 77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244, 102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196, 135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123, 5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42, 223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9, 129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228, 251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107, 49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254, 138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180 &#125;; &#x2F;&#x2F;点乘 static float Dot(Vector2 v1, Vector2 v2) &#123; return v1.x * v2.x + v1.y * v2.y; &#125; &#x2F;&#x2F;求梯度值(这里是求定点代表的梯度向量和距离向量的点积) static float Grad(Vector2 vertex, Vector2 p) &#123; return Dot(new Vector2(permutation[(int)vertex.x], permutation[(int)vertex.y]), p); &#125; &#x2F;&#x2F;二维柏林噪声 static float perlinNoise(Vector2 p) &#123; &#x2F;&#x2F;向量两个维度向下取整,为了求出点在哪个方格 Vector2 pi &#x3D; new Vector2((int)p.x, (int)p.y); &#x2F;&#x2F;计算缓和曲线，这里用的是最原始的 Vector2 pf &#x3D; p - pi; Vector2 w &#x3D; pf * pf * (new Vector2(3.0f, 3.0f) - (float)2.0 * pf); &#x2F;&#x2F;二维晶格四个顶点 Vector2[] vertex &#x3D; &#123; new Vector2(pi.x, pi.y), new Vector2(pi.x + 1, pi.y), new Vector2(pi.x, pi.y + 1), new Vector2(pi.x + 1, pi.y + 1) &#125;; &#x2F;&#x2F; Debug.Log(&quot;x_1&quot; + Mathf.Lerp(Grad(vertex[0], pf), Grad(vertex[1], pf - new Vector2(1.0f, 0.0f)), w.x)); &#x2F;&#x2F; Debug.Log(w.x); &#x2F;&#x2F; Debug.Log(&quot;x_2&quot; + Mathf.Lerp(Grad(vertex[2], pf - new Vector2(0.0f, 1.0f)), Grad(vertex[1], pf - new Vector2(1.0f, 1.0f)), w.x)); &#x2F;&#x2F; Debug.Log(w.y); return Mathf.Lerp( Mathf.Lerp(Grad(vertex[0], pf), Grad(vertex[1], pf - new Vector2(1.0f, 0.0f)), w.x), Mathf.Lerp(Grad(vertex[2], pf - new Vector2(0.0f, 1.0f)), Grad(vertex[1], pf - new Vector2(1.0f, 1.0f)), w.x), w.y); &#125; 参考资料 1. 游戏开发中的噪声算法","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题6：后继者","slug":"问题6：后继者","date":"2020-07-29T03:48:16.000Z","updated":"2020-07-29T04:48:37.765Z","comments":false,"path":"2020/07/29/问题6：后继者/","link":"2020/07/29/问题6：后继者","permalink":"http://ssssshinji.github.io/2020/07/29/%E9%97%AE%E9%A2%986%EF%BC%9A%E5%90%8E%E7%BB%A7%E8%80%85/","excerpt":"","text":"题目描述 设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。可以假定每个节点都含有指向父节点的连接。（提示在页尾） 个人思路 中序遍历二叉搜索树会得到一个升序排列。指定节点的下一个节点应该是右子树的最左节点，如果没有右子树，则是父节点。 个人解答 1234567891011121314&#x2F;&#x2F;该解法有误！！！！！！未考虑当前节点是父节点的右子节点的情况 static TreeNode FindNextNode(TreeNode node)&#123; TreeNode curr &#x3D; node; if(curr.right !&#x3D; null)&#123; curr &#x3D; curr.right; while(curr.left !&#x3D; null)&#123; curr &#x3D; curr.left; &#125; &#125; else&#123; curr &#x3D; node.parent; &#125; return curr; &#125; 题目解析 回想一下中序遍历，它会遍历左子树，然后是当前节点，接着是右子树。要解决这个问题，必须格外小心，想想具体是怎么回事。 假定我们有一个假想的节点。已知访问顺序为左子树，当前节点，然后是右子树。显然，下一个节点应该位于右边。 不过，到底是右子树的哪个节点呢？如果中序遍历右子树，那它就会是接下来第一个被访问的节点，也就是说，它应该是右子树最左边的节点。够简单的吧！ 但是，若这个节点没有右子树，又该怎么办？这种情况就有点棘手了。 若节点n没有右子树，那就表示已遍访n的子树。我们必须回到n的父节点，记作q。 若n在q的左边，那么，下一个我们应该访问的节点就是q（中序遍历，left -&gt; current -&gt;right）。 若n在q的右边，则表示已遍历q的子树。我们需要从q往上访问，直至找到还未完全遍历过的节点x。怎么才能知道还未完全遍历节点x呢？之前从左节点访问至其父节点时，就已碰到了这种情况。左节点已完全遍历，但其父节点尚未完全遍历。伪代码大致如下。 1234567891011Node InOrderSucc(Node n)&#123; if(n has a right subtree)&#123; return leftmost child of right subtree &#125; else&#123; while(n is a right child of n.parent)&#123; n &#x3D; n.parent; &#x2F;&#x2F;向上移动 &#125; return n.parent &#x2F;&#x2F;如果父节点还未遍历 &#125;&#125; 且慢，如果一路往上遍访这棵树都没发现左节点呢？只有当我们遇到中序遍历的最末端时，才会出现这种情况，也就是说，如果我们已位于树的最右边，那就不会再有中序后继，此时该返回null。 标准解答 12345678910111213141516171819202122static TreeNode FindNextNode(TreeNode node)&#123; if(node &#x3D;&#x3D; null)return null; TreeNode curr &#x3D; node; if(curr.right !&#x3D; null)&#123; curr &#x3D; curr.right; while(curr.left !&#x3D; null)&#123; curr &#x3D; curr.left; &#125; return curr; &#125; else&#123; curr &#x3D; node; TreeNode currParent &#x3D; curr.parent; &#x2F;&#x2F;找到curr是左子节点的节点 while(currParent !&#x3D; null &amp;&amp; currParent.left !&#x3D; curr)&#123; curr &#x3D; currParent; currParent &#x3D; currParent.parent; &#125; &#x2F;&#x2F;如果是最右节点，currParent最后会是null return currParent; &#125;&#125; 这不是世上最复杂的算法问题，要写出完美无瑕的代码却有难度。面对这类问题，一种行之有效的做法是用伪代码勾勒大纲，仔细描绘各种不同的情况。 反思 情况没有考虑完全。 提示：#79，#91 -想想中序遍历是如何工作的，并尝试对其进行“逆向工程”。 -这只是逻辑方法中的一步：一个特定节点的后继节点是右子树的最左节点。如果没有右子树呢？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"问题精析：c#：IComparable和IComparer","slug":"问题精析：c-：IComparable和IComparer","date":"2020-07-27T16:05:03.000Z","updated":"2020-07-27T16:25:32.331Z","comments":false,"path":"2020/07/28/问题精析：c-：IComparable和IComparer/","link":"2020/07/28/问题精析：c-：IComparable和IComparer","permalink":"http://ssssshinji.github.io/2020/07/28/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9Ac-%EF%BC%9AIComparable%E5%92%8CIComparer/","excerpt":"","text":"概念 IComparable：可比较接口：IComparable 在要比较的对象的类中实现，可以比较该对象和另一个对象。IComparable提供了一个方法int CompareTo(object obj)。这个方法接受一个对象，所以可以实现这个接口 12345678910111213public class ClassTest : IComparable&#123; public int intTest; public int CompareTo(object obj) &#123; &#x2F;&#x2F;类型转换，这里的写法不安全，应该用as return intTest-((ClassTest)obj).intTest; &#x2F;&#x2F;这里的代码可以按需要自己编写，这里只是一个简单的示例 &#125;&#125;ClassTest a &#x3D; new ClassTest()&#123;intTest&#x3D;1&#125;;ClassTest b &#x3D; new ClassTest()&#123;intTest&#x3D;2&#125;;Console.WriteLine(a.CompareTo(b));&#x2F;&#x2F;输出-1 IComparer：比较器：IComparer 也提供了一个方法Compare()。这个方法接受两个对象，返回一个整型结果，这与 CompareTo()相同。 1234567891011121314public class ClassTestComparer : IComparer&#123; public static IComparer Default &#x3D; new ClassTestComparer(); &#x2F;&#x2F;这里必须使用这样的定义，将对象转化为IComparer类型有很大用处，下面会介绍 public int Compare(object a,object b) &#123; return ((ClassTest)a).intTest - ((ClassTest)b).intTest; &#x2F;&#x2F;同样这里使用最简单的示例，但是你可以大放异彩 &#125;&#125;ClassTest a &#x3D; new ClassTest()&#123;intTest&#x3D;1&#125;;ClassTest b &#x3D; new ClassTest()&#123;intTest&#x3D;2&#125;;Console.WriteLine(ClassTestComparer.Default.Compare(a,b));&#x2F;&#x2F;结果是-1 &amp;emsp两个接口提供的方法返回值都是int类型的，负数代表小于，0代表等于，正数代表大于。所以对数字之外的自定义比较器，需要人工设定什么是“大”，什么是“小”。所以上文示例中两个数直接相减，就可以比较大小。 注意事项 在这两种情况下，提供给方法的参数是system.object类型。也就是说，可以比较任意类型的两个对象。所以，在返回结果之前，通常需要进行某种类型比较，如果使用了错误的类型，还会抛出异常。这种情况可以用泛型来解决。 对集合使用Sort()时，形参中是IComparer（比较器）类型。排序完之后，按照返回的int值，集合是由小到大排列的。 使用无参Sort()时，集合中至少要有一个类实现了IComparable，否则会报错。 不要使用new运算符直接创建Comparer类的实例，应调用Default方法，该方法将返回一个已被适当地初始化过的Comparer对象，如下： 1ComparertheComparer&#x3D;Comparer.Default； 参考资料 1. c# 实现IComparable、IComparer接口、Comparer类的详解 2. C# IComparable和IComparer接口和自定义比较器","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"c#","slug":"c","permalink":"http://ssssshinji.github.io/tags/c/"}]},{"title":"问题2：变位词组","slug":"问题2：变位词组","date":"2020-07-27T13:21:49.000Z","updated":"2020-07-27T15:14:00.187Z","comments":false,"path":"2020/07/27/问题2：变位词组/","link":"2020/07/27/问题2：变位词组","permalink":"http://ssssshinji.github.io/2020/07/27/%E9%97%AE%E9%A2%982%EF%BC%9A%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84/","excerpt":"","text":"题目描述 编写一种方法，对字符串数组进行排序，将所有变位词排在相邻的位置。（提示在页尾） 个人思路 没思路，直接看提示。可以将数组中的每个元素排序，排序后相等的便是字符重组，放在一起即可。但哪怕这样，还需要O(n^2)的时间复杂度。后两个提示根本看不懂啥意思。 个人解答 1无 题目解析 我们需要一种快速简单的方法来确定两个字符串是否互为变位串。究竟是什么界定了两个单词是否互为变位词呢？变位词是指具有相同字符但顺序不同的单词。因此，如果可以把字符放在同一个顺序中，就能很容易地检查出新单词是否相同。 做法之一就是套用一种标准排序算法，比如归并排序或快速排序，并修改比较器（comparator）。这个比较器用来指示两个互为变位词的字符串是一样的。 检查两个词是否互为变位词，最简单的方法是什么呢？我们可以数一数每个字符串中各个字符出现的次数，两者相同则返回true，或者直接对字符串进行排序，若两个字符串互为变位词，排序后就相同。 标准解答 123456789101112131415161718public class AnagramComparator : IComparer&lt;string&gt;&#123; public string sortChars(string s)&#123; char[] content &#x3D; s.ToCharArray(); Array.Sort(content); return new string(content); &#125; public int Compare(string s1,string s2)&#123; return sortChars(s1).CompareTo(sortChars(s2)); &#125;&#125;static void Main(string[] args)&#123; string[] array&#x3D; new string[] &#123;&quot;asdfg&quot;,&quot;qwerty&quot;,&quot;ytrewq&quot;,&quot;gfdsa&quot;&#125;; Array.Sort(array, new AnagramComparator()); for(int i &#x3D; 0; i &lt; array.Length; i++)&#123; System.Console.WriteLine(array[i]); &#125;&#125; 复杂度分析 这个算法的时间复杂度为O(nlog(n))。这可能是使用通用排序算法所能取得的最佳情况了，但实际上，并不需要对整个数组进行排序，只需将变位词分组放在一起即可。 进阶 可以使用散列表做到这一点，这个散列表会将排序后的单词映射到它的一个变位词列表。举例来说，acre会映射到列表{acre, race, care}。一旦将所有同为变位词的单词分在同一组，就可以将它们放回到数组中。 标准解答 12345678910111213141516171819static void Sort(string[] array)&#123; HashMapList&lt;string,string&gt; mL &#x3D; new HashMapList(); &#x2F;&#x2F;将同为变位词的单词分在同一组 foreach(string s in array)&#123; string key &#x3D; sortChars(s); mL.Add(key,s); &#125; &#x2F;&#x2F;将散列表转换为数组 int index &#x3D; 0; foreach(string key in mL.Keys)&#123; ArrayList aL &#x3D; new ArrayList(mL[key]); foreach(string t in aL)&#123; array[index] &#x3D; t; index++; &#125; &#125; &#x2F;&#x2F;这里的HashMapList是一个散列表，是自定义的类，在原书附录A中有实现，特点是可以一个key &#x2F;&#x2F;对应多个value&#125; 你或许看出来了，上面的算法是从桶排序法修改而来的。 反思 排序问题可以利用手动实现比较接口和比较器。 提示：#177，#182，#263，#342 -你如何检查两个单词是否互为变位词？想一想如何定义“变位词”。用你自己的话来解释一下。 -两个单词互为变位词是指含有相同的字符，但顺序不同。怎么才能把字符排好序呢？ -你能利用标准排序算法吗？ -你真的需要真正的排序吗？或者仅需重新组织列表就够了？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"排序和查找","slug":"排序和查找","permalink":"http://ssssshinji.github.io/tags/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/"}]},{"title":"问题精析：柏林噪声原理","slug":"问题精析：柏林噪声原理","date":"2020-07-26T17:24:13.000Z","updated":"2020-07-26T17:32:26.776Z","comments":false,"path":"2020/07/27/问题精析：柏林噪声原理/","link":"2020/07/27/问题精析：柏林噪声原理","permalink":"http://ssssshinji.github.io/2020/07/27/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"应用 柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得奥斯卡科技成果奖（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的改进版柏林噪声算法。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。 如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。 基本原理 注意：事先声明，本节内容大多源于this wonderful article by Matt Zucker，不过该篇文章内容也是建立在1980年所发明的柏林噪声算法基础上的。本文我将使用2002年发明的改进版柏林噪声算法。因此，我的算法版本跟Zucker的版本会有些不同。 让我们从最基本的柏林噪声函数看起： 1public double perlin(double x, double y, double z); 函数接收x,y,z三个坐标分量作为输入，并返回0.0~1.0的double值作为输出。那我们应该怎么处理输入值？首先，我们取3个输入值x,y,z的小数点部分，就可以表示为单元空间里的一个点了。为了方便讲解，我们将问题降维到2维空间来讨论（原理是一样的），下图是该点在2维空间上的表示： 图1：小蓝点代表输入值在单元正方形里的空间坐标，其他4个点则是单元正方形的各顶点 接着，我们给4个顶点（在3维空间则是8个顶点）各自生成一个伪随机的梯度向量。梯度向量代表该顶点相对单元正方形内某点的影响是正向还是反向的（向量指向方向为正向，相反方向为反向）。而伪随机是指，对于任意组相同的输入，必定得到相同的输出。因此，虽然每个顶点生成的梯度向量看似随机，实际上并不是。这也保证了在梯度向量在生成函数不变的情况下，每个坐标的梯度向量都是确定不变的。 图2：各顶点上的梯度向量随机选取结果 请注意，上图所示的梯度向量并不是完全准确的。在本文所介绍的改进版柏林噪声中，这些梯度向量并不是完全随机的，而是由12条单位正方体（3维）的中心点到各条边中点的向量组成： 1(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1) 采用这些特殊梯度向量的原因在Ken Perlin’s SIGGRAPH 2002 paper: Improving Noise这篇文章里有具体讲解。 举个例子来理解伪随机，比如我们从圆周率π（3.14159…）的小数部分中随机抽取某一位数字，结果看似随机，但如果抽取小数点后1位，结果必定为1；抽取小数点后2位，结果必定为4。 接着，我们需要求出另外4个向量（在3维空间则是8个），它们分别从各顶点指向输入点（蓝色点）。下面有个2维空间下的例子： 图3:各个距离向量 接着，对每个顶点的梯度向量和距离向量做点积运算，我们就可以得出每个顶点的影响值： 1grad.x * dist.x + grad.y * dist.y + grad.z * dist.z 这正是算法所需要的值，点积运算为两向量长度之积，再乘以两向量夹角余弦。 点积也可以理解为向量a在向量b上的投影，当距离向量在梯度向量上的投影为同方向，点积结果为正数；当距离向量在梯度向量上的投影为反方向，点积结果为负数。因此，通过两向量点积，我们就知道该顶点的影响值是正还是负的。不难看出，顶点的梯度向量直接决定了这一点。 下一步，我们需要对4个顶点的影响值做插值，求得加权平均值（在3维空间则是8个）。算法非常简单（2维空间下的解法）： 123456789101112&#x2F;&#x2F; Below are 4 influence values in the arrangement:&#x2F;&#x2F; [g1] | [g2]&#x2F;&#x2F; -----------&#x2F;&#x2F; [g3] | [g4]int g1, g2, g3, g4;int u, v; &#x2F;&#x2F; These coordinates are the location of the input coordinate in its unit square. &#x2F;&#x2F; For example a value of (0.5,0.5) is in the exact center of its unit square.int x1 &#x3D; lerp(g1,g2,u);int x2 &#x3D; lerp(g3,h4,u);int average &#x3D; lerp(x1,x2,v); 至此，整个柏林噪声算法还剩下最后一块拼图了：如果直接使用上述代码，由于是采用lerp线性插值计算得出的值，虽然运行效率高，但噪声效果不好，看起来会不自然。我们需要采用一种更为平滑，非线性的插值函数：fade函数，通常也被称为ease curve(也作为缓动函数在游戏中广泛使用)： ease curve的值会用来计算前面代码里的u和v，这样插值变化不再是单调的线性变化，而是这样一个过程：初始变化慢，中间变化快，结尾变化又慢下来（也就是在当数值趋近于整数时，变化变慢）。这个用于改善柏林噪声算法的fade函数可以表示为以下数学形式： $$ 6t^5 - 15t^4 + 10t^3 $$ 基本上，这就是整个柏林噪声算法的原理了！搞清了算法的各个实现关键步骤后，现在让我们着手把代码实现出来。 参考资料 1. 一篇文章搞懂柏林噪声算法，附代码讲解","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题5：链表求和","slug":"问题5：链表求和","date":"2020-07-26T14:54:44.000Z","updated":"2020-07-29T04:30:50.056Z","comments":false,"path":"2020/07/26/问题5：链表求和/","link":"2020/07/26/问题5：链表求和","permalink":"http://ssssshinji.github.io/2020/07/26/%E9%97%AE%E9%A2%985%EF%BC%9A%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/","excerpt":"","text":"题目描述 给定两个用链表表示的整数，每个节点包含一个数位。这些数位是反向存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。（提示在页尾） 示例： 12输入：(7-&gt; 1-&gt; 6) + (5-&gt; 9-&gt; 2),即617加295结果：2-&gt; 1-&gt; 9,即912 进阶：假设这些数位是正向存放的，请再做一遍。 个人思路 考虑各种情况然后写个加法器出来，代码分支非常多而且丑陋。 个人解答 1234567891011121314151617181920212223242526272829303132333435363738394041static Node AddList(Node n1, Node n2)&#123; Node head &#x3D; new Node(0); Node curr &#x3D; head; &#x2F;&#x2F;进位 int carryBit &#x3D; 0; while(n1 !&#x3D; null || n2 !&#x3D; null || carryBit !&#x3D; 0)&#123; &#x2F;&#x2F;链表1空，链表2未空 if(n1 &#x3D;&#x3D; null &amp;&amp; n2 !&#x3D; null)&#123; curr.value &#x3D; n2.value + carryBit; n2 &#x3D; n2.next; &#125; &#x2F;&#x2F;链表2空，链表1未空 else if(n2 &#x3D;&#x3D; null &amp;&amp; n1 !&#x3D; null)&#123; curr.value &#x3D; n1.value + carryBit; n1 &#x3D; n1.next; &#125; &#x2F;&#x2F;只剩下进位，最高位相加的情况 else if(n1 &#x3D;&#x3D; null&amp;&amp;n2 &#x3D;&#x3D; null&amp;&amp;carryBit !&#x3D; 0)&#123; curr.value &#x3D; carryBit; &#125; else &#123; curr.value &#x3D; n1.value + n2.value + carryBit; n1 &#x3D; n1.next; n2 &#x3D; n2.next; &#125; if(curr.value &gt;&#x3D; 10)&#123; curr.value &#x3D; curr.value%10; carryBit &#x3D; 1; &#125; else&#123; carryBit &#x3D; 0; &#125; &#x2F;&#x2F;防止最后会多个curr.next，显示出一个0 if(n1 &#x3D;&#x3D; null&amp;&amp;n2 &#x3D;&#x3D; null&amp;&amp;carryBit &#x3D;&#x3D; 0)&#123; break; &#125; curr.next &#x3D; new Node(0); curr &#x3D; curr.next; &#125; return head;&#125; 题目解析 可以用递归法模拟这个过程，将两个节点的值逐一相加，如有进位则转入下一个节点。 标准解答 1234567891011121314151617181920static Node AddList(Node n1, Node n2, int carryBit)&#123; if(n1 &#x3D;&#x3D; null &amp;&amp; n2 &#x3D;&#x3D; null &amp; carryBit &#x3D;&#x3D; 0)&#123; return null; &#125; Node result &#x3D; new Node(0); int value &#x3D; carryBit; if(n1 !&#x3D; null)&#123; value +&#x3D; n1.value; &#125; if(n2 !&#x3D; null)&#123; value +&#x3D; n2.value; &#125; result.value &#x3D; value % 10; &#x2F;&#x2F;递归 if(n1 !&#x3D; null || n2 !&#x3D; null)&#123; Node more &#x3D; AddList(n1 &#x3D;&#x3D; null ? null : n1.next,n2 &#x3D;&#x3D; null ? null : n2.next, value &gt;&#x3D; 10 ? 1 : 0); result.next &#x3D; more; &#125; return result;&#125; 复杂度分析 O(n)。 进阶 从概念上来说，第二部分并无不同（递归，进位处理），但在实现时稍微复杂一些。 1.一个链表的节点可能比另一个链表的少，我们无法直接处理这种情况。例如，假设要对(1-&gt; 2-&gt; 3-&gt; 4)与(5-&gt; 6-&gt; 7)求和。务必注意，5应该与2而不是1配对。对此，我们可以一开始先比较两个链表的长度并用0填充较短的链表。 2.在前一个问题中，相加的结果不断追加到链表尾部（也即向前传递）。这就意味着递归调用会传入进位，而且会返回结果（随后追加至链表尾部）。不过，这里的结果要加到首部（也即向后传递）。跟前一个问题一样，递归调用必须返回结果和进位。实现也不是太难，但处理起来会更难一些，可以通过创建一个Partial Sum包裹类来解决这一点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class PartialSum &#123; &#x2F;&#x2F;初始为null可以让末尾不会多出一位 public Node sum &#x3D; null; public int carry &#x3D; 0;&#125;static Node AddLists(Node n1, Node n2)&#123; int len1 &#x3D; Length(n1); int len2 &#x3D; Length(n2); &#x2F;&#x2F;将较短的表填充0 if(len1&lt;len2)&#123; n1 &#x3D; PadList(n1, len2 - len1); &#125;else&#123; n2 &#x3D; PadList(n2, len1 - len2); &#125; &#x2F;&#x2F;链表相加 PartialSum sum &#x3D; AddListsHelper(n1,n2); &#x2F;&#x2F;如果有进位，插入到链表首部，否则返回链表 if(sum.carry &#x3D;&#x3D; 0)&#123; return sum.sum; &#125; else&#123; Node result &#x3D; InsertBefore(sum.sum,sum.carry); return result; &#125;&#125;static PartialSum AddListsHelper(Node n1, Node n2)&#123; if(n1 &#x3D;&#x3D; null &amp;&amp; n2 &#x3D;&#x3D; null)&#123; PartialSum sum1 &#x3D; new PartialSum(); return sum1; &#125; &#x2F;&#x2F;递归对较小的数位相加 PartialSum sum &#x3D; AddListsHelper(n1.next,n2.next); &#x2F;&#x2F;进位相加 int val &#x3D; sum.carry + n1.value + n2.value; &#x2F;&#x2F;加入当前数位的和 Node full_result &#x3D; InsertBefore(sum.sum, val % 10); &#x2F;&#x2F;返回当前和进位 sum.sum &#x3D; full_result; sum.carry &#x3D; val&#x2F;10; return sum;&#125;&#x2F;&#x2F;链表填充0static Node PadList(Node n, int padding)&#123; Node head &#x3D; n; for(int i &#x3D; 0; i &lt; padding; i++)&#123; head &#x3D; InsertBefore(head,0); &#125; return head;&#125;static Node InsertBefore(Node node, int data)&#123; Node n &#x3D; new Node(data); if(node !&#x3D; null)&#123; n.next &#x3D; node; &#125; return n;&#125;static int Length(Node n)&#123; int count &#x3D; 0; while(n !&#x3D; null)&#123; count +&#x3D; 1; n &#x3D; n.next; &#125; return count;&#125; 反思 太强了。 提示：#7，#30，#71，#95，#109 -当然，你可以将链表转换为整数，计算总和，然后将其转换回新的链表。如果你在面试中这样做，面试官可能会接受答案，然后看看你在不能将其转换为数字然后返回的情况下，还能否做到这一点。 -尝试递归。假设你有两个链表，A=1-&gt; 5-&gt; 9（代表951）和B=2-&gt; 3-&gt;6-&gt; 7（代表7632），以及一个操作链表其余部分的函数（5-&gt; 9和3-&gt; 6-&gt;7）。你能用这个来创建求和方法吗？sum(1-&gt; 5-&gt; 9, 2-&gt; 3-&gt; 6-&gt; 7)和sum(5-&gt; 9, 3-&gt; 6-&gt; 7)之间有何关系？ -确保你考虑到了链表的长度不同的情况。 -你的算法在形如9-&gt; 7-&gt; 8和6-&gt; 8-&gt; 5的链表上工作吗？仔细检查一下。 -对于后续问题：问题是，当链表的长度不一样时，一个链表的首部可能代表1000的位置，而另一个链表代表10的位置。如果你把它们做的一样长呢？有没有方法修改链表来做到这一点，而不改变它所代表的值？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"问题精析：光线追踪发展史3","slug":"问题精析：光线追踪发展史3","date":"2020-07-25T17:19:12.000Z","updated":"2020-07-25T17:45:26.000Z","comments":false,"path":"2020/07/26/问题精析：光线追踪发展史3/","link":"2020/07/26/问题精析：光线追踪发展史3","permalink":"http://ssssshinji.github.io/2020/07/26/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%8F%91%E5%B1%95%E5%8F%B23/","excerpt":"","text":"Whitted RayTrace 光线追踪基本算法 我们知道递归是光线追踪的最基本的特点，我们先来看没有递归的情况。其实没有递归的情况和RayCasting技术特点几乎是一模一样的。 将直接的shader函数用伪代码实现： 12345shader(point, ray)&#123; calculate surface normal vector use Phong illumination formula to calculate contributions of each light source&#125; 首先如之前所列的年代关系，出现Whitted光线追踪时，并没有提出我们现在做全局光照的渲染方程，所以当时依旧是使用的基于经验的光照模型，就像这里的phong。当然你也可以用其他的。 我们来看递归的形式： 123456789101112shader(point, ray)&#123; radiance &#x3D; black; for each light source shadow_ray &#x3D; calc_shadow_ray(point,light) if !in_shadow(shadow_ray,light) radiance +&#x3D; phing_illumination(point,ray,light) if material is specularly reflective radiance +&#x3D; spec_reflectance * Trace(reflected_ray(point,ray))) if material is specularly transmissive radiance +&#x3D; spec_transmittance * Trace(refracted_ray(point,ray))) return radiance&#125; 首先进行这个点的颜色初始化，如果不在阴影中，我们phong模型的着色，如果材质拥有镜面反射，最后的颜色要加上镜面反射光线的颜色贡献，如果材质拥有折射特性，加上折射的贡献。 当然，这里对于放射和折射的具体计算比较基础，就不表了。搞了这么多，我们先不进行其他的分析，先来看看效果上和RayCasting的区别 还有一个比较重要的问题是什么时候结束这个罪恶的递归？有两种情况。第一种情况是，光线没有打到物体上，第二种是由于每一次反射或者折射，贡献值会逐渐的降低，我们预先设定一个阈值，当它小于这个阈值的时候，我们停止。当然，如果你只按照上面的做法来渲染一个图片出来是可行的，但是会有一些需要解决的问题。 锯齿 我们首要问的问题时，为什么会产生锯齿？由于之前的光线追踪算法对每一个像素值，都只创建了一个光线，都只采样了场景中的一个点，和那一个颜色，但是，对于一个像素而言，有可能包含了很多个不同的点，尤其是在物体边缘的情况下时，这些点不一定都有相同的颜色。而我们这种有规律的采样，就会导致这种锯齿。 超级采样是为每个像素增加的光线数量的过程。这不能解决锯齿问题，但它会尝试减少它们对最终图像的影响。在以下示例中，从像素发出九条光线。六个是蓝色，三个是绿色。像素的最终颜色将是蓝色的三分之二和绿色的三分之一。 ![(https://picb.zhimg.com/80/v2-7639a3642d49cfaabd5da52753b80263_720w.jpg) 自适应超级采样（也称为蒙特卡罗采样）是一种以更智能的方式进行超采样的尝试。首先发出固定数量的光线并比较它们的颜色。如果颜色相似，则程序假定像素正在查看同一个对象，并且光线的平均值被计算为该像素的颜色。如果光线颜色不同（由某个阈值定义）那么我们认为这个像素比较特殊需要进一步检查。在这种情况下，像素被细分为更小的区域，并且每个新区域被视为一个完整的像素。这个过程再次开始，同样的固定光线模式被射入每个新的部分。 遗憾的是，自适应超级采样仍然将像素划分为规则的光线模式，并且会受到常规像素细分可能出现的混叠的影响。例如对象和采样网格机会是对齐的。总之有规律的方法都不得劲。 Stochiastic（随机）采样将固定数量的光线发送到像素中，但确保它们是随机分布的（但或多或少均匀地覆盖该区域）。此外，stochiastic射线试图解决在凹凸不平的表面上跟随入射光线的问题。 这是分布式光线追踪中比较核心的概念，所以放在下面来说。 参考资料 1. 光线追踪 2. [《Real-Time Rendering 3rd》 提炼总结]","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题1：最后k行","slug":"问题1：最后k行","date":"2020-07-25T16:44:52.000Z","updated":"2020-07-25T17:10:02.687Z","comments":false,"path":"2020/07/26/问题1：最后k行/","link":"2020/07/26/问题1：最后k行","permalink":"http://ssssshinji.github.io/2020/07/26/%E9%97%AE%E9%A2%981%EF%BC%9A%E6%9C%80%E5%90%8Ek%E8%A1%8C/","excerpt":"","text":"题目描述 用C++写个方法，打印输入文件的最后K行。（提示在页尾） 个人思路 对c++不是很了解，没有思路。 个人解答 1太久没写我居然写不出来BFS，很难受。 题目解析 此题的蛮力解法如下：先数出文件的行数（N），然后打印第N-K行到第N行。但是，这么做，文件要读两遍，会做无用功。我们需要一种解法，只读一遍文件就能打印最后K行。 我们可以使用一个数组，存放从文件读取到的所有K行和最后的K行。因此，这个数组起初包含的是0至K行，然后是1至K+1行，接着是2至K+2行，以此类推。每次读取新的一行，就将数组中最早读入的那一行清掉。 不过，你可能会问，这么做是不是还要移动数组元素，进而做大量的工作？不会，只要做法得当就不会。我们将使用循环式数组，而不必每次都移动数组元素。 使用循环式数组（circular array），每次读取新的一行，都会替换数组中最早读入的元素。我们会以专门的变量记录这个元素，每次加入新元素，该变量就要随之更新。 下面是循环式数组的例子： 1234步骤1（初始态）：array &#x3D; &#123;a,b,c,d,e,f&#125;. p &#x3D; 0步骤1（初始态）：array &#x3D; &#123;g,b,c,d,e,f&#125;. p &#x3D; 1步骤1（初始态）：array &#x3D; &#123;g,h,c,d,e,f&#125;. p &#x3D; 2步骤1（初始态）：array &#x3D; &#123;g,h,i,d,e,f&#125;. p &#x3D; 3 下面是该算法的实现代码。 标准解答 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;void print:ast10Lines(char* fileName)&#123; const int K = 10; ifstream file (fileName); string L[K]; int size = 0; //逐行读取文件，并存入循环式数组 //行尾的EOF标志不算单独一行 while(file.peek() != EOF)&#123; getline(file,L[size%k]); size++; &#125; int start = size &gt; K ? (size % K) : 0; int count = min(K,size); for(int i = 0l i &lt; count; i++)&#123; cout&lt;&lt;L[(start + i) % K] &lt;&lt; endl; &#125;&#125; 复杂度分析 这种解法要求读取整个文件，不过，任意时刻都只会在内存里存放10行内容。O(n)。 反思 这个方法可以记一下，没有快慢指针用的时候可以使用这种方法。 提示：#449，#459 -如果已经有文件中的行数，我们要怎么做？ -假设我们没有文件中的行数。有没有一种方法可以在不预先计算行数的情况下做到这件事。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"c和c++","slug":"c和c","permalink":"http://ssssshinji.github.io/tags/c%E5%92%8Cc/"}]},{"title":"问题精析：抗锯齿","slug":"问题精析：抗锯齿","date":"2020-07-23T10:32:10.000Z","updated":"2020-07-23T17:11:55.182Z","comments":false,"path":"2020/07/23/问题精析：抗锯齿/","link":"2020/07/23/问题精析：抗锯齿","permalink":"http://ssssshinji.github.io/2020/07/23/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E6%8A%97%E9%94%AF%E9%BD%BF/","excerpt":"","text":"产生锯齿的原因 你能够清楚看见形成边缘的像素。这种现象被称之为锯齿(Aliasing)。锯齿的来源是因为场景的定义在三维空间中是连续的，而最终显示的像素则是一个离散的二维数组。所以判断一个点到底没有被某个像素覆盖的时候单纯是一个“有”或者“没有&quot;问题，丢失了连续性的信息，导致锯齿。 光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。 这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点(Sample Point)，它会被用来决定这个三角形是否遮盖了某个像素。图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所遮盖，所以它们不会受到片段着色器的影响。 你现在可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的： 由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。 SSAA（超级采样） 最开始我们有一种叫做超采样抗锯齿(Super Sample Anti-aliasing, SSAA)的技术，它会使用比正常分辨率更高的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率。这些额外的分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的性能开销。所以这项技术只拥有了短暂的辉煌。 拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。 然而，在这项技术的基础上也诞生了更为现代的技术，叫做多重采样抗锯齿(Multisample Anti-aliasing, MSAA)。它借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿。我们在这一节中会深度讨论OpenGL中内建的MSAA技术。 MSAA（多重采样） 为了理解什么是多重采样(Multisampling)，以及它是如何解决锯齿问题的，我们之前深入地了解OpenGL光栅器的工作方式。 多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。 上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点。这里，只有两个采样点遮盖住了三角形。 采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。 从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。你的猜想可能是，我们对每个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有子采样点的颜色平均一下。在这个例子中，我们需要在两个子采样点上对被插值的顶点数据运行两次片段着色器，并将结果的颜色储存在这些采样点中。（幸运的是）这并不是它工作的方式，因为这本质上说还是需要运行更多次的片段着色器，会显著地降低性能。 MSAA真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。 这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形。让我们来看看前面三角形的多重采样会是什么样子： 这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被遮盖，所以片段着色器的结果将只会储存到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所储存的颜色来决定。 简单来说，一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下的效果： 对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。 例如4xMSAA，三角形只覆盖了4个子采样点中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在像素中央（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只覆盖了一半的采样点。现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。 不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。 OpenGL关键代码 如果我们想要在OpenGL中使用MSAA，我们必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample Buffer)。 1glfwWindowHint(GLFW_SAMPLES, 4);&#x2F;&#x2F;提示(Hint) GLFW，我们希望使用一个包含N个样本的多重采样缓冲。 我们还需要调用glEnable并启用GL_MULTISAMPLE，来启用多重采样。在大多数OpenGL的驱动上，多重采样都是默认启用的，所以这个调用可能会有点多余，但显式地调用一下会更保险一点。这样子不论是什么OpenGL的实现都能够正常启用多重采样了。 1glEnable(GL_MULTISAMPLE); 参考资料 1. 抗锯齿 1. 请问FXAA、FSAA与MSAA有什么区别？效果和性能上哪个好？","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题1：合并排序的数组","slug":"问题1：合并排序的数组","date":"2020-07-23T04:30:45.000Z","updated":"2020-07-23T08:09:31.826Z","comments":false,"path":"2020/07/23/问题1：合并排序的数组/","link":"2020/07/23/问题1：合并排序的数组","permalink":"http://ssssshinji.github.io/2020/07/23/%E9%97%AE%E9%A2%981%EF%BC%9A%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/","excerpt":"","text":"题目描述 给定两个排序后的数组A和B，其中A的末端有足够的缓冲空间容纳B。编写一个方法，将B合并入A并排序。（提示在页尾） 个人思路 可以同时遍历A和B，将B中的元素按按大小插入A中，但是对于数组来说效率太低了。如果能从数组的末端往前面插入，利用本身的空余，可以减少移动数组元素的次数。可以很轻松得到B数组末端元素的位置，可是如何得到A数组最后一个有效元素的位置呢？ 个人解答 12345678910111213141516171819202122static void merge(int[] a, int[] b, int lastA, int lastB)&#123; int indexA &#x3D; lastA; int indexB &#x3D; lastB; int indexFinal &#x3D; lastA + lastB + 1; while(indexA &gt;&#x3D; 0 &amp;&amp; indexB &gt;&#x3D; 0)&#123; if(a[indexA] &gt; indexB)&#123; a[indexFinal] &#x3D; a[indexA]; indexA --; &#125; else&#123; a[indexFinal] &#x3D; b[indexB]; indexB --; &#125; indexFinal--; &#125; &#x2F;&#x2F;如果b中有剩余，还需进一步处理 while(indexB &gt;&#x3D; 0)&#123; a[indexFinal] &#x3D; b[indexB]; indexB --; indexFinal --; &#125;&#125; 题目解析 已知数组A末端有足够的缓冲，不需要再分配额外空间。处理方法很简单，就是逐一比较A和B中的元素，并按顺序插入数组，直至耗尽A和B中的所有元素。 这么做的唯一问题是，如果将元素插入数组A的前端，就必须将原有的元素往后移动，以腾出空间。更好的做法是将元素插入数组A的末端，那里都是空闲的可用空间。 下面的代码就实现了上述做法，从数组A和B的末端元素开始，将最大的元素放到数组A的末端。 标准解答 12345678910111213141516static void merge(int[] a, int[] b, int lastA, int lastB)&#123; int indexA &#x3D; lastA; int indexB &#x3D; lastB; int indexFinal &#x3D; lastA + lastB + 1; while(indexB &gt;&#x3D; 0)&#123; if(indexA &gt;&#x3D; 0 &amp;&amp;a[indexA] &gt; indexB)&#123; a[indexFinal] &#x3D; a[indexA]; indexA --; &#125; else&#123; a[indexFinal] &#x3D; b[indexB]; indexB --; &#125; indexFinal--; &#125;&#125; 复杂度分析 O(m+n)。 反思 又写的比我漂亮，吐啦！有重复代码的时候要考虑能不能合并。 提示：#332 -尝试从数组的末端向前端移动。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"排序和查找","slug":"排序和查找","permalink":"http://ssssshinji.github.io/tags/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/"}]},{"title":"问题2：栈的最小值","slug":"问题2：栈的最小值","date":"2020-07-22T09:10:25.000Z","updated":"2020-07-22T10:10:53.678Z","comments":false,"path":"2020/07/22/问题2：栈的最小值/","link":"2020/07/22/问题2：栈的最小值","permalink":"http://ssssshinji.github.io/2020/07/22/%E9%97%AE%E9%A2%982%EF%BC%9A%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","excerpt":"","text":"题目描述 请设计一个栈，除了pop与push函数，还支持min函数，其可返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。（提示在页尾） 个人思路 min要时间复杂度为O(1),就一定不能用到遍历操作。个人思路是利用一个变量保存最小值，在每次入栈和出栈时都更新这个变量。问题是出栈的时候，如果最小的元素出栈了，如何更新min变量？ 1无解答 题目解析 既然是最小值，就不会经常变动，只有在更小的元素加入时，才会改变。一种解法是在Stack类里添加一个int型的minValue。当minValue出栈时，我们会搜索整个栈，找出新的最小值。可惜，这不符合入栈和出栈操作时间为O(1)的要求。 这就导出了我们的第二种解法。只要记下每种状态的最小值，获取最小值就是小菜一碟。实现方式很简单，每个节点记录当前最小值即可。这么一来，要找到min，直接查看栈顶元素就能得到最小值。 当一个元素入栈时，该元素会记下当前最小值，将min记录在自身数据结构的min成员中。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Node &#123; public Node next; public int value; public int subMin;&#125;public class MyStack&#123; public Node head; public int size; public int min; public int Size()&#123; return this.size; &#125; public void Push(Node node)&#123; if(this.Size() &#x3D;&#x3D; 0)&#123; head &#x3D; node; node.subMin &#x3D; node.value; &#125; else&#123; if(node.value &lt; head.subMin)&#123; node.subMin &#x3D; node.value; &#125; else&#123; node.subMin &#x3D; head.subMin; &#125; node.next &#x3D; head; head &#x3D; node; &#125; &#125; public int Pop()&#123; if(this.Size() &#x3D;&#x3D; 0)&#123; throw new Exception(); &#125; else&#123; int temp &#x3D; head.value; head &#x3D; head.next; return temp; &#125; &#125; public int Min()&#123; return head.subMin; &#125;&#125; &amp;emsp但是，这种做法有个缺点：当栈很大时，每个元素都要记录min，就会浪费大量空间。还有没有更好的做法？利用其他的栈来记录这些min，我们也许可以比之前做得更好一些。 为什么这么做可以节省空间？假设有个很大的栈，而第一个元素刚好是最小值。对于第一种解法，我们需要记录n个整数，其中n为栈的大小。不过，对于第二种解法，我们只需存储几项数据：第二个栈（只有一个元素）以及栈本身数据结构的若干成员。 12345678910111213141516171819202122232425public class StackWithMin : Stack &#123; Stack s2; public StackWithMin()&#123; s2 &#x3D; new Stack(); &#125; public void push(int value)&#123; if(value &lt;&#x3D; Min())&#123; s2.Push(value); &#125; base.Push(value); &#125; public new int Pop()&#123; int value &#x3D; base.Pop(); if(value &#x3D;&#x3D; Min())&#123; s2.Pop(); &#125; return value; &#125; public new int Min()&#123; if(s2.isEmpty())&#123; return Int32.MaxValue; &#125; return s2.head; &#125;&#125; 反思 利用额外的空间存储数据保证时间复杂度较小，要更深入理解空间换时间的策略。 提示：#27，#59，#78 -注意最小的元素不会经常变化。它只在添加更小的元素或最小的元素被弹出时才发生变化。 -如果保持追踪每个栈节点的额外数据会怎么样？什么样的数据可能更容易解决这个问题呢？ -考虑让每个节点知道它“子栈”的最小值（包括它下面的所有元素，以及它本身）。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"http://ssssshinji.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"}]},{"title":"问题精析：光线追踪发展史2","slug":"问题精析：光线追踪发展史2","date":"2020-07-21T15:50:10.000Z","updated":"2020-07-21T16:13:37.503Z","comments":false,"path":"2020/07/21/问题精析：光线追踪发展史2/","link":"2020/07/21/问题精析：光线追踪发展史2","permalink":"http://ssssshinji.github.io/2020/07/21/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%8F%91%E5%B1%95%E5%8F%B22/","excerpt":"","text":"Whitted RayTrace 1980年，Whitted ,Kay和Greenberg 提出了使用递归的光线追踪来描绘准确的折射和反射。 光线投射渲染的进化发生在1979年，当时Turner Whitted通过引入反射，折射和阴影来延长光线投射过程从而形成自身的Whitted光线追踪。 在当时它得到的那张512x512的渲染图耗时74分钟，而今天则只需要几秒钟就可以完成。 大致上，Whitted RayTrace其主要把光线分为四种 1.视角光线，和之前的一样，没什么好说的。 2.反射光线。在表面沿镜面反射方向继续照射。反射的颜色由反射光线与场景中的对象的交点决定。 3.折射光线，其创建与反射光线类似，只是它的方向是进入对象并最终可以退出对象。 4.阴影光线，是通过创建从交点到所有灯光的阴影光线来计算的。如果阴影光线在到达灯光之前与某个对象相交，则该交点将从该特定灯光中阴影显示。 Whitted 光线追踪主要解决了场景中没有间接光的问题，但是它解决的也相当的一般，因为它所有的间接光都只来源于完美的镜面反射或者是折射，这种材质显然在现实世界中并不常见，对于大多数的间接光基本无法模拟，这也是由于它对每一个EyeRay 的交点只发出一条的Reflected ray和Refracted ray。这个问题将在分布式光线追踪中有所改善。 光线追踪的类型 前向光线追踪 Forward Ray Tracing:前向光线追踪遵循光子从光源到物体。虽然前向光线可以最准确地确定每个物体的颜色，但效率非常低。这是因为来自光源的许多光线永远不会通过视平面并进入眼睛。追踪来自光源的每条光线意味着许多光线将被浪费掉，因为它们从未对从眼睛看.（这里的前向后向可能每个人理解不同而相反，这里指的是Light Ray Tracing） 向后光线追踪 Backward Ray Tracing:为了使光线追踪更有效，引入了后向光线追踪方法。在后向光线中，在眼睛处产生眼睛光线; 它通过视平面并进入世界。射线击中的第一个物体是从视平面的那个点可见的物体。 后向光线的缺点是它假设只有通过视平面并进入眼睛的光线对场景的最终图像有贡献。在某些情况下，这种假设是有缺陷的。例如，如果一个透镜被固定在桌子顶部的一个距离处，并且被正上方的光源照亮，那么在透镜下面会有一个具有大光浓度的焦点。如果反向光线追踪试图重新创建此图像，则会计算错误，因为向后发射光线只会确认光线通过透镜；反向光线无法识别通过透镜的正向光线弯曲。因此，如果只进行反向光线追踪，透镜下方将只有一个均匀的光斑，就像透镜是一块普通的玻璃。 如上所述，有效且最容易实现性能优化的一种方法是从眼睛向后发射光线，而不是从光源光发射线。通过这种方式，不会浪费计算能力来从未击中模型或相机的光线。 混合光线追踪:由于前向光线追踪和后向光线追踪都有其缺点，最近的研究试图开发出会影响速度和精度的混合解决方案。在这些混合解决方案中，仅执行某些级别的前向射线。算法记录数据，然后继续执行后向光线追踪。场景的最终着色将后向光线和前向光线计算都考虑在内。 Veach（1995）发明出了后向光线追踪+前向光线追踪+连接线（Bidirectional Path Tracing）的混合方法，这在后面会讲解。综上，而我们的whitted光线追踪一般而言都时使用的向后渲染的方式来进行的（从眼睛发射光线）。 参考资料 1. 光线追踪 2. [《Real-Time Rendering 3rd》 提炼总结]","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：光线追踪发展史","slug":"问题精析：光线追踪发展史","date":"2020-07-21T08:47:13.000Z","updated":"2020-07-21T15:52:49.282Z","comments":false,"path":"2020/07/21/问题精析：光线追踪发展史/","link":"2020/07/21/问题精析：光线追踪发展史","permalink":"http://ssssshinji.github.io/2020/07/21/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA%E5%8F%91%E5%B1%95%E5%8F%B2/","excerpt":"","text":"Ray Casting. Ray Casting.1968年，Arthur Appel。 第一个用于渲染的光线投射算法最初由Arthur Appel在1968年引入。光线投射通过从观察点对每一个像素发射一条光线并找到在世界场景中阻挡光线路径的最近物体来渲染场景，raycasting只有两种射线，第一种是眼睛发射的eye射线，来寻找场景中的交点，另一个是从交点发到灯光的阴影射线，看自身是否是处于阴影当中。 与传统扫描线渲染算法相比，光线投射的一个显着优点是能够处理不平整的表面和固体。 电子世界争霸战（1982年电影Tron Series）的大部分动画都是使用光线投射技术渲染的。 早年间光栅化技术还未流行时，也会用于游戏当中。最著名的一款光线投射的游戏是Wolfenstein 3D。接下来将介绍不论在光线追踪还是光线投射算法中都通用的公共部分，避免之后的内容太过的庞杂。 光线投射基本算法 123Render() for each pixel x,y color(pixel) &#x3D; trace(ray_through_pixel(x,y)) 首先做的就是创建光线，得到每一个点的光线数据结构，之后开始Trace，这里使用Trace这个函数名是为了和后面统一。是指在场景中追踪这个光线。 1234Trace() object_point &#x3D; Closest_intersection(ray) if object_point return Shade(object_point,ray) else return Background_Color 我们在场景中寻找光线与场景中的物体是否有交点，并返回距离我们最近的那一个object的信息，如果找到，我们进行着色如果没找到我们返回设定的背景颜色。 1234Closest_intersection(ray) for each surface in scene calc_intersection(ray, surface) return the closest point of intersection to viewer 在光线投射的Closest_intersection中，我们并不需要额外的返回其他的复杂信息。 12Shade(point, ray) to calculate contributions of each light source 光线的表示和求交问题 不论对于哪种的光线渲染算法，第一步都是进行从相机进行光线投射，其最终的目的就是找到屏幕中的每一个像素对应的光线的方向。 在这里，对于局部、世界、相机空间的转换关系是和光栅化渲染中的空间转换的做法基本类似，所以在这里就不进行赘述。 大多数情况下，我们使用\\(p(t) = e + t(s - e)\\)的方法来进行光线的表示，e是我们设定的相机观察点，而s是画布上的点，通常我们渲染之前预先设定的长宽，然后我们通过参数t来表示光线的长度。 1.当t为0，表示原点 2.当t为正数代表指向屏幕 3.当t为负数代表在原点后面 4.如果t1&lt; t2,代表t1离我们更近 参考资料 1. 光线追踪 2. [《Real-Time Rendering 3rd》 提炼总结]","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题7：旋转矩阵","slug":"问题7：旋转矩阵","date":"2020-07-21T06:30:43.000Z","updated":"2020-07-21T08:36:36.381Z","comments":false,"path":"2020/07/21/问题7：旋转矩阵/","link":"2020/07/21/问题7：旋转矩阵","permalink":"http://ssssshinji.github.io/2020/07/21/%E9%97%AE%E9%A2%987%EF%BC%9A%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5/","excerpt":"","text":"题目描述 给定一幅由N×N矩阵表示的图像，其中每个像素的大小为4字节，编写一种方法，将图像旋转90度。不占用额外内存空间能否做到？ 个人思路 将矩阵中的所有元素ai,j和相应的aj,i对调即可，这样子要使用至少一个临时变量做额外空间。要做到不使用额外空间的话，可以尝试矩阵读入的顺序，先读列再读行。可以做到不适用额外空间。**不对！**转置矩阵等于是翻转之后旋转了90度，不是直接旋转了90度。旋转90度需要的是环状旋转。 个人解答 12345678910111213141516171819202122static void RotateMatrix(int[][] matrix)&#123; int rowStart &#x3D; 0; int colStart &#x3D; matrix.Length - 1; int width &#x3D; colStart - rowStart; &#x2F;&#x2F; int ColStart &#x3D; 0; &#x2F;&#x2F; int colEnd &#x3D; matrix.Length - 1; while(width &gt; 0)&#123; for(int i &#x3D; 0; i &lt; width; i++)&#123; int temp &#x3D; matrix[rowStart + i][colStart]; &#x2F;&#x2F;上移右 matrix[rowStart + i][colStart] &#x3D; matrix[rowStart][rowStart + i]; &#x2F;&#x2F;左移上 matrix[rowStart][rowStart + i] &#x3D; matrix[colStart-i][rowStart]; &#x2F;&#x2F;下移左 matrix[colStart-i][rowStart] &#x3D; matrix[colStart][colStart - i]; &#x2F;&#x2F;左移上 matrix[colStart][colStart - i] &#x3D; temp; &#125; rowStart +&#x3D; 1; colStart -&#x3D; 1; width -&#x3D; 2; &#125; 复杂度分析 O(n^2)。因为需要访问n^2个元素。 题目解析 要将矩阵旋转90度，最简单的做法就是一层一层进行旋转。对每一层执行环状旋转（circular rotation）：将上边移到右边，右边移到下边，下边移到左边，左边移到上边。 那么，该如何交换这4条边？一种做法是把上面复制到一个数组中，然后将左边移到上边，下边移到左边，等等。这需要占用O(N)的内存空间，实际上没有必要。 更好的做法是按索引一个一个进行交换，具体做法如下。 123456for i &#x3D; 0 to n temp &#x3D; top[i]; top[i] &#x3D; left[i] left[i] &#x3D; bottom[i] bottom[i] &#x3D; temp; right[i] &#x3D; temp; 从最外面一层开始逐渐向里，在每一层上执行上述交换。另外，也可以从内层开始，逐层向外。 标准解答 1234567891011121314151617&#x2F;&#x2F;和我的解答基本相同，写的更漂亮 static string CompressBad(string s)&#123; if(s.Length &#x3D;&#x3D; 1)&#123; return s; &#125; StringBuilder sb &#x3D; new StringBuilder(10); int count &#x3D; 0; for(int i &#x3D; 0; i &lt; s.Length; i++)&#123; count++; if(i + 1 &gt;&#x3D; s.Length || s[i+1] !&#x3D; s[i])&#123; sb.Append(s[i]); sb.Append(count); count &#x3D; 0; &#125; &#125; return sb.ToString().Length &gt; s.Length ? s : sb.ToString();&#125; 反思 花了一个多小时考虑细节写出来的代码，感觉稳的一批。不过标准答案还是更加漂亮。而且又忘了边界检查。 提示：#51，#100 -尝试逐层思考。你能旋转某个特定图层吗？ -旋转一个特定的层只意味着在4个数组中交换值。如果要求你在2个数组中交换值，你能做到吗？你能把它扩展到4个数组吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：Blooming","slug":"问题精析：Blooming","date":"2020-07-19T12:40:25.000Z","updated":"2020-07-22T18:27:41.164Z","comments":false,"path":"2020/07/19/问题精析：Blooming/","link":"2020/07/19/问题精析：Blooming","permalink":"http://ssssshinji.github.io/2020/07/19/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9ABlooming/","excerpt":"","text":"意义 这个问题的提出简单来说是为了解决这样的问题：例如有一张在阳光下的白纸，白纸在监视器上显示出是出白色，而前方的太阳也是纯白色的，所以基本上白纸和太阳就是一样的了，给太阳加一个光晕，这样太阳看起来似乎就比白纸更亮了！ 重点概念 Bloom和HDR结合使用效果很好。常见的一个误解是HDR和泛光是一样的，很多人认为两种技术是可以互换的。但是它们是两种不同的技术，用于各自不同的目的上。可以使用默认的8位精确度的帧缓冲，也可以在不使用泛光效果的时候，使用HDR。只不过在有了HDR之后再实现泛光就更简单了。 步骤 1.对物体进行普通着色，并使用MRT（Multiple Render Targets，多渲染目标）渲染到一个帧缓冲内的两个颜色缓冲中。我们先正常计算光照，将其传递给第一个像素着色器的输出变量FragColor。然后我们使用当前储存在FragColor的东西来决定它的亮度是否超过了一定阈限。我们通过恰当地将其转为灰度的方式计算一个fragment的亮度，如果它超过了一定阈限，我们就把颜色输出到第二个颜色缓冲，那里保存着所有亮部，暂称BrightColor。 2.还需要创建一个帧缓冲（也需要右两个颜色缓冲），使用两步高斯模糊来对BrightColor进行处理。 3.将FragColor和处理过的BrightColor进行合并。 各步骤关键代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&#x2F;&#x2F;第一步片元着色器&#x2F;&#x2F;基本光照，然后写入到两个缓冲#version 330 corelayout (location &#x3D; 0) out vec4 FragColor;layout (location &#x3D; 1) out vec4 BrightColor;in VS_OUT &#123; vec3 FragPos; vec3 Normal; vec2 TexCoords;&#125; fs_in;struct Light &#123; vec3 Position; vec3 Color;&#125;;uniform Light lights[4];uniform sampler2D diffuseTexture;uniform vec3 viewPos;void main()&#123; vec3 color &#x3D; texture(diffuseTexture, fs_in.TexCoords).rgb; vec3 normal &#x3D; normalize(fs_in.Normal); &#x2F;&#x2F; ambient vec3 ambient &#x3D; 0.0 * color; &#x2F;&#x2F; lighting vec3 lighting &#x3D; vec3(0.0); vec3 viewDir &#x3D; normalize(viewPos - fs_in.FragPos); for(int i &#x3D; 0; i &lt; 4; i++) &#123; &#x2F;&#x2F; diffuse vec3 lightDir &#x3D; normalize(lights[i].Position - fs_in.FragPos); float diff &#x3D; max(dot(lightDir, normal), 0.0); vec3 result &#x3D; lights[i].Color * diff * color; &#x2F;&#x2F; attenuation (use quadratic as we have gamma correction) float distance &#x3D; length(fs_in.FragPos - lights[i].Position); result *&#x3D; 1.0 &#x2F; (distance * distance); lighting +&#x3D; result; &#125; vec3 result &#x3D; ambient + lighting; &#x2F;&#x2F; check whether result is higher than some threshold, if so, output as bloom threshold color float brightness &#x3D; dot(result, vec3(0.2126, 0.7152, 0.0722)); if(brightness &gt; 1.0) BrightColor &#x3D; vec4(result, 1.0); else BrightColor &#x3D; vec4(0.0, 0.0, 0.0, 1.0); FragColor &#x3D; vec4(result, 1.0);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;&#x2F;第二步片元着色器#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D image;uniform bool horizontal;uniform float weight[5] &#x3D; float[] (0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);void main()&#123; vec2 tex_offset &#x3D; 1.0 &#x2F; textureSize(image, 0); &#x2F;&#x2F; gets size of single texel vec3 result &#x3D; texture(image, TexCoords).rgb * weight[0]; if(horizontal) &#123; for(int i &#x3D; 1; i &lt; 5; ++i) &#123; result +&#x3D; texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; result +&#x3D; texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i]; &#125; &#125; else &#123; for(int i &#x3D; 1; i &lt; 5; ++i) &#123; result +&#x3D; texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i]; result +&#x3D; texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i]; &#125; &#125; FragColor &#x3D; vec4(result, 1.0);&#125;&#x2F;&#x2F;第二步逻辑处理第一次传入BrightColor，之后纵横交替进行模糊处理 bool horizontal &#x3D; true, first_iteration &#x3D; true; unsigned int amount &#x3D; 10; shaderBlur.Use(); for (unsigned int i &#x3D; 0; i &lt; amount; i++) &#123; glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]); shaderBlur.SetInt(&quot;horizontal&quot;, horizontal); glBindTexture(GL_TEXTURE_2D, first_iteration ? colorBuffers[1] : pingpongColorbuffers[!horizontal]); &#x2F;&#x2F; bind texture of other framebuffer (or scene if first iteration) renderQuad(); horizontal &#x3D; !horizontal; if (first_iteration) first_iteration &#x3D; false; &#125; glBindFramebuffer(GL_FRAMEBUFFER, 0); 123456789101112131415161718192021222324&#x2F;&#x2F;第三步片元着色器#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D scene;uniform sampler2D bloomBlur;uniform bool bloom;uniform float exposure;void main()&#123; const float gamma &#x3D; 2.2; vec3 hdrColor &#x3D; texture(scene, TexCoords).rgb; vec3 bloomColor &#x3D; texture(bloomBlur, TexCoords).rgb; if(bloom) hdrColor +&#x3D; bloomColor; &#x2F;&#x2F; additive blending &#x2F;&#x2F; tone mapping 这里是之前提到过的粗暴派，仅利用exp曲线 vec3 result &#x3D; vec3(1.0) - exp(-hdrColor * exposure); &#x2F;&#x2F; also gamma correct while we&#39;re at it result &#x3D; pow(result, vec3(1.0 &#x2F; gamma)); FragColor &#x3D; vec4(result, 1.0);&#125; 参考资料 1. 泛光","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：HDR和ToneMapping","slug":"问题精析：HDR和ToneMapping","date":"2020-07-19T09:09:11.000Z","updated":"2020-07-19T10:18:35.868Z","comments":false,"path":"2020/07/19/问题精析：HDR和ToneMapping/","link":"2020/07/19/问题精析：HDR和ToneMapping","permalink":"http://ssssshinji.github.io/2020/07/19/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AHDR%E5%92%8CToneMapping/","excerpt":"","text":"HDR背景及概念 一般来说，当存储在帧缓冲(Framebuffer)中时，亮度和颜色的值是默认被限制在0.0到1.0之间的。这个看起来无辜的语句使我们一直将亮度与颜色的值设置在这个范围内，尝试着与场景契合。这样是能够运行的，也能给出还不错的效果。但是如果我们遇上了一个特定的区域，其中有多个亮光源使这些数值总和超过了1.0，又会发生什么呢？答案是这些片段中超过1.0的亮度或者颜色值会被约束在1.0，从而导致场景混成一片，难以分辨： 这是由于大量片段的颜色值都非常接近1.0，在很大一个区域内每一个亮的片段都有相同的白色。这损失了很多的细节，使场景看起来非常假。 解决这个问题的一个方案是减小光源的强度从而保证场景内没有一个片段亮于1.0。然而这并不是一个好的方案，因为你需要使用不切实际的光照参数。一个更好的方案是让颜色暂时超过1.0，然后将其转换至0.0到1.0的区间内，从而防止损失细节。 显示器被限制为只能显示值为0.0到1.0间的颜色，但是在光照方程中却没有这个限制。通过使片段的颜色超过1.0，我们有了一个更大的颜色范围，这也被称作HDR(High Dynamic Range, 高动态范围)。有了HDR，亮的东西可以变得非常亮，暗的东西可以变得非常暗，而且充满细节。 HDR原本只是被运用在摄影上，摄影师对同一个场景采取不同曝光拍多张照片，捕捉大范围的色彩值。这些图片被合成为HDR图片，从而综合不同的曝光等级使得大范围的细节可见。看下面这个例子，左边这张图片在被光照亮的区域充满细节，但是在黑暗的区域就什么都看不见了；但是右边这张图的高曝光却可以让之前看不出来的黑暗区域显现出来。 这与我们眼睛工作的原理非常相似，也是HDR渲染的基础。当光线很弱的啥时候，人眼会自动调整从而使过暗和过亮的部分变得更清晰，就像人眼有一个能自动根据场景亮度调整的自动曝光滑块。 HDR渲染和其很相似，我们允许用更大范围的颜色值渲染从而获取大范围的黑暗与明亮的场景细节，最后将所有HDR值转换成在[0.0, 1.0]范围的LDR(Low Dynamic Range,低动态范围)。转换HDR值到LDR值得过程叫做色调映射(Tone Mapping)，现在现存有很多的色调映射算法，这些算法致力于在转换过程中保留尽可能多的HDR细节。这些色调映射算法经常会包含一个选择性倾向黑暗或者明亮区域的参数。 在实时渲染中，HDR不仅允许我们超过LDR的范围[0.0, 1.0]与保留更多的细节，同时还让我们能够根据光源的真实强度指定它的强度。比如太阳有比闪光灯之类的东西更高的强度，那么我们为什么不这样子设置呢?(比如说设置一个10.0的漫亮度) 这允许我们用更现实的光照参数恰当地配置一个场景的光照，而这在LDR渲染中是不能实现的，因为他们会被上限约束在1.0。 因为显示器只能显示在0.0到1.0范围之内的颜色，我们肯定要做一些转换从而使得当前的HDR颜色值符合显示器的范围。简单地取平均值重新转换这些颜色值并不能很好的解决这个问题，因为明亮的地方会显得更加显著。我们能做的是用一个不同的方程与/或曲线来转换这些HDR值到LDR值，从而给我们对于场景的亮度完全掌控，这就是之前说的色调变换，也是HDR渲染的最终步骤。 浮点帧缓冲 当一个帧缓冲的颜色缓冲的内部格式被设定成了GL_RGB16F, GL_RGBA16F, GL_RGB32F 或者GL_RGBA32F时，这些帧缓冲被叫做浮点帧缓冲(Floating Point Framebuffer)，浮点帧缓冲可以存储超过0.0到1.0范围的浮点值，所以非常适合HDR渲染。 想要创建一个浮点帧缓冲，我们只需要改变颜色缓冲的内部格式参数就行了（注意GL_FLOAT参数)： 12glBindTexture(GL_TEXTURE_2D, colorBuffer);glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL); 默认的帧缓冲默认一个颜色分量只占用8位(bits)。当使用一个使用32位每颜色分量的浮点帧缓冲时(使用GL_RGB32F 或者GL_RGBA32F)，我们需要四倍的内存来存储这些颜色。所以除非你需要一个非常高的精确度，32位不是必须的，使用GLRGB16F就足够了。 当光的强度值大于1.0时，一大块区域都是白色的。因为默认的帧缓冲中，所有片段着色器的输出值被约束在0.0到1.0间，超过1.0的地方损失了所有细节。因为我们直接转换HDR值到LDR值，这就像我们根本就没有应用HDR一样。为了修复这个问题我们需要做的是无损转化所有浮点颜色值回0.0-1.0范围中。我们需要应用到色调映射。 色调映射(Tone Mapping) 色调映射(Tone Mapping)是一个损失很小的转换浮点颜色值至我们所需的LDR[0.0, 1.0]范围内的过程，通常会伴有特定的风格的色平衡(Stylistic Color Balance)。 经验派 Reinhard tone mapping,伪代码如下 123456float3 ReinhardToneMapping(float3 color, float adapted_lum) &#123; const float MIDDLE_GREY &#x3D; 1; color *&#x3D; MIDDLE_GREY &#x2F; adapted_lum; return color &#x2F; (1.0f + color);&#125; 这种tone mapping的方法更多地来自于经验，没什么原理在后面。所以就姑且称它为经验派吧。它的优点是简单直接，把亮的变暗，暗的变量。这样暗处和亮处细节就都出来了。但缺点也很明显，就是灰暗。个个颜色都朝着灰色的方向被压缩了，画面像蒙了一层纱。 粗暴派 到了2007年，孤岛危机（Crysis）的CryEngine 2，为了克服Reinhard灰暗的缺点，开始用了另一个tone mapping的方法。前面提到了tone mapping就是个S曲线，那么既然你要S曲线，我就搞出一个S曲线。这个方法更简单，只要一行，而且没有magic number。用一个exp来模拟S曲线。 1234float3 CEToneMapping(float3 color, float adapted_lum) &#123; return 1 - exp(-adapted_lum * color);&#125; CE的方法在于快速，并且视觉效果比Reinhard。但是这个方法纯粹就是凑一个函数，没人知道应该如何改进。属于粗暴地合成。 拟合派 到了2010年，Uncharted 2公开了它的tone mapping方法，称为Filmic tone mapping。当年我也写过一篇博客讲KlayGE切换到Filmic tone mapping的事情。这个方法的本质是把原图和让艺术家用专业照相软件模拟胶片的感觉，人肉tone mapping后的结果去做曲线拟合，得到一个高次曲线的表达式。这样的表达式应用到渲染结果后，就能在很大程度上自动接近人工调整的结果。 1234567891011121314151617float3 F(float3 x)&#123; const float A &#x3D; 0.22f; const float B &#x3D; 0.30f; const float C &#x3D; 0.10f; const float D &#x3D; 0.20f; const float E &#x3D; 0.01f; const float F &#x3D; 0.30f; return ((x * (A * x + C * B) + D * E) &#x2F; (x * (A * x + B) + D * F)) - E &#x2F; F;&#125;float3 Uncharted2ToneMapping(float3 color, float adapted_lum)&#123; const float WHITE &#x3D; 11.2f; return F(1.6f * adapted_lum * color) &#x2F; F(WHITE);&#125; 那些ABCDEF都是多项式的系数，而WHITE是个magic number，表示白色的位置。这个方法开启了tone mapping的新路径，让人们知道了曲线拟合的好处。并且，其他颜色空间的变换，比如gamma矫正，也可以一起合并到这个曲线里来，一次搞定，不会增加额外开销。缺点就是运算量有点大，两个多项式的计算，并且相除。因为Filmic tone mapping的优异表现，大部分游戏都切换到了这个方法。包括CE自己，也在某个时候完成了切换。 最强派 在大家以为Filmic tone mapping会统治很长时间的时候，江湖中来了一位异域高手。他认为，你们这帮搞游戏/实时图形的，都是渣渣。让我们电影业来教你们什么叫tone mapping。这位高手叫美国电影艺术与科学学会，就是颁布奥斯卡奖的那个机构。不要以为他们只是个评奖的单位，美国电影艺术与科学学会的第一宗旨就是提高电影艺术与科学的质量。 他们发明的东西叫Academy Color Encoding System（ACES），是一套颜色编码系统，或者说是一个新的颜色空间。它是一个通用的数据交换格式，一方面可以不同的输入设备转成ACES，另一方面可以把ACES在不同的显示设备上正确显示。不管你是LDR，还是HDR，都可以在ACES里表达出来。这就直接解决了VDR的问题，不同设备间都可以互通数据。 然而对于实时渲染来说，没必要用全套ACES。因为第一，没有什么“输入设备”。渲染出来的HDR图像就是个线性的数据，所以直接就在ACES空间中。而输出的时候需要一次tone mapping，转到LDR或另一个HDR。也就是说，我们只要ACES里的非常小的一条路径，而不是纷繁复杂的整套体系。 1234567891011float3 ACESToneMapping(float3 color, float adapted_lum)&#123; const float A &#x3D; 2.51f; const float B &#x3D; 0.03f; const float C &#x3D; 2.43f; const float D &#x3D; 0.59f; const float E &#x3D; 0.14f; color *&#x3D; adapted_lum; return (color * (A * color + B)) &#x2F; (color * (C * color + D) + E);&#125; 看着很像Uncharted 2的做法吧，都是多项式拟合。但是式子比Uncharted的简单，并不需要算两个多项式并相除，只要算一个，一次搞定。它的曲线是这样的。S感很浓，并且比Uncharted的更向小的方向移，即便很小的数值和接近1的数值也有梯度。这样能很好地保留暗处和亮处的细节。 更好的地方是，按照前面说的，ACES为的是解决所有设备之间的颜色空间转换问题。所以这个tone mapper不但可以用于HDR到LDR的转换，还可以用于从一个HDR转到另一个HDR。也就是从根本上解决了VDR的问题。这个函数的输出是线性空间的，所以要接到LDR的设备，只要做一次sRGB校正。要接到HDR10的设备，只要做一次Rec 2020颜色矩阵乘法。Tone mapping部分是通用的，这也是比之前几个算法都好的地方。 参考资料 1. HDR 2. Tone mapping进化论","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题6：字符串压缩","slug":"问题6：字符串压缩","date":"2020-07-18T10:38:05.000Z","updated":"2020-07-18T17:47:25.989Z","comments":false,"path":"2020/07/18/问题6：字符串压缩/","link":"2020/07/18/问题6：字符串压缩","permalink":"http://ssssshinji.github.io/2020/07/18/%E9%97%AE%E9%A2%986%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9/","excerpt":"","text":"题目描述 利用字符重复出现的次数，编写一种方法，实现基本的字符串压缩功能。比如，字符串aabcccccaaa会变为a2b1c5a3。若“压缩”后的字符串没有变短，则返回原先的字符串。你可以假设字符串中只包含大小写英文字母（a至z）。 个人思路 涉及字符串拼接，利用stringbuilder，别忘了引用System.Text,记得处理边界情况，尤其是最后一位字符。 个人解答 123456789101112131415161718192021222324252627static string CompressBad(string s)&#123; if(s.Length &#x3D;&#x3D; 1)&#123; return s; &#125; StringBuilder sb &#x3D; new StringBuilder(10); char before &#x3D; s[0]; int count &#x3D; 1; for(int i &#x3D; 1; i &lt; s.Length; i++)&#123; if(s[i] &#x3D;&#x3D; before)&#123; count ++; if(i &#x3D;&#x3D; s.Length - 1)&#123; sb.Append(before); sb.Append(count); &#125; &#125; else &#123; sb.Append(before); sb.Append(count); count &#x3D; 1; if(i &#x3D;&#x3D; s.Length - 1)&#123; sb.Append(s[i]); sb.Append(1); &#125; &#125; &#125; return sb.ToString().Length &gt; s.Length ? s : sb.ToString();&#125; 题目解析 乍一看，编写这个方法似乎易如反掌，实则有点儿复杂。我们会迭代访问字符串，将字符复制至新字符串，并数出重复字符。在遍历过程中的每一步，只需检查当前字符与下一个字符是否一致。如果不一致，则将压缩后的版本写入到结果中。 但是直接使用字符串拼接的话，时间复杂度为O(n2)。 可以使用StringBuilder优化部分性能。 标准解答 1234567891011121314151617&#x2F;&#x2F;和我的解答基本相同，写的更漂亮 static string CompressBad(string s)&#123; if(s.Length &#x3D;&#x3D; 1)&#123; return s; &#125; StringBuilder sb &#x3D; new StringBuilder(10); int count &#x3D; 0; for(int i &#x3D; 0; i &lt; s.Length; i++)&#123; count++; if(i + 1 &gt;&#x3D; s.Length || s[i+1] !&#x3D; s[i])&#123; sb.Append(s[i]); sb.Append(count); count &#x3D; 0; &#125; &#125; return sb.ToString().Length &gt; s.Length ? s : sb.ToString();&#125; 反思 写出不优美的代码一定要看看还能不能再优化，有时候就是一个下标，一个if的问题。 提示：#92，#110 -先做容易的事。压缩字符串，然后再比较长度。 -注意不要把字符串重复连接在一起。这会非常低效。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：PBR实现ByOpenGL（带纹理）","slug":"问题精析：PBR实现ByOpenGL（带纹理）","date":"2020-07-17T18:08:29.000Z","updated":"2020-07-17T18:24:23.067Z","comments":false,"path":"2020/07/18/问题精析：PBR实现ByOpenGL（带纹理）/","link":"2020/07/18/问题精析：PBR实现ByOpenGL（带纹理）","permalink":"http://ssssshinji.github.io/2020/07/18/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR%E5%AE%9E%E7%8E%B0ByOpenGL%EF%BC%88%E5%B8%A6%E7%BA%B9%E7%90%86%EF%BC%89/","excerpt":"","text":"片元着色器代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#version 330 coreout vec4 FragColor;in vec2 TexCoords;in vec3 WorldPos;in vec3 Normal;&#x2F;&#x2F;光源相关uniform vec3 lightPositions[4];uniform vec3 lightColors[4];&#x2F;&#x2F;摄像机位置uniform vec3 camPos;&#x2F;&#x2F;材质参数uniform sampler2D albedoMap;uniform sampler2D normalMap;uniform sampler2D metallicMap;uniform sampler2D roughnessMap;uniform sampler2D aoMap;const float PI &#x3D; 3.14159265359;float DistributionGGX(vec3 N, vec3 H, float roughness);float GeometrySchlickGGX(float NdotV, float roughness);float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);vec3 fresnelSchlick(float cosTheta, vec3 F0);vec3 getNormalFromMap()&#123; vec3 tangentNormal &#x3D; texture(normalMap, TexCoords).xyz * 2.0 - 1.0; vec3 Q1 &#x3D; dFdx(WorldPos); vec3 Q2 &#x3D; dFdy(WorldPos); vec2 st1 &#x3D; dFdx(TexCoords); vec2 st2 &#x3D; dFdy(TexCoords); vec3 N &#x3D; normalize(Normal); vec3 T &#x3D; normalize(Q1*st2.t - Q2*st1.t); vec3 B &#x3D; -normalize(cross(N, T)); mat3 TBN &#x3D; mat3(T, B, N); return normalize(TBN * tangentNormal);&#125;void main()&#123; vec3 albedo &#x3D; pow(texture(albedoMap, TexCoords).rgb, vec3(2.2)); float metallic &#x3D; texture(metallicMap, TexCoords).r; float roughness &#x3D; texture(roughnessMap, TexCoords).r; float ao &#x3D; texture(aoMap, TexCoords).r; vec3 N &#x3D; getNormalFromMap(); vec3 V &#x3D; normalize(camPos - WorldPos); vec3 Lo &#x3D; vec3(0.0); vec3 F0 &#x3D; vec3(0.04); F0 &#x3D; mix(F0,albedo,metallic); for(int i &#x3D; 0; i &lt; 4; i++)&#123; vec3 L &#x3D; normalize(lightPositions[i] - WorldPos); vec3 H &#x3D; normalize(V + L); float distance &#x3D; length(lightPositions[i] - WorldPos); float attenuation &#x3D; 1.0&#x2F;(distance * distance); vec3 radiance &#x3D; lightColors[i] * attenuation; &#x2F;&#x2F; cook-torrance brdf float NDF &#x3D; DistributionGGX(N, H, roughness); float G &#x3D; GeometrySmith(N, V, L, roughness); vec3 F &#x3D; fresnelSchlick(max(dot(H, V), 0.0), F0); vec3 kS &#x3D; F; vec3 kD &#x3D; vec3(1.0) - kS; kD *&#x3D; 1.0 - metallic; vec3 nominator &#x3D; NDF * G * F; float denominator &#x3D; 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; vec3 specular &#x3D; nominator &#x2F; denominator; &#x2F;&#x2F; add to outgoing radiance Lo float NdotL &#x3D; max(dot(N, L), 0.0); Lo +&#x3D; (kD * albedo &#x2F; PI + specular) * radiance * NdotL; &#125; vec3 ambient &#x3D; vec3(0.03) * albedo * ao; vec3 color &#x3D; ambient + Lo; color &#x3D; color &#x2F; (color + vec3(1.0)); color &#x3D; pow(color,vec3(1.0&#x2F;2.2)); FragColor &#x3D; vec4(color,1.0);&#125;vec3 fresnelSchlick(float cosTheta, vec3 F0)&#123; return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);&#125;float DistributionGGX(vec3 N, vec3 H, float roughness)&#123; float a &#x3D; roughness * roughness; float a2 &#x3D; a*a; float NdotH &#x3D; max(dot(N,H),0.0); float NdotH2 &#x3D; NdotH * NdotH; float nom &#x3D; a2; float denom &#x3D; (NdotH2 * (a2 - 1.0) + 1.0); denom &#x3D; PI * denom * denom; return nom &#x2F; denom;&#125;float GeometrySchlickGGX(float NdotV, float roughness)&#123; float r &#x3D; (roughness + 1.0); float k &#x3D; (r*r)&#x2F;8.0; float nom &#x3D; NdotV; float denom &#x3D; NdotV * (1 - k) + k; return nom &#x2F; denom;&#125;float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)&#123; float NdotV &#x3D; max(dot(N,V),0.0); float NdotL &#x3D; max(dot(N,L),0.0); float ggx1 &#x3D; GeometrySchlickGGX(NdotV,roughness); float ggx2 &#x3D; GeometrySchlickGGX(NdotL,roughness); return ggx1 * ggx2;&#125; 参考资料 1. 光照","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题4：分割链表","slug":"问题4：分割链表","date":"2020-07-17T05:53:51.000Z","updated":"2020-07-17T18:07:35.184Z","comments":false,"path":"2020/07/17/问题4：分割链表/","link":"2020/07/17/问题4：分割链表","permalink":"http://ssssshinji.github.io/2020/07/17/%E9%97%AE%E9%A2%984%EF%BC%9A%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目描述 编写程序以x为基准分割链表，使得所有小于x的节点排在大于或等于x的节点之前。如果链表中包含x，分割元素x只需处于“右半部分”即可，其不需要被置于左右两部分之间。（提示在页尾） 示例： 12输入：3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1 [分割节点为5]结果：3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8 个人思路 利用四个Node，分别存放前后两个链表的首尾，最后连在一起。或者同时从头尾遍历，头遍历时遇到bix大的和尾遍历时遇到比x小的交换位置。 个人解答 1无 题目解析 假如本题描述的是一个数组，对于如何移动元素则要非常谨慎。数组元素的移动通常开销很大。 但是，在链表当中，情况要简单得多。与数组中需要移动和交换元素不同的是，可以通过创建两个链表完成该操作，其中一个链表包含小于x的元素，而另一个链表包含大于或等于x的元素。 遍历链表，不断地将元素插入到before链表和after链表当中。当到达链表尾部并完成了分离操作后，将得到的两个链表合并。 对于保持其原有的顺序的元素，该方法大体称得上运行“稳定”，除了对分割链表进行了必要的移动。下面的代码实现了该方法。 标准解答 123456789101112131415161718192021222324252627282930313233343536static Node Partition(Node node,int x)&#123; Node beforeStart &#x3D; null; Node beforeEnd &#x3D; null; Node afterStart &#x3D; null; Node afterEnd &#x3D; null; while(node !&#x3D; null)&#123; Node next &#x3D; node.next; node.next &#x3D; null; if(node.data &lt; x)&#123; if(beforeStart &#x3D;&#x3D; null)&#123; beforeStart.next &#x3D; node; beforeEnd &#x3D; beforeStart; &#125; else&#123; beforeEnd.next &#x3D; node; beforeEnd &#x3D; node; &#125; &#125; else&#123; if(afterStart &#x3D;&#x3D; null)&#123; afterStart.next &#x3D; node; afterEnd &#x3D; afterStart; &#125; else&#123; afterEnd.next &#x3D; node; afterEnd &#x3D; node; &#125; &#125; node &#x3D; next; &#125; if(beforeStart &#x3D;&#x3D; null)&#123; return afterStart; &#125; beforeEnd.next &#x3D; afterStart; return beforeStart;&#125; 复杂度分析 O(n)。 使用4个变量跟踪2个链表确实麻烦，不妨将这段代码写的简短一些。 如果不介意链表中的元素是否保持“稳定”（因为面试官没有提到这个要求，你也不需要必须保证其“稳定性”），可以不断地在链表头部和尾部加入元素，以便于整理链表。 在该方法中，我们创建了一个“新”链表（借助已有节点），将大于基准点的元素加入到链表尾部，将小于基准点的元素加入到链表头部。每当加入一个元素时，就会更新头节点或者尾节点。 12345678910111213141516171819static Node Partition(Node node,int x)&#123; Node head &#x3D; node; Node tail &#x3D; node; while(node !&#x3D; null)&#123; Node next &#x3D; node.next; if(node.data &lt; x)&#123; node.next &#x3D; head; head &#x3D; node; &#125; else&#123; tail.next &#x3D; node; tail &#x3D; node; &#125; node &#x3D; next; &#125; tail.next &#x3D; null; return head;&#125; 反思 应该问清楚链表是否双向之类的细节。第二种解答方法也需要好好理解，重点是Node next = node.next;这步的位置。 提示：#3，#24 -这个问题有很多解法，其中大部分都有最优的运行时间。有些代码比其他代码更短，更干净。你可以想出不同的解法吗？ -考虑元素不必保持相同的相对顺序。我们只需要确保小于基准点的元素必须位于比基准点大的元素之前。这有助于你想出更多的解法吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"问题精析：PBR实现ByOpenGL","slug":"问题精析：PBR实现ByOpenGL","date":"2020-07-16T18:12:01.000Z","updated":"2020-07-16T18:13:37.950Z","comments":false,"path":"2020/07/17/问题精析：PBR实现ByOpenGL/","link":"2020/07/17/问题精析：PBR实现ByOpenGL","permalink":"http://ssssshinji.github.io/2020/07/17/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR%E5%AE%9E%E7%8E%B0ByOpenGL/","excerpt":"","text":"片元着色器代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#version 330 coreout vec4 FragColor;in vec2 TexCoords;in vec3 WorldPos;in vec3 Normal;&#x2F;&#x2F;光源相关uniform vec3 lightPositions[4];uniform vec3 lightColors[4];&#x2F;&#x2F;摄像机位置uniform vec3 camPos;&#x2F;&#x2F;材质参数uniform vec3 albedo;uniform float metallic;uniform float roughness;uniform float ao;const float PI &#x3D; 3.14159265359;float DistributionGGX(vec3 N, vec3 H, float roughness);float GeometrySchlickGGX(float NdotV, float roughness);float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);vec3 fresnelSchlick(float cosTheta, vec3 F0);void main()&#123; vec3 N &#x3D; normalize(Normal); vec3 V &#x3D; normalize(camPos - WorldPos); vec3 Lo &#x3D; vec3(0.0); vec3 F0 &#x3D; vec3(0.04); F0 &#x3D; mix(F0,albedo,metallic); for(int i &#x3D; 0; i &lt; 4; i++)&#123; vec3 L &#x3D; normalize(lightPositions[i] - WorldPos); vec3 H &#x3D; normalize(V + L); float distance &#x3D; length(lightPositions[i] - WorldPos); float attenuation &#x3D; 1.0&#x2F;(distance * distance); vec3 radiance &#x3D; lightColors[i] * attenuation; &#x2F;&#x2F; cook-torrance brdf float NDF &#x3D; DistributionGGX(N, H, roughness); float G &#x3D; GeometrySmith(N, V, L, roughness); vec3 F &#x3D; fresnelSchlick(max(dot(H, V), 0.0), F0); vec3 kS &#x3D; F; vec3 kD &#x3D; vec3(1.0) - kS; kD *&#x3D; 1.0 - metallic; vec3 nominator &#x3D; NDF * G * F; float denominator &#x3D; 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001; vec3 specular &#x3D; nominator &#x2F; denominator; &#x2F;&#x2F; add to outgoing radiance Lo float NdotL &#x3D; max(dot(N, L), 0.0); Lo +&#x3D; (kD * albedo &#x2F; PI + specular) * radiance * NdotL; &#125; vec3 ambient &#x3D; vec3(0.03) * albedo * ao; vec3 color &#x3D; ambient + Lo; color &#x3D; color &#x2F; (color + vec3(1.0)); color &#x3D; pow(color,vec3(1.0&#x2F;2.2)); FragColor &#x3D; vec4(color,1.0);&#125;vec3 fresnelSchlick(float cosTheta, vec3 F0)&#123; return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);&#125;float DistributionGGX(vec3 N, vec3 H, float roughness)&#123; float a &#x3D; roughness * roughness; float a2 &#x3D; a*a; float NdotH &#x3D; max(dot(N,H),0.0); float NdotH2 &#x3D; NdotH * NdotH; float nom &#x3D; a2; float denom &#x3D; (NdotH2 * (a2 - 1.0) + 1.0); denom &#x3D; PI * denom * denom; return nom &#x2F; denom;&#125;float GeometrySchlickGGX(float NdotV, float roughness)&#123; float r &#x3D; (roughness + 1.0); float k &#x3D; (r*r)&#x2F;8.0; float nom &#x3D; NdotV; float denom &#x3D; NdotV * (1 - k) + k; return nom &#x2F; denom;&#125;float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)&#123; float NdotV &#x3D; max(dot(N,V),0.0); float NdotL &#x3D; max(dot(N,L),0.0); float ggx1 &#x3D; GeometrySchlickGGX(NdotV,roughness); float ggx2 &#x3D; GeometrySchlickGGX(NdotL,roughness); return ggx1 * ggx2;&#125; 参考资料 1. 光照","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题5：合法二叉搜索树","slug":"问题5：合法二叉搜索树","date":"2020-07-16T04:39:46.000Z","updated":"2020-07-16T09:03:11.272Z","comments":false,"path":"2020/07/16/问题5：合法二叉搜索树/","link":"2020/07/16/问题5：合法二叉搜索树","permalink":"http://ssssshinji.github.io/2020/07/16/%E9%97%AE%E9%A2%985%EF%BC%9A%E5%90%88%E6%B3%95%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","excerpt":"","text":"题目描述 实现一个函数，检查一棵二叉树是否为二叉搜索树。（提示在页尾） 个人思路 保证leftChild &lt; node &lt; rightChild,不仅如此，左边的每个节点必须小于当前节点，该节点还必须小于右边的所有节点。也就是说，左子树都有最大值，右子树有最小值。 个人解答 1234567891011121314static bool IsSearchTree(Treenode node,int min, int max)&#123; if(node &#x3D;&#x3D; null)&#123; return true; &#125; else if(node.value &lt; min || node.value &gt; max)&#123; return false; &#125; else if(node.value &lt; node.left.value || node.value &gt; node.right.value)&#123; return false; &#125; else &#123; return IsSearchTree(node.left,Int32.MinValue,node.value) &amp;&amp; IsSearchTree(node.right,node.value,Int32.MaxValue); &#125;&#125; 复杂度分析 O(n)。 题目解析 此题有两种不同的解法：第一种是利用中序遍历，第二种则建立在left&lt;=current&lt;right这项特性之上。 **解法1：中序遍历：**看到此题，首先想到的可能是中序遍历，即将所有元素复制到数组中，然后检查该数组是否有序。这种解法会占用一点儿额外的内存，但大部分情况下都奏效。唯一的问题在于，它无法正确处理树中的重复值。例如，一棵树的左子节点和本身都是20，一棵树的右子节点和本身都是20，该算法无法区分这两棵树（其中一棵是无效的）。因为两者的中序遍历结果相同。不过，要是假定这棵树不得包含重复值，那么这种做法还是行之有效的。该方法的伪码大致如下。 标准解答 12345int[] array &#x3D; new int[tree.size];for（中序遍历）&#123; array[i++] &#x3D; node;&#125;比较数组中前一个和后一个的大小 注意，这里必须记录数组在逻辑上的“尾部”，用它来分配空间以存储所有元素。 仔细检查该解法，就会发现代码中的数组实无必要。除了用来比较某个元素和前一个元素，别无他用。那么，为什么不在进行比较时，直接记下最后的元素？ 下面是该算法的实现代码。 1234567891011121314Int32 last_printed &#x3D; Int32.MinValue;bool checkBST(Treenode n)&#123; if(n &#x3D;&#x3D; null)return true; &#x2F;&#x2F;对左子树递归 if(!checkBST(n.left))return false; &#x2F;&#x2F;检查当前节点 if(last_printed !&#x3D; Int32.MinValue &amp;&amp; n.data &lt;&#x3D; last_printed)&#123; return false; &#125; last_printed &#x3D; n.data; &#x2F;&#x2F;对右子树递归 if(!checkBST(n.right))return false; return true;&#125; 解法2：最小与最大法一棵什么样的树才可称为二叉搜索树？我们知道这棵树必须满足以下条件：对于每个节点，left.data&lt;=current.data&lt; right.data，但是这样还不够。更准确地说，成为二叉搜索树的条件是：所有左边的节点必须小于或等于当前节点，而当前节点必须小于所有右边的节点。 利用这一点，我们可以通过自上而下传递最小和最大值来解决这个问题。在迭代遍历整个树的过程中，我们会用逐渐变窄的范围来检查各个节点。利用这一点，我们可以通过自上而下传递最小和最大值来解决这个问题。在迭代遍历整个树的过程中，我们会用逐渐变窄的范围来检查各个节点。 1与个人思路基本相同 反思 对前序遍历的性质掌握不到位。 提示：#35，#57，#86，#113，#128 -如果使用前序遍历来遍历树，元素的顺序是正确的，这是否表明树实际上是有序的？有重复元素会发生什么？如果允许重复元素，它们必须位于特定的一边（通常是左边）。 -作为一个二叉搜索树，并不是说每个节点都满足left.value&lt;=current.value&lt; right就够了。左边的每个节点必须小于当前节点，该节点还必须小于右边的所有节点。 -如果左边的每个节点必须小于或等于当前节点，那么这就等于左边最大的节点必须小于或等于当前节点。 -相比于根据leftTree.max和rightTree.min来验证当前节点的值，我们可以翻转逻辑吗？验证左子树的节点以确保其小于current.value。 -把checkBST函数当作一个递归函数，保证每个节点在允许范围内（最小，最大）。首先，这个范围是无限的。当我们遍历左边，最小的是负无穷大，最大的是root.value。你能实现这个递归函数，并且随着遍历而适当调整这些范围吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"问题精析：PBR材质","slug":"问题精析：PBR材质","date":"2020-07-15T17:19:38.000Z","updated":"2020-07-15T17:30:12.249Z","comments":false,"path":"2020/07/16/问题精析：PBR材质/","link":"2020/07/16/问题精析：PBR材质","permalink":"http://ssssshinji.github.io/2020/07/16/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR%E6%9D%90%E8%B4%A8/","excerpt":"","text":"在了解了PBR后面的数学模型之后，说明一下美术师一般是如何编写一个我们可以直接输入PBR的平面物理属性的。PBR渲染管线所需要的每一个表面参数都可以用纹理来定义或者建模。使用纹理可以让我们逐个片段的来控制每个表面上特定的点对于光线是如何响应的：不论那个点是金属的，粗糙或者平滑，也不论表面对于不同波长的光会有如何的反应。 **反照率：**反照率(Albedo)纹理为每一个金属的纹素(Texel)（纹理像素）指定表面颜色或者基础反射率。这和我们之前使用过的漫反射纹理相当类似，不同的是所有光照信息都是由一个纹理中提取的。漫反射纹理的图像当中常常包含一些细小的阴影或者深色的裂纹，而反照率纹理中是不会有这些东西的。它应该只包含表面的颜色（或者折射吸收系数）。 **法线：**法线贴图纹理和我们之前在法线贴图教程中所使用的贴图是完全一样的。法线贴图使我们可以逐片段的指定独特的法线，来为表面制造出起伏不平的假象。 **金属度：**金属(Metallic)贴图逐个纹素的指定该纹素是不是金属质地的。根据PBR引擎设置的不同，美术师们既可以将金属度编写为灰度值又可以编写为1或0这样的二元值。 **粗糙度：**粗糙度(Roughness)贴图可以以纹素为单位指定某个表面有多粗糙。采样得来的粗糙度数值会影响一个表面的微平面统计学上的取向度。一个比较粗糙的表面会得到更宽阔更模糊的镜面反射（高光），而一个比较光滑的表面则会得到集中而清晰的镜面反射。某些PBR引擎预设采用的是对某些美术师来说更加直观的光滑度(Smoothness)贴图而非粗糙度贴图，不过这些数值在采样之时就马上用（1.0 – 光滑度）转换成了粗糙度。 **反照率：**反照率(Albedo)纹理为每一个金属的纹素(Texel)（纹理像素）指定表面颜色或者基础反射率。这和我们之前使用过的漫反射纹理相当类似，不同的是所有光照信息都是由一个纹理中提取的。漫反射纹理的图像当中常常包含一些细小的阴影或者深色的裂纹，而反照率纹理中是不会有这些东西的。它应该只包含表面的颜色（或者折射吸收系数）。 **环境光遮蔽AO：**环境光遮蔽(Ambient Occlusion)贴图或者说AO贴图为表面和周围潜在的几何图形指定了一个额外的阴影因子。比如如果我们有一个砖块表面，反照率纹理上的砖块裂缝部分应该没有任何阴影信息。然而AO贴图则会把那些光线较难逃逸出来的暗色边缘指定出来。在光照的结尾阶段引入环境遮蔽可以明显的提升你场景的视觉效果。网格/表面的环境遮蔽贴图要么通过手动生成，要么由3D建模软件自动生成。 美术师们可以在纹素级别设置或调整这些基于物理的输入值，还可以以现实世界材料的表面物理性质来建立他们的材质数据。这是PBR渲染管线最大的优势之一，因为不论环境或者光照的设置如何改变这些表面的性质是不会改变的，这使得美术师们可以更便捷的获取物理可信的结果。在PBR渲染管线中编写的表面可以非常方便的在不同的PBR渲染引擎间共享使用，不论处于何种环境中它们看上去都会是正确的，因此看上去也会更自然。 参考资料 1. 理论","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题3：魔术索引","slug":"问题3：魔术索引","date":"2020-07-15T08:58:58.000Z","updated":"2020-07-15T10:03:29.114Z","comments":false,"path":"2020/07/15/问题3：魔术索引/","link":"2020/07/15/问题3：魔术索引","permalink":"http://ssssshinji.github.io/2020/07/15/%E9%97%AE%E9%A2%983%EF%BC%9A%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/","excerpt":"","text":"题目描述 在数组A[0…n-1]中，有所谓的魔术索引，满足条件A[i]=i。给定一个有序整数数组，元素值各不相同，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引。进阶：如果数组元素有重复值，又该如何处理呢？（提示在页尾） 个人思路 如果a[i] &lt; i，比如说a[6] = 3,那么a[3]到a[6]之间都不可能有魔术索引。如果a[i] &gt; i,比如说a[4] = 7;那么在a[5]到a[7]之间都不可能有魔术索引，故可写出： 个人解答 12345678910111213public static int MagicIndex(int[] a)&#123; return MagicIndex(a,0,a.Length-1);&#125;public static int MagicIndex(int[] a, int low, int high)&#123; if(a[low] &#x3D;&#x3D; low)return low; if(a[low] &lt; low)&#123; high &#x3D; a[low] -1; &#125; if(a[low] &gt; low)&#123; low &#x3D; a[low] + 1; &#125; return MagicIndex(a,low,high);&#125; 复杂度分析 O(n)。 题目解析 看到这个问题，第一个想到的应该是蛮力法，提到它并不丢人。蛮力法只需迭代访问整个数组，找出符合条件的元素即可。 不过，既然给定数组是有序的，我们理应充分利用这个条件。你可能会发现这个问题与经典的二分查找问题大同小异。充分运用模式匹配法，就能找出适当的算法，我们又该怎么运用二分查找法呢？在二分查找中，要找出元素k，我们会先拿它跟数组中间的元素x比较，确定k位于x的左边还是右边。以此为基础，是否通过检查中间元素就能确定魔术索引的位置？下面来看一个样例数组。 0 1 2 3 4 5 6 7 8 9 10 -40 -20 -1 1 2 3 5 7 9 12 13 看到中间元素A[5]=3，我们可以断定魔术索引一定在数组右侧，因为A[mid]&lt;mid。 为何魔术索引不会在数组左侧呢？注意，从元素i移至i-1时，此索引对应的值至少要减1，也可能更多（因为数组是有序的，且所有元素各不相同）。因此，如果中间元素因过小而不是魔术索引，那么往左侧移动时，索引减k，值至少也减k，所有余下的元素也会过小。(和自己的思路不一样) 继续运用这个递归算法，就会写出与二分查找极为相似的代码 标准解答 123456789101112131415public static int MagicIndex(int[] a)&#123; return MagicIndex(a,0,a.Length-1);&#125;public static int MagicIndex(int[] a, int low, int high)&#123; if(low &lt; high)&#123;return -1;&#125; int mid &#x3D; (low + high) &#x2F;2; if(a[mid] &#x3D;&#x3D; mid)&#123; return mid; &#125;else if(a[mid] &gt; mid)&#123; return MagicIndex(a,low,mid - 1); &#125; else &#123; return MagicIndex(a,mid + 1,high); &#125;&#125; 如果数组元素有重复值，前面的算法就会失效。以下面的数组为例。 0 1 2 3 4 5 6 7 8 9 10 -10 -5 2 2 2 3 4 7 9 12 13 看到A[mid]&lt;mid，我们无法断定魔术索引位于数组哪一边。它可能在数组右侧，跟前面一样。或者，也可能在左侧（在本例中的确在左侧）。 它有没有可能在左侧的任意位置？未必。由A[5]=3可知，A[4]不可能是魔术索引。A[4]必须等于4，其索引才能成为魔术索引，但数组是有序的，故A[4]必定小于A[5]。 其实，看到A[5]=3时，按照前面的做法，我们需要递归搜索右半部分。不过，若搜索左半部分，我们可以跳过一些元素，只递归搜索A[0]到A[3]的元素。A[3]是第一个可能成为魔术索引的元素。 综上所述，我们得到一般模式：先比较midIndex和midValue是否相同。然后，若两者不同，则按如下方式递归搜索左半部分和右半部分。 左半部分：搜索索引从start到Math.min(midIndex -1,midValue)的元素。 右半部分：搜索索引从Math.max(midIndex+1, midValue)到end的元素。 标准解答（进阶） 1与个人思路基本相同 反思 对问题的一些细节理解的不到位，会导致构建出来的解题模型有一点问题。要对细节多思考，保证逻辑正确，简洁。 提示：#170，#204，#240，#286，#340 -先试试蛮力算法。 -蛮力算法的运行时间可能为O(N)。如果试图击败那个运行时间，你认为会得到什么运行时间。什么样的算法具有该运行时间？ -你能以O(logN)的时间复杂度来解决这个问题吗？ -二分查找有O(logn)的运行时间。你能在这个问题中应用二分查找吗？ -给定一个特定的索引和值，你能确定魔术索引是在它之前还是之后吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"递归与动态规划","slug":"递归与动态规划","permalink":"http://ssssshinji.github.io/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"问题精析：OpenGL：VAO和VBO","slug":"问题精析：OpenGL：VAO和VBO","date":"2020-07-14T17:40:15.000Z","updated":"2020-07-14T17:51:34.290Z","comments":false,"path":"2020/07/15/问题精析：OpenGL：VAO和VBO/","link":"2020/07/15/问题精析：OpenGL：VAO和VBO","permalink":"http://ssssshinji.github.io/2020/07/15/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AOpenGL%EF%BC%9AVAO%E5%92%8CVBO/","excerpt":"","text":"顶点输入和VBO 开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。 我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个float数组。 12345float vertices[] &#x3D; &#123; -0.5f, -0.5f, 0.0f, 0.5f, -0.5f, 0.0f, 0.0f, 0.5f, 0.0f&#125;; 定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。 我们通过**顶点缓冲对象(Vertex Buffer Objects, VBO)**管理这个内存，它会在GPU内存（通常被称为显存）中储存大量顶点。使用这些缓冲对象的好处是我们可以一次性的发送一大批数据到显卡上，而不是每个顶点发送一次。从CPU把数据发送到显卡相对较慢，所以只要可能我们都要尝试尽量一次性发送尽可能多的数据。当数据发送至显卡的内存中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。 顶点缓冲对象是我们在OpenGL教程中第一个出现的OpenGL对象。就像OpenGL中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用glGenBuffers函数和一个缓冲ID生成一个VBO对象： 12unsigned int VBO;glGenBuffers(1, &amp;VBO); OpenGL有很多缓冲对象类型，顶点缓冲对象的缓冲类型是GL_ARRAY_BUFFER。OpenGL允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用glBindBuffer函数把新创建的缓冲绑定到GL_ARRAY_BUFFER目标上： 1glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到GL_ARRAY_BUFFER目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式： GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 现在我们已经把顶点数据储存在显卡的内存中，用VBO这个顶点缓冲对象管理。 VAO 顶点数组对象(Vertex Array Object, VAO)可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的VAO就行了。刚刚设置的所有状态都将存储在VAO中 OpenGL的核心模式要求我们使用VAO，所以它知道该如何处理我们的顶点输入。如果我们绑定VAO失败，OpenGL会拒绝绘制任何东西。 一个顶点数组对象会储存以下这些内容： glEnableVertexAttribArray和glDisableVertexAttribArray的调用。 通过glVertexAttribPointer设置的顶点属性配置。 通过glVertexAttribPointer调用与顶点属性关联的顶点缓冲对象。 每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。 创建一个VAO和创建一个VBO很类似： 12unsigned int VAO;glGenVertexArrays(1, &amp;VAO); 要想使用VAO，要做的只是使用glBindVertexArray绑定VAO。从绑定之后起，我们应该绑定和配置对应的VBO和属性指针，之后解绑VAO供之后使用。当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把VAO绑定到希望使用的设定上就行了。这段代码应该看起来像这样： 1234567891011121314151617&#x2F;&#x2F; ..:: 初始化代码（只运行一次 (除非你的物体频繁改变)） :: ..&#x2F;&#x2F; 1. 绑定VAOglBindVertexArray(VAO);&#x2F;&#x2F; 2. 把顶点数组复制到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);&#x2F;&#x2F; 3. 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);[...]&#x2F;&#x2F; ..:: 绘制代码（渲染循环中） :: ..&#x2F;&#x2F; 4. 绘制物体glUseProgram(shaderProgram);glBindVertexArray(VAO);glDrawArrays(GL_TRIANGLES, 0, 3); glDrawArrays函数第一个参数是我们打算绘制的OpenGL图元的类型。由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递GL_TRIANGLES给它 （图元装配环节的）。第二个参数指定了顶点数组的起始索引，我们这里填0。最后一个参数指定我们打算绘制多少个顶点，这里是3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。 参考资料 1. 你好，三角形","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：Early-z","slug":"问题精析：Early-z","date":"2020-07-14T15:13:36.000Z","updated":"2020-07-18T06:19:59.944Z","comments":false,"path":"2020/07/14/问题精析：Early-z/","link":"2020/07/14/问题精析：Early-z","permalink":"http://ssssshinji.github.io/2020/07/14/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AEarly-z/","excerpt":"","text":"为什么会有Early-z 传统的渲染管线在之前有过详细介绍，一系列的测试实在执行过片元着色器之后才进行的，也就是说就算我们指定了一些测试条件来剔除掉一部分像素，但是这些像素还是经过了计算的，便产生了Over Draw，因为这部分计算也就显得没有必要。 Early-z便由此产生，在光栅化阶段的片元着色器计算前，先利用深度测试丢弃那些不会显示出来的像素。 实现Early-z Early-z是一种硬件特性，每个厂商在实现时也会有所不同。需要一些方法，我们才能利用这种特性。 This sample demonstrates two ways to take advantage of early Z rejection. When rendering, if the hardware detects that after performing vertex shading a fragment will fail the depth test, it can avoid the cost of executing the pixel shader and reject the fragment. To best take advantage of this feature, it is necessary to maximize the number of fragments that can be rejected because of depth testing. This sample demonstrates two ways of doing this:front to back rendering and z pre-pass. 简单的说，一种是通过从前向后渲染，一种是通过z pre-pass。 从前向后渲染 我们知道在编写shaderlab的时候会为我们的shader指定渲染队列，这个渲染队列其实就是unity帮我们实现从前向后渲染功能的工具（根据渲染队列进行渲染，unity使用了正数索引代表渲染队列，索引号越小越早被渲染）。不透明物体，我们最好使用从前向后渲染，这样可以使用early-z功能，减少绘制的像素。而透明物体不可以使用这种early-z的方式，因为透明物体盖住的物体还是需要被渲染出来的，所以unity中不透明物体是从后往前渲染的，而且透明物体需要在不透明物体渲染完之后再进行渲染。所以unity已经帮我们实现了这种early-z的功能，我们只需要合理控制物体的渲染队列，就可以实现优化了。 很容易理解，从前到后渲染，能保证无用的像素都在进入片元着色器前通过Early-z丢弃。 z-pre pass For Z pre-pass, all opaque geometry is rendered in two passes. The first pass populates the Z buffer with depth values from all opaque geometry. A null pixel shader is used and the color buffer is not updated. For this first pass, only simple vertex shading is performed so unnecessary constant buffer updates and vertex-layout data should be avoided. For the second pass, the geometry is resubmitted with Z writes disabled but Z testing on and full vertex and pixel shading is performed. The graphics hardware takes advantage of Early-Z to avoid performing pixel shading on geometry that is not visible. 文章中有提到第一个pass中只进行了简单的顶点着色，要避免不必要的常量缓冲区更新和顶点布局数据。也就是说这个渲染管线也与第一篇文章所描述的相同。early-z是在顶点着色器与片元着色器之间操作的。 1234Pass &#123; ZWrite On ColorMask 0&#125; Early-z失效 1.片元着色器里里修改了深度值，显然。 2.打开了alpha test(或fragment shader里discard了fragment)，原因和blending和depth test的关系是类似的，early-z可能会更新之后被alpha test discard掉的fragment。 总结 1.Early Z由硬件实现，随着硬件的演进，它的功能也在不断进化，处理的情况也变多。 2.Alpha Test或者Depth modify都会使用early z失效，但是后面渲染的批次还可以继续使用early z（Hierachical Z）优化。 3.渲染API可以通过设置earlydepthstencilvii或者layout(early_fragment_tests) in;（opengl）来强制使用early z。 我们知道现在不透明物体开启了深度写入与深度测试后，会进行early-Z判断，但是这个时候还是需要应用层把相关的顶点数据传递给GPU，以进行深度测试。所以在FrameDebugger中，我们可以看到就算前面有一个很大的不透明物体，把后面的不透明物体都挡住了，但是后面的物体还是会占用drawcall，这个drawcall就是应用层把信息传递给GPU的数据。所以深度测试其实无法对CPU瓶颈进行优化，只是可以让没有通过深度测试的物体，不进行片元着色器的计算，从而减少计算量，降低GPU瓶颈。 参考资料 1. alpha test, blending, early-z, later-z之间的次序关系 2. 深入剖析GPU Early Z优化 2. [unity]神秘的Early-Z到底是个啥？","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：PBR:基本原理及推导","slug":"问题精析：PBR-基本原理及推导","date":"2020-07-12T10:24:55.000Z","updated":"2020-07-16T10:20:06.671Z","comments":false,"path":"2020/07/12/问题精析：PBR-基本原理及推导/","link":"2020/07/12/问题精析：PBR-基本原理及推导","permalink":"http://ssssshinji.github.io/2020/07/12/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%E5%8F%8A%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"本节的理论和推导尽量简化和精简。 满足以下条件的光照模型才能称之为PBR光照模型： 基于微平面模型（Be based on the microfacet surface model）。 能量守恒（Be energy conserving）。 使用基于物理的BRDF（Use a physically based BRDF）。 微平面（Microfacet） 大多数PBR技术都是基于微平面理论。在此理论下，认为在微观上所有材质表面都是由很多朝向不一的微小平面组成，有的材质表面光滑一些，有的粗糙一些。 当光线射入这些微平面后，通常会产生镜面反射。对于越粗糙的表面，由于其朝向更无序，反射的光线更杂乱，反之，平滑的微平面，反射的光线更平齐。 从微观角度来说，没有任何表面是完全光滑的。由于这些微平面已经微小到无法逐像素地继续对其进行细分，因此我们只有假设一个粗糙度(Roughness)参数，然后用统计学的方法来概略的估算微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出某个向量的方向与微平面平均取向方向一致的概率。这个向量便是位于光线向量l和视线向量v之间的中间向量，被称为半角向量(Halfway Vector)。半角向量h是视线v和入射光l的中间单位向量： $$ \\frac{\\vec l + \\vec v}{\\lVert \\vec l + \\vec v \\rVert} $$ 1234&#x2F;&#x2F; lightPos是光源位置，viewPos是摄像机位置，FragPos是像素位置vec3 lightDir &#x3D; normalize(lightPos - FragPos);vec3 viewDir &#x3D; normalize(viewPos - FragPos);vec3 halfwayDir &#x3D; normalize(lightDir + viewDir); 粗糙度从0.1~1.0的变化图。粗糙度越小，镜面反射越亮范围越小；粗糙度越大，镜面反射越弱。（此处关于镜面反射的含义参考PBR） 能量守恒（Energy Conservation） 在概述中有详细介绍。故不再赘述。要点为，通常情况下，PBR会简化折射光，将平面上所有折射光都视为被完全吸收而不会散开。而有一些被称为次表面散射(Subsurface Scattering)技术的着色器技术会计算折射光散开后的模拟，它们可以显著提升一些材质（如皮肤、大理石或蜡质）的视觉效果，不过性能也会随着下降。 金属(Metallic)材质会立即吸收所有折射光，故而金属只有镜面反射，而没有折射光引起的漫反射。 根据上面的能量守恒关系，可以先计算镜面反射部分，此部分等于入射光线被反射的能量所占的百分比。而折射部分可以由镜面反射部分计算得出。 123&#x2F;&#x2F; lightPos是光源位置，viewPos是摄像机位置，FragPos是像素位置float kS &#x3D; calculateSpecularComponent(...); &#x2F;&#x2F; 反射&#x2F;镜面部分float kD &#x3D; 1.0 - kS; &#x2F;&#x2F; 折射&#x2F;漫反射部分 通过以上代码可以看出，镜面反射部分与漫反射部分的和肯定不会超过1.0，从而近似达到能量守恒的目的。 反射方程（Reflectance Equation） 渲染方程(Render Equation)是用来模拟光的视觉效果最好的模型。而PBR的渲染方程是用以抽象地描述PBR光照计算过程的特化版本的渲染方程，被称为反射方程。 PBR的反射方程可抽象成下面的形式： $$ L_o(p,\\omega_o) =\\int_{\\Omega} f_r(p,\\omega_i,\\omega_o)L_i(p,\\omega_i)n\\cdot\\omega_id\\omega_i $$ 为了计算这个区域（半球）内的所有值，在反射方程中使用了一个称作为积分的数学符号 ∫，来计算半球Ω内所有的入射向量dωi。 积分计算面积的方法，有解析(analytically)和渐近(numerically)两种方法。目前尚没有可以满足渲染计算的解析法，所以只能选择离散渐近法来解决这个积分问题。 具体做法是在半球Ω按一定的步长将反射方程离散地求解，然后再按照步长大小将所得到的结果平均化，这种方法被称为黎曼和(Riemann sum)。下面是实现的伪代码： 1234567891011int steps &#x3D; 100; &#x2F;&#x2F; 分段计算的数量，数量越多，计算结果越准确。float dW &#x3D; 1.0f &#x2F; steps;vec3 P &#x3D; ...;vec3 Wo &#x3D; ...;vec3 N &#x3D; ...;float sum &#x3D; 0.0f;for(int i &#x3D; 0; i &lt; steps; ++i) &#123; vec3 Wi &#x3D; getNextIncomingLightDir(i); sum +&#x3D; Fr(P, Wi, Wo) * L(P, Wi) * dot(N, Wi) * dW;&#125; 只剩下fr项未描述。fr就是双向反射分布函数(Bidirectional Reflectance Distribution Function, BRDF)，它的作用是基于表面材质属性来对入射辐射度进行缩放或者加权。 Cook-Torrance BRDF BRDF函数是近似的计算在一个给定了属性的不透明表面上每个单独的光线对最终的反射光的贡献量。假如表面是绝对光滑的（比如镜子），对于所有入射光ωi的BRDF函数都将会返回0.0，除非出射光线ωo方向的角度跟入射光线ωi方向的角度以面法线为中轴线完全对称，则返回1.0。 BRDF对于材质的反射和折射属性的模拟基于之前讨论过的微平面理论，想要BRDF在物理上是合理的，就必须遵守能量守恒定律。比如反射光能量总和永远不应该超过入射光。技术上来说，Blinn-Phong光照模型跟BRDF一样使用了ωi跟ωo作为输入参数，但是没有像基于物理的渲染这样严格地遵守能量守恒定律。 BRDF有好几种模拟表面光照的算法，然而，基本上所有的实时渲染管线使用的都是Cook-Torrance BRDF。 Cook-Torrance BRDF分为漫反射和镜面反射两个部分： $$ f_r = k_df_{lambert} + k_sf_{(cook-torrance)} $$ 其中kd是入射光中被折射的比例，ks是另外一部分被镜面反射的入射光。BRDF等式左边的flambert表示的是漫反射部分，这部分叫做兰伯特漫反射（Lambertian Diffuse）。在PBR-三种反射模型和PBR-BRDF中都有详细说明。 此处的伦勃朗漫反射跟以前用的漫反射之间的关系：以前的漫反射是用表面的漫反射颜色乘以法线与面法线的点积，这个点积依然存在，只不过是被移到了BRDF外面，写作n⋅ωi，放在反射方程Lo靠后的位置。 BRDF的高光（镜面反射）部分更复杂： $$ f_{(cook-torrance)} = \\frac{DFG}{4(\\omega_o\\cdot n)(\\omega_i\\cdot n)} $$ Cook-Torrance镜面反射BRDF由3个函数（D，F，G）和一个标准化因子构成。D，F，G符号各自近似模拟了特定部分的表面反射属性： D(Normal Distribution Function，NDF)：法线分布函数，估算在受到表面粗糙度的影响下，取向方向与中间向量一致的微平面的数量。这是用来估算微平面的主要函数。 F(Fresnel equation)：菲涅尔方程，描述的是在不同的表面角下表面反射的光线所占的比率。 G(Geometry function)：几何函数，描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。 D(Normal Distribution Function，NDF) 法线分布函数，从统计学上近似的表示了与某些（如中间）向量h取向一致的微平面的比率。 目前有很多种NDF都可以从统计学上来估算微平面的总体取向度，只要给定一些粗糙度的参数以及一个我们马上将会要用到的参数Trowbridge-Reitz GGX(GGXTR): $$ NDF_{(GGXTR)}(n,h,\\alpha) = \\frac{\\alpha^2}{\\pi((n\\cdot h)^2(\\alpha^2 - 1)+1)^2} $$ 这里的h是用来测量微平面的半角向量，α是表面的粗糙度，n是表面法线。 如果将h放到表面法线和光线方向之间，并使用不同的粗糙度作为参数，可以得到下面的效果： 当粗糙度很低（表面很光滑）时，与中间向量h取向一致的微平面会高度集中在一个很小的半径范围内。由于这种集中性，NDF最终会生成一个非常明亮的斑点。但是当表面比较粗糙的时候，微平面的取向方向会更加的随机，与向量h取向一致的微平面分布在一个大得多的半径范围内，但是较低的集中性也会让最终效果显得更加灰暗。 Trowbridge-Reitz GGX的NDF实现代码： 123456789101112float DistributionGGX(vec3 N, vec3 H, float a)&#123; float a2 &#x3D; a*a; float NdotH &#x3D; max(dot(N, H), 0.0); float NdotH2 &#x3D; NdotH*NdotH; float nom &#x3D; a2; float denom &#x3D; (NdotH2 * (a2 - 1.0) + 1.0); denom &#x3D; PI * denom * denom; return nom &#x2F; denom;&#125; F(Fresnel equation) 菲涅尔方程定义的是在不同观察方向上，表面上被反射的光除以被折射的光的比例。在一束光击中了表面的一瞬间，菲涅尔根据表面与观察方向之间的夹角，计算得到光被反射的百分比。根据这个比例和能量守恒定律我们可以直接知道剩余的能量就是会被折射的能量。 当我们垂直观察每个表面或者材质时都有一个基础反射率，当我们以任意一个角度观察表面时所有的反射现象都会变得更明显（反射率高于基础反射率）。你可以从你身边的任意一件物体上观察到这个现象，当你以90度角观察你的桌子你会法线反射现象将会变得更加的明显，理论上以完美的90度观察任意材质的表面都应该会出现全反射现象（所有物体、材质都有菲涅尔现象）。 菲涅尔方程同样是个复杂的方程，但是幸运的是菲涅尔方程可以使用Fresnel-Schlick来近似： $$ F_{(Schlick)}(h,v,F_0) = F_0 + (1-F_0)(1-(h\\cdot v))^5 $$ F0表示的是表面基础反射率，这个我们可以使用一种叫做Indices of refraction(IOR)的方法计算得到。运用在球面上的效果就是你看到的那样，观察方向越是接近掠射角（grazing angle，又叫切线角，与正视角相差90度），菲涅尔现象导致的反射就越强： 菲涅尔方程中有几个微妙的地方，一个是Fresnel-Schlick算法仅仅是为电介质（绝缘体）表面定义的算法。对于金属表面，使用电介质的折射率来计算基础反射率是不合适的，我们需要用别的菲涅尔方程来计算。对于这个问题，我们需要预先计算表面在正视角(即以0度角正视表面)下的反应（F0），然后就可以跟之前的Fresnel-Schlick算法一样，根据观察角度来进行插值。这样我们就可以用一个方程同时计算金属和电介质了。 表面在正视角下的反映或者说基础反射率可以在这个数据库中找到，下面是Naty Hoffman的在SIGGRAPH公开课中列举的一些常见材质的值： 这里可以观察到的一个有趣的现象，所有电介质材质表面的基础反射率都不会高于0.17，这其实是例外而非普遍情况。导体材质表面的基础反射率起点更高一些并且（大多）在0.5和1.0之间变化。此外，对于导体或者金属表面而言基础反射率一般是带有色彩的，这也是为什么要用RGB三原色来表示的原因（法向入射的反射率可随波长不同而不同）。这种现象我们只能在金属表面观察的到。(这也是为什么金属的高光有颜色，非导体的高光是一种灰色的原因) 通过预先计算电介质与导体的值，我们可以对两种类型的表面使用相同的Fresnel-Schlick近似，但是如果是金属表面的话就需要对基础反射率添加色彩。我们一般是按下面这个样子来实现的： 12vec3 F0 &#x3D; vec3(0.04);F0 &#x3D; mix(F0, surfaceColor.rgb, metalness); 我们为大多数电介质表面定义了一个近似的基础反射率。F0取最常见的电解质表面的平均值，这又是一个近似值。不过对于大多数电介质表面而言使用0.04作为基础反射率已经足够好了，而且可以在不需要输入额外表面参数的情况下得到物理可信的结果。然后，基于金属表面特性，我们要么使用电介质的基础反射率要么就使用F0作来为表面颜色。因为金属表面会吸收所有折射光线而没有漫反射，所以我们可以直接使用表面颜色纹理来作为它们的基础反射率。 Fresnel Schlick近似可以用GLSL代码实现： 1234vec3 fresnelSchlick(float cosTheta, vec3 F0)&#123; return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);&#125; 如果没有应用微面元模型，则有半角向量等于法向量 h=n,cosTheta便为表面法向量n与观察方向v的点乘的结果。实际上，h向量的意义就是在微面元模型下替代法向量的作用，本文不再赘述。 G(Geometry function) 几何函数模拟微平面相互遮挡导致光线的能量减少或丢失的现象。 类似NDF，几何函数也使用粗糙度作为输入参数，更粗糙意味着微平面产生自阴影的概率更高。几何函数使用由GGX和Schlick-Beckmann组合而成的模拟函数Schlick-GGX： $$ G_{(SchlickGGX)}(n,v,k) = \\frac{n\\cdot v}{(n\\cdot v)(1-k)+k} $$ 这里的k是使用粗糙度α计算而来的，用于直接光照和IBL光照的几何函数的参数： $$ k_{Pdirect} = \\frac{(\\alpha + 1)^2}{8} $$ $$ k_{IBL} = \\frac{\\alpha^2}{2} $$ $$ G_{(SchlickGGX)}(n,v,k) = \\frac{n\\cdot v}{(n\\cdot v)(1-k)+k} $$ 为了有效地模拟几何体，我们需要同时考虑两个视角，视线方向（几何遮挡）跟光线方向（几何阴影），我们可以用Smith函数将两部分放到一起： $$ G(n,v,l,k)=Gsub(n,v,k)Gsub(n,l,k) $$ 其中v表示视线向量，Gsub(n,v,k)表示视线方向的几何遮挡；l表示光线向量，Gsub(n,l,k)表示光线方向的几何阴影。使用Smith函数与Schlick-GGX作为Gsub可以得到如下所示不同粗糙度R的视觉效果： 使用GLSL编写的几何函数代码如下： 1234567891011121314151617float GeometrySchlickGGX(float NdotV, float k)&#123; float nom &#x3D; NdotV; float denom &#x3D; NdotV * (1.0 - k) + k; return nom &#x2F; denom;&#125; float GeometrySmith(vec3 N, vec3 V, vec3 L, float k)&#123; float NdotV &#x3D; max(dot(N, V), 0.0); float NdotL &#x3D; max(dot(N, L), 0.0); float ggx1 &#x3D; GeometrySchlickGGX(NdotV, k); &#x2F;&#x2F; 视线方向的几何遮挡 float ggx2 &#x3D; GeometrySchlickGGX(NdotL, k); &#x2F;&#x2F; 光线方向的几何阴影 return ggx1 * ggx2;&#125; 几何函数是一个值域为[0.0, 1.0]的乘数（a为粗糙度，取0时几何函数为1），其中白色或者说1.0表示没有微平面阴影，而黑色或者说0.0则表示完全微平面阴影。 参考资料 1. 由浅入深学习PBR的原理和实现","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题4：检查平衡性","slug":"问题4：检查平衡性","date":"2020-07-11T08:45:58.000Z","updated":"2020-07-16T04:49:20.843Z","comments":false,"path":"2020/07/11/问题4：检查平衡性/","link":"2020/07/11/问题4：检查平衡性","permalink":"http://ssssshinji.github.io/2020/07/11/%E9%97%AE%E9%A2%984%EF%BC%9A%E6%A3%80%E6%9F%A5%E5%B9%B3%E8%A1%A1%E6%80%A7/","excerpt":"","text":"题目描述 实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过1。（提示在页尾） 个人思路 两个函数，一个求高度，一个判断是否平衡。但是效率很低下。看了提示之后想试着写成一个函数。 个人解答 123456789101112131415161718&#x2F;&#x2F;自己写的有问题，等于只检查了最大的那颗树！！！！！！ static int TreeDepth(TreeNode root)&#123; if(root &#x3D;&#x3D; null)&#123; return 0; &#125; return TreeDepth(root.left) &gt; TreeDepth(root.right) ? TreeDepth(root.left)+1 : TreeDepth(root.right)+1; &#125; static bool IsBalance(TreeNode root)&#123; if(root.left !&#x3D; null||root.right !&#x3D; null)&#123; IsBalance(root.left); IsBalance(root.right); &#125; if(Math.Abs(TreeDepth(root.left) - TreeDepth(root.right)) &gt; 1)&#123; return false; &#125; return true; &#125; 题目解析 任意一个节点，其两棵子树的高度差不超过1。根据该定义可以得到一种解法，即直接递归访问整棵树，计算每个节点两棵子树的高度。此法虽然可行，但不太高效，这段代码会递归访问每个节点的整棵子树，也就是说，getHeight会被反复调用计算同一个节点的高度。因此，由于每个节点被其上方的节点访问一次，这个算法的时间复杂度为O(NlogN)。 标准解答 1234567891011121314151617static int TreeDepth(TreeNode root)&#123; if(root &#x3D;&#x3D; null)&#123; return 0; &#125; return TreeDepth(root.left) &gt; TreeDepth(root.right) ? TreeDepth(root.left)+1 : TreeDepth(root.right)+1;&#125;static bool IsBalance(TreeNode root)&#123; if(root &#x3D;&#x3D; null)&#123; return true; &#125; if(Math.Abs(TreeDepth(root.left) - TreeDepth(root.right)) &gt; 1)&#123; return false; &#125; else&#123; return IsBalance(root.left) &amp;&amp; IsBalance(root.right); &#125;&#125; 仔细查看上面的方法，你或许会发现，getHeight不仅可以检查高度，还能检查这棵树是否平衡。那么，我们发现子树不平衡时又该怎么做呢？直接返回一个错误代码即可 改进过的算法会从根节点递归向下检查每棵子树的高度。我们会通过checkHeight方法，以递归方式获取每个节点左右子树的高度。若子树是平衡的，则checkHeight返回该子树的实际高度。若子树不平衡，则checkHeight返回一个错误代码。checkHeight会立即中断执行，并返回一个错误代码。 我们应该拿什么作为错误代码呢？空树的高度一般被记作-1，所以将-1作为错误代码并不是上乘之选。其实，我们可以将Integer.MIN_VALUE作为错误代码。 标准解答（改进） 1234567891011121314151617int checkHeight(Treenode root)&#123; if(root &#x3D;&#x3D; null) return -1; int leftHeight &#x3D; checkHeight(root.left); if(leftHeight &#x3D;&#x3D; Int32.MinValue)return Int32.MinValue;&#x2F;&#x2F;向上传递错误 int rightHeight &#x3D; checkHeight(root.right); if(rightHeight &#x3D;&#x3D; Int32.MinValue)return Int32.MinValue;&#x2F;&#x2F;向上传递错误 int heightDiff &#x3D; leftHeight - rightHeight; if(Math.Abs(heightDiff) &gt; 1)&#123; return Int32.MinValue; &#125; else&#123; return Math.Max(leftHeight, rightHeight) + 1; &#125;&#125;bool isBalanced(Treenode root)&#123; return checkHeight(root) !&#x3D; Int32.MinValue;&#125; 复杂度分析 这段代码需要O(N)的时间和O(H)的空间，其中H为树的高度。 反思 思考时感觉需要同时返回两个式子，忘记了&amp;&amp;运算符，导致最后写出来的算法其实只能判断最大树是否平衡。 提示：#21，#33，#49，#105，#124 -考虑平衡树的定义。你可以检查单个节点的条件吗？你可以检查每个节点吗？ -如果你开发了一个蛮力解法，请注意它的运行时间。如果你是用于计算每个节点的子树的高度，那么该算法会很低效。 -如果你可以修改二叉树节点类，允许节点存储子树的高度，会如何？ -你不需要修改二叉树类来存储子树的高度。递归函数是否可以计算每个子树的高度，同时检查节点是否平衡？尝试让函数返回多个值。 -其实，你只需要一个checkHeight函数即可，它既可以计算高度，也可以平衡检查。可以使用整数返回值表示两者。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"问题精析：PBR:BRDF","slug":"问题精析：PBR-BRDF","date":"2020-07-10T07:53:16.000Z","updated":"2020-07-12T09:26:28.148Z","comments":false,"path":"2020/07/10/问题精析：PBR-BRDF/","link":"2020/07/10/问题精析：PBR-BRDF","permalink":"http://ssssshinji.github.io/2020/07/10/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR-BRDF/","excerpt":"","text":"我们看到一个表面，实际上是周围环境的光照射到表面上，然后表面将一部分光反射到我们眼睛里。双向反射分布函数BRDF（Bidirectional Reflectance Distribution Function）就是描述表面入射光和反射光关系的。BRDF就是一个描述光如何从给定的两个方向（入射光方向l和出射方向v）在表面进行反射的函数。 BRDF的精确定义是出射辐射率的微分（differential outgoing radiance）和入射辐照度的微分（differential incoming irradiance）之比： $$ f(l,v) = \\frac{dL_o(v)}{dE(l)} $$ 其中f就是BRDF，l是入射光方向，v是观察方向，也就是我们关心的反射光方向。 \\(f(l,v)\\)是表面反射到\\(v\\)方向的反射光的微分辐射率。表面反射到\\(v\\)方向的反射光的辐射率为\\(L_o(v)\\)，来自于表面上半球所有方向的入射光线的贡献，而微分辐射率\\(dL_o(v)\\)特指来自方向\\(l\\)的入射光贡献的反射辐射率。 \\(dE(l)\\)是表面上来自入射光方向\\(l\\)的微分辐照度。表面接收到的辐照度为\\(E\\)，来自上半球所有方向的入射光线的贡献，而微分辐照度\\(dE(l)\\)特指来自于方向\\(l\\)的入射光。 相关物理量（辐射度量学） 辐射通量/光通量 Radiant Flux 功率（Power），单位瓦特（Watts），或者焦耳／秒。辐射度学中，辐射功率也被称为辐射通量（Radiant Flux）或者通量（Flux）。描述的是在单位时间穿过截面的光能，或每单位时间的辐射能量，通常用Φ来表示。 $$ \\phi = dQ/dt $$ 其中的Q表示辐射能(Radiant energy)，单位是J，焦耳。 辐射强度/发光强度 Radiant Intensity 指通过单位立体角的辐射通量。用符号I表示，单位\\(W \\cdot sr^-1\\)，瓦特每球面度。之所以引入辐射强度，是因为有时候要度量通过一个点的通量的密度，但因为点的面积是0，无法使用辐照度。辐射强度不会随距离变化而变化，不像点光源的辐照度会随距离增大而衰减，这是因为立体角不会随距离变化而变化。 $$ I = d\\phi/d\\omega $$ 辐照度/辉度Irradiance 辐照度（Irradiance，又译作辉度，辐射照度，用符号E表示），指入射表面的辐射通量，即单位时间内到达单位面积的辐射通量，或到达单位面积的辐射通量，也就是辐射通量对于面积的密度，用符号E表示，单位\\(W \\cdot m^-2\\)，瓦特每平方米。 $$ E = d\\phi/dA $$ 也可以写成辐射率(Radiance)在入射光所形成半球上的积分： $$ \\frac{d\\phi}{dA} = E = \\int_{\\Omega} L(\\omega)cos\\theta d\\omega $$ 假定不垂直于光线传输方向的表面面积为\\(A\\)，将它投影到垂直于光线方向得到一个虚拟表面，这个虚拟表面的面积为\\(A^ \\bot = Acos \\theta _i\\)，通过这两个面积的通量是相同的，均为\\(\\phi\\)，则表面接收到的辐照度\\(E = \\phi/A\\)，虚拟表面上的辐照度\\(E_L = \\phi/Acos \\theta_i\\)，于是\\(E = E_Lcos \\theta_i\\)。 辐射率/光亮度Radiance 我们常需要度量从一个微小面积表面出发，射向某个微小方向的通量（或者来自某个微小方向，照射到微小面积表面的通量），辐射率就是度量这种情况的量。辐射率（Radiance），指每单位面积每单位立体角的辐射通量密度。用符号L表示，单位\\(W \\cdot sr^-1 \\cdot m^-2\\)。需要注意的是，辐射率使用物体表面沿目标方向上的投影面积，而不是面积。 $$ L = \\frac{d^2\\phi}{dAcos \\theta d\\omega} $$ 辐射率实际上可以看成是我们眼睛看到（或相机拍到）的物体上一点的颜色。在基于物理着色时，计算表面一点的颜色就是计算它的辐射率。辐射率不会随距离变化而衰减，这和我们日常感受一致，在没有雾霾的干扰时，我们看到的物体表面上一点的颜色并不会随距离变化而变化。为什么辐照度会随距离增大而衰减，但是我们看到的颜色却不会衰减呢？这是因为随着距离变大，我们看到的物体上的一块区域到达视网膜的通量密度会变小，同时这块区域在视网膜表面上的立体角也会变小，正好抵消了通量密度的变化。 Lambert模型的BRDF 如图，设Lambert面元获得入射照度Ei，各方向均匀释放亮度，每个方向释放的亮度都是Lo。 又设此表面反射率为Albedo，根据反射率定义: $$ \\begin{align} Albedo &amp;= Eo/Ei \\\\&amp;= \\frac{\\int_{\\Omega} L(\\omega)cos\\theta d\\omega}{E_i} \\\\&amp;=\\frac{L_o*\\pi}{E_i} \\end{align} $$ 所以 $$ brdf=Lo/Ei=Albedo/pi $$ 半球cos积分等于\\(\\pi\\)的计算过程：作代换\\(dw=sin(\\theta)d\\theta d\\phi\\)，则 $$ \\begin{align} \\int_{\\Omega} cos\\theta d\\omega &amp;= \\int_{0}^{2\\pi}d\\phi \\int_{0}^{\\pi/2}cos\\theta sin\\theta d\\theta \\end{align} $$ 参考资料 1. 基于物理着色：BRDF 1. brdf为什么要定义为一个单位是sr-1的量？ 1. Lambert漫反射的BRDF","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：PBR:三种反射模型","slug":"问题精析：PBR-三种反射模型","date":"2020-07-09T18:35:40.000Z","updated":"2020-07-12T11:03:46.875Z","comments":false,"path":"2020/07/10/问题精析：PBR-三种反射模型/","link":"2020/07/10/问题精析：PBR-三种反射模型","permalink":"http://ssssshinji.github.io/2020/07/10/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR-%E4%B8%89%E7%A7%8D%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"PBR是近来一个新的，有意思的实时渲染方式。这个术语已经被传播得很广泛，但他的真实含义往往是混淆的。简单的回答是：这意味着很多。或者：这得看情况。这种回答并不能使人满意。所以我尝试着将PBR的真实含义，和它与传统的流程详细的解释清楚。这个文档主要是针对美术人员而非工程师。不会涉及数学或者代码类的东西。 PBR和传统流程最主要的区别在于他更详细和科学的还原了光照和物理表面的关系原理。他的纹理系统已经大大的进化。而旧的生产流程和近似的表达方式可以安全的抛弃了。这代表着无论是工程师还是美术工作人员都需要理解这些变化的动机在哪里。 我们需要从一些最基础的东西开始。这样我们可以在讲一些新东西之前对一些基本的概念有清楚的认识。你可能会觉得我讲的这些部分太枯燥乏味，但读过之后你会知道这些东西是值得的。你也可以了解一下Joe Wilson的文章：creating PBR artwork。 漫反射(Diffusion) 也称为散射，漫反射是最容易模拟的模型，现实中的例子也很多，例如石头，水泥，砖块等。最简单的Lambertian很简单粗暴的认为光线被均匀的反射到表面上方的半球中。 生活中一般说的漫反射是指投射在粗糙表面上的光向各个方向反射的现象，与渲染中的概念有所区别。渲染中的漫反射(Diffusion)指散射，包含次表面散射。表面引起的反射，与粗糙程度相关的（生活中所说的漫反射和镜面反射），交给镜面反射(Specular)负责，由粗糙度(Roughness)控制。下文漫反射均代表渲染中的漫反射，也就是散射，而不是表面的反射。 漫反射的性质通常用BRDF（双向反射分布函数）的漫反射分量来表示（基本是兰伯特模型，与粗糙程度无关）。一句话不严谨的概括BRDF既是输入一个入射的方向和一个出射的方向，输出一个出射光线和入射光线能量的比值。 12345float Lambertian(Vector3 In, Vector3 Out)&#123; &#x2F;&#x2F; 乘以PI的倒数是因为BRDF在半球内的积分需要为1，满足能量守恒 return INV_PI;&#125; 因为Lambertian模型均匀的反射出能量，所以返回值是一个常量和出射入射方向无关。下面是一个用Lambertian材质渲染的图片。 Lambertian并不能很好的模拟现实中的许多漫反射材质，现实中完美的均匀反射当然几乎是不存在的，有些现实中的材质会在视线方向接近和表面平行的时候反射更多的光线等。所以当然有一些更复杂的数学模型去模拟更复杂的漫反射，例如Oren Nayar模型。 Disney的Principled BRDF简单的用两个Fresnel项来增加入射角度低时反射的光线能量强度来模拟这种效果。好处是计算量相对小而且能打到足够的近似。贴一个我自己实现的伪代码，公式在最上面文档的链接5.3章节有，自行查阅。 1234567891011121314float DisneyDiffuse(Vector3 In, Vector3 Out)&#123; float oneMinusCosL &#x3D; 1.0f - AbsCosTheta(In); float oneMinusCosLSqr &#x3D; oneMinusCosL * oneMinusCosL; float oneMinusCosV &#x3D; 1.0f - AbsCosTheta(Out); float oneMinusCosVSqr &#x3D; oneMinusCosV * oneMinusCosV; &#x2F;&#x2F; Roughness是粗糙度，IDotH的意思会在下一篇讲Microfacet模型时提到 float IDotH &#x3D; Dot(In, Normalize(In + Out)); float F_D90 &#x3D; 0.5f + 2.0f * IDotH * IDotH * Roughness; return INV_PI * (1.0f + (F_D90 - 1.0f) * oneMinusCosLSqr * oneMinusCosLSqr * oneMinusCosL) * (1.0f + (F_D90 - 1.0f) * oneMinusCosVSqr * oneMinusCosVSqr * oneMinusCosV);&#125; 光滑镜面反射(Specular) 最常见的就是镜子和玻璃一类的材质了，他们分别为导体和电介材质。镜面反射就只是将入射光线根据表面法线反射，并且只在反射方向有能量其他方向均为0。对玻璃这种电介材质则除了反射之外还有根据物体的折射率一部分光线会折射进入物体之中。 最常见的就是镜子和玻璃一类的材质了，他们分别为导体和电介材质。镜面反射就只是将入射光线根据表面法线反射，并且只在反射方向有能量其他方向均为0。 对玻璃这种电介材质则除了反射之外还有根据物体的折射率一部分光线会折射进入物体之中。反射和折射能量的多少是根据菲涅尔定律决定（Fresnel’s Law）。图形学中常常使用用Schlock的近似Fresnel，伪代码如下。 12345678910float Fresnel_Schlick(float InCosine, float normalReflectance)&#123; &#x2F;&#x2F; InCosine是入射光线和法线的夹角，normalReflectance是入射光线和法线垂直时的反射能量大小 float oneMinusCos &#x3D; 1.0f - InCosine; float oneMinusCosSqr &#x3D; oneMinusCos * oneMinusCos; float fresnel &#x3D; normalReflectance + (1.0f - normalReflectance) * oneMinusCosSqr * oneMinusCosSqr * oneMinusCos; return fresnel;&#125; 值得一提的是在离线渲染，光线追踪里这两种材质本身的着色很容易，只用根据反射和折射的方向射出新的光线然后递归的着色即可。在游戏实时渲染中反射通常是用屏幕空间的反射（Screen Space Reflection）和环境光照贴图两者结合实现的，折射也通常是用扭曲屏幕空间像素的方法。都会有一些Artifact，目前没有完美的解决方案。 对于电介材质来说，除了本身的颜色以外，折射率是决定外观的另一个重要因素。折射率决定了折射光线的方向以及全反射的临界角度，上面的图片采用的折射率是1.5，也就是常见的玻璃的折射率，下面这张图则是用折射率2.42的渲染结果，对应的材质是钻石。根据菲涅尔定律，折射率越高的物体反射光线与折射光线的比值也越大，所以整个看起来更加Bling Bling了。 当然现实中不存在完美平滑的表面。接下来提高真实感的一个手段就是对材质表面的法线进行扰动。法线贴图是方法之一。(PBR中多用微表面) 参考资料 1. 基于物理着色（一）","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题5：一次编辑","slug":"问题5：一次编辑","date":"2020-07-09T10:54:46.000Z","updated":"2020-07-09T18:34:08.083Z","comments":false,"path":"2020/07/09/问题5：一次编辑/","link":"2020/07/09/问题5：一次编辑","permalink":"http://ssssshinji.github.io/2020/07/09/%E9%97%AE%E9%A2%985%EF%BC%9A%E4%B8%80%E6%AC%A1%E7%BC%96%E8%BE%91/","excerpt":"","text":"题目描述 字符串有三种编辑操作：插入一个字符、删除一个字符或者替换一个字符。给定两个字符串，编写一个函数判定它们是否只需要一次（或者零次）编辑。 示例： 1234pale, ple -&gt; truepales, pale -&gt; truepale, bake -&gt; truepale, bake -&gt; flase 个人思路 如果两个字符串长度相等，逐个比较就好，不同的地方最多只能有1处。如果两个字符长度相差1，分别用两个指针指向各自位置，如果出现不同，长的那个字符串的指针往后挪一位。之后再出现不同则返回false。 个人解答 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static bool CanOneEdit()&#123; string[] values &#x3D; Console.ReadLine().Split(&#39;,&#39;); string str1 &#x3D; values[0]; string str2 &#x3D; values[1]; bool oneDiff &#x3D; false; if(Math.Abs(str1.Length - str2.Length) &gt; 1)&#123; return false; &#125; else if(str1.Length &#x3D;&#x3D; str2.Length)&#123; int i &#x3D; 0; int j &#x3D; 0; for(i &#x3D; 0,j &#x3D; 0; i &lt; str1.Length;i++,j++)&#123; if(str1[i] !&#x3D; str2[j])&#123; if(oneDiff)&#123; return false; &#125; else oneDiff &#x3D; true; &#125; &#125; return true; &#125; else if(str1.Length - str2.Length &#x3D;&#x3D; 1)&#123; int i &#x3D; 0; int j &#x3D; 0; while(i &lt; str1.Length &amp;&amp; j &lt; str2.Length)&#123; if(str1[i] !&#x3D; str2[j])&#123; if(oneDiff)&#123; return false; &#125; else oneDiff &#x3D; true; i++; continue; &#125; i++;j++; &#125; return true; &#125; else if(str1.Length - str2.Length &#x3D;&#x3D; -1)&#123; int i &#x3D; 0; int j &#x3D; 0; while(i &lt; str1.Length &amp;&amp; j &lt; str2.Length)&#123; if(str1[i] !&#x3D; str2[j])&#123; if(oneDiff)&#123; return false; &#125; else oneDiff &#x3D; true; j++; continue; &#125; i++;j++; &#125; return true; &#125; return false;&#125; 题目解析 该题目可借助蛮力法。通过移除每一个字符（并比较），替换每一个字符（并比较），插入每一个字符（并比较）等方法，得到所有可能的字符串，然后检查只需一次编辑的字符串。该算法的运行时间过于缓慢，因此不用费尽心思来实现。 对于此类问题，思考一下每一种操作的“意义”大有裨益。两个字符串之间需要一次插入、替换或删除操作意味着什么？ **替换:**设想一下诸如bale和pale这样的两个字符串，它们之间相差一次替换操作。这确实意味着你可以通过替换bale中的一个字母来获得pale，但是更精确的说法是，这两个字符串仅在一个字符位置上有所不同。 **插入:**字符串apple和aple之间相差一次插入操作。这意味着，如果你对比两个字符串，会发现除了在字符串上的某一位置需要整体移动一次以外，它们是完全相同的。 **删除:**字符串apple和aple之间同样也可以表示为相差一次删除操作，因为删除操作只是“插入”的相反操作而已。 标准解答 1&#x2F;&#x2F;和我的解答基本相同，写的更漂亮 复杂度分析 该算法的时间复杂度为O(n)，n是较短字符串的长度（几乎所有合理的算法都为该时间复杂度）。为什么运行时间由较短的字符串决定而不是由较长的字符串决定呢？如果两个字符串长度相同（相差一个字符），那么使用较长的字符串或者较短的字符串定义时间复杂度均可。如果它们的长度大不相同，那么算法会在O(1)的时间内结束。因此，一个非常长的字符串不会极大地增加运行时间。只有当两个字符串都很长的时候，时间复杂度才会增加。 我们或许会注意到代码oneEditReplace和代码oneEditInsert相差无几。因此，可以将二者合并为一个方法。 标准解答（进阶） 12345678910111213141516171819202122232425262728bool oneEditAway(string first, string second)&#123; &#x2F;&#x2F;检查长度 if(Math.Abs(first.Length - second.Length) &gt; 1)&#123; return false; &#125; &#x2F;&#x2F;获取较长或较短字符串 string s1 &#x3D; first.Length &lt; second.Length ? first :second; string s2 &#x3D; first.Length &lt; second.Length ? second :first; int index1 &#x3D; 0; int index2 &#x3D; 0; bool foundDiff &#x3D; false; while(index2 &lt; s2.Length &amp;&amp; index1 &lt; s1.Length)&#123; if(s1[index1] !&#x3D; s2[index2])&#123; if(foundDiff)return false; foundDiff &#x3D; true; if(s1.Length &#x3D;&#x3D; s2.Length)&#123; index1++; &#125; &#125; else&#123; &#x2F;&#x2F;匹配的话才移动较短的指针 index1++; &#125; &#x2F;&#x2F;总是移动较长的指针 index2++; &#125; return true;&#125; 有些人或许会认为第一种方法更好，因为它更为清晰且更易理解。另外一些人则会认为第二种方法更好，因为该方法更加紧凑且重复代码更少（有助于代码的维护）。你并不需要站队，只需和面试官权衡利弊。 反思 思路基本相同，但是代码比我的漂亮多了。切记整洁代码的原则，少参数，少行数，数十行的行代码要分成多个方法。 提示：#23，#97，#130 -从容易的事情开始。你能分别检查一下每一个条件吗？ -“插入字符”选项和“删除字符”选项之间是何关系？这些需要分开检查吗？ -你能一次完成三次检查吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：PBR概述","slug":"问题精析：PBR概述","date":"2020-07-08T14:09:16.000Z","updated":"2020-07-12T11:01:04.584Z","comments":false,"path":"2020/07/08/问题精析：PBR概述/","link":"2020/07/08/问题精析：PBR概述","permalink":"http://ssssshinji.github.io/2020/07/08/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9APBR%E6%A6%82%E8%BF%B0/","excerpt":"","text":"PBR是近来一个新的，有意思的实时渲染方式。这个术语已经被传播得很广泛，但他的真实含义往往是混淆的。简单的回答是：这意味着很多。或者：这得看情况。这种回答并不能使人满意。所以我尝试着将PBR的真实含义，和它与传统的流程详细的解释清楚。这个文档主要是针对美术人员而非工程师。不会涉及数学或者代码类的东西。 PBR和传统流程最主要的区别在于他更详细和科学的还原了光照和物理表面的关系原理。他的纹理系统已经大大的进化。而旧的生产流程和近似的表达方式可以安全的抛弃了。这代表着无论是工程师还是美术工作人员都需要理解这些变化的动机在哪里。 我们需要从一些最基础的东西开始。这样我们可以在讲一些新东西之前对一些基本的概念有清楚的认识。你可能会觉得我讲的这些部分太枯燥乏味，但读过之后你会知道这些东西是值得的。你也可以了解一下Joe Wilson的文章：creating PBR artwork。 散射和反射(Diffusion and Reflection)) Diffusion和Reflection。也被叫做diffuse和specular。是描述光和物体表面互相作用的最基础的两个术语。很多人知道他们在实际应用中是怎么样的。但并不知道他们的物理原理是什么。 当光照射到物体的表面时，他会反射一部分，或者说反弹一部分。从表面的一边反弹到镜像的另一边。就像一个球打在地面上并弹起来一样。在光滑的表面上，会有像镜子一样的效果。单词specular，就是用来描述这种现象的。而specular正是拉丁语中镜子的意思。 然而并不是所有的光线都会从表面直接反射。有些光线会在进入被照射物体的内部。这些进入物体内部的光线有的会被物体吸收（往往会转变为热量消耗掉），而有些散射光线会在物体内散射后又从表面散射出去。然后被我们的肉眼或者摄像机看到。像diffuse，diffsion，3S（SSS）等都是表达的这个物理现象。 对不同波长的光，它的反射和吸收的量是差别很大的。这就让物体有了颜色（例子：如果白光照射在物体上，大部分的光线都被吸收掉了，而只反射出蓝色，那这个物体就是蓝色的）。这种散射是均匀而散乱的往各个向散射过去的。这和镜面反射完全不同。我们在shader上用albedo来表达这些散射颜色。Diffuse color是和这个同义的短语。 半透明和全透明(Translucency and Transparentcy) 有时候diffuse是蛮复杂的。在有些材质中，散射的距离会更广，更远。比如说像皮肤或者蜡这些材质。这时候用一个简单的颜色来表示是不够的。引擎会要计算物体的形状或者厚度。如果物体足够薄，就可以看到光从物体的背面照射出来（就好像光穿过人的手），这就是translucent（半透明）。如果散射更低，比如说玻璃，几乎所有的光线都直接穿过，以至于你可以看到背面的图像。这些属性都和“物体表面的散射”相去甚远。这时引擎需要一个单独的shader来模拟这些现象。 能量守恒(Energy Conservation) 有了这些描述后我们就有足够的信息去得到一个重要的结论：散射diffusion和反射reflection是相互排斥的（要么就散射，要么就反射）这也是传统光照模型所忽略的。。这是因为：如果光要散射，他就必须要在物体表面内传播，也就是不能反射。这就是照明系统中的“能量守恒定理”：从一个物体表面散射或反射的光线永远不会比原本照射他的光线要亮。 这很容易被引擎执行：在diffuse执行之前先把反射的那部分光线减去。这意味着高反射的物体的diffuse会很少很黑，因为大部分的光线都被反射掉了，几乎不能在物体的表面散射。下面这种守恒也是同样成立的：如果一个物体有非常亮的diffuse，那他也不会有什么反射。 这种能量守恒是PBR的一个重要的部分。这让艺术家能够基于物理的原理来调整albedo和reflective的值，而不是违背物理原理（这往往会看起来很low很糟糕）。虽然严格的执行这些规律和创造屌炸天的艺术作品并没有什么必然的联系。但它能起到一个“物理学保姆”（比喻）的角色。这能保护你的作品不会偏离规律太远。或者在不同的光照条件下得到前后矛盾的效果（不同光照下的表现相差很多）。 金属(Metals) 1.首先，导体（金属）会比绝缘体（非金属）的反射要高的多得多得多。导体一般会反射高达60－90%的光线，而绝缘体会少得多，一般在0-20%的范围内。这种高反射避免了光线进入到物体表面内部散射，给金属一种光亮的效果。 2.其次，导体的反射有时会在可见光谱中变化，这意味着他们的反射是有颜色倾向的。这种反射颜色在不同的导体上也是不同的。比如说：金，铜，黄铜，都是不一样的。而绝缘体不会有这种现象，他们的反射是不带颜色的 （一般是某种深度的灰色的）。 3.最后，导体一般会吸收没有反射的光线，而不是在表面散射。这个规律意味着金属是没有diffuse颜色的。但是注意：在现实情况中，金属表面会有一些物体（比如灰尘）和氧化物会产生一些固有色。（这里存疑，因为有的地方讲diffuse和固有色是同一个东西） 菲涅尔(Fresnel) 奥古斯丁菲涅尔第一个准确的描述了菲涅尔这个现象。如果我们要谈论光线的反射，那就绕不开这种现象。 在计算机图形学中，菲涅尔指的是在不同角度下，反射的变化现象。特别是：光在一个小掠角射到一个表面的反射会比垂直照射到一个表面要多得多。这意味着一个有着正确菲涅尔效果的物体，在它的边缘位置反射会比中间位置的反射会强很多。我们已经对这个效果很熟悉了，而在计算机图形学领域中，菲涅尔也不是一个新词。不过，PBR系统对菲涅尔方程式做了几个重要的修正。 首先，对所有的材质，在很小的角度看，反射都会很强烈。在极为边缘或者小角度的地方，任何材质都会反射得像一面镜子一样。是的，任何材质，只要平滑，并从对的角度观察，都会像是一面完美的镜子。这有违常理，不过实际上就是这样子的。 第二个有关于菲涅尔属性的结论是。不同的材质之间，菲涅尔曲线的变化差异并不大。金属的差异大一些，但也还是可以分析和记录的。 那这对于我们意味着，获得一个真实的效果。艺术家应该更少的控制菲涅尔属性，而不是更多的控制它。 这里有个关于菲涅尔效果的警告。在一个表面越粗糙的时候，菲涅尔效果会越不明显。下文会讲述更多的关于这方面的信息。 微表面(Microsurface) 以上对于反射（reflection）和漫反射（diffusion）的描述都是是基于物体表面朝向的。从一个正常的观察尺度来说，这种表面朝向是基于物体的形状的。而法线贴图也会在描述更加小一些的形状细节。渲染引擎能基于这些信息来渲染diffuse和reflection信息。 但是这里还有一个很大的部分被忽略掉了。大部分真实世界的表面都有很多不完美的地方：小凹槽，破损，小突起等细节。这些细节肉眼是看不到的。正常分辨率的法线贴图也不能体现这些小细节。虽然不能被肉眼看到，这种小细节仍然会对光的diffsion和reflection产生影响。 微表面的细节影响最显著的是反射 Specular（次表面散射影响不明显，所以我们不会在这里过多的讨论）。从上面的图我们可以看到平行光线照射到粗糙的表面后会分散的反射开来，因为每一束光和表面碰撞的方向都是不同的。我们用球碰墙的模拟，在一个类似于崖壁或者类似的不平整的表面：当球打到一个表面时，反弹的角度是不可预期的。简单的讲，越是粗糙的表面，越多的反射光线会分散，呈现一种模糊的效果。 可惜的是。定义每一个不同的微表面是不实际的。因为工作流程，内存控制，计算量都做不到。那么咋整呢？我们可以不用直接描述每一个不同的微表面。而是定义一个大概的粗糙程度。那样我们也可以获得一个十分接近而准确的效果。这种值往往叫做Gloss，Smoothness，或者Roughness。你可以通过贴图定义他们，或者给不同的材质定义不同的值。 微表面的细节是一个材质的重要组成部分。因为在实际生活中有大量的，广泛的，不同的微表面特征。光泽度贴图（gloss mapp）不是一个新的概念。但它还是在PBR渲染中扮演了重要的角色。因为微表面细节对光的反射有重大的影响。下面我们马上会讲到PBR系统对微表面属性的若干方面的提升。 守恒定律(包含微表面) 当我们将微表面细节纳入到我们的渲染模型，然后准确的散布反射光线。这时就必须正确地反射光线的量。遗憾的是，很多老的渲染引擎都把这个部分搞错了，基于微表面的粗糙度，不是反射过多就是反射过少。 当方程式准确平衡的时候，一个引擎需要将粗糙表面的高光变得模糊，而将光滑的表面的高光变得小而尖锐。在亮度上的不同表现关键在于：两种材质（光滑和粗糙）都会反射同等量的光线，不过粗糙的表面将它散射到不同的方向，而光滑的表面会变得更加的集中。（不改变反射率便可以使高光的亮度，大小发生改变） 微表面光泽度直接影响了反射亮度的表现。这意味着艺术家可以直接在光泽度贴图直接绘制不同的变化：划痕，凹痕，磨损，磨光，等等。于此同时PBR系统不仅会改变反射的样子，也会相应地改变亮度。再也不需要“spec蒙版”“反射贴图”变化了!（从而决定了PBR和传统渲染有很大程度上的区别） 这意义重大。因为这两个真实世界中的量是基于物理相关的——微表面细节和反射度——现在第一次在艺术领域和渲染流程中被准确地联系在了一起。这十分像我们之前讲的diffusion/reflection平衡：我们可以独立的制定两个独立的值，但一但我们将它们联系起来，区别它们就会变得更加的困难。 进一步说，显示世界中的材质的反射值的变化不会很大（参见之前我们讲的关于导体的部分）。一个很好的例子是水和泥巴。都有相似的反射率，但是泥巴是十分粗糙的，但它上面的积水却很光滑，它们因为反射性不同的原因而看起来十分的不一样。在PBR系统中，艺术家主要通过gloss或者roughness贴图来区别这种不同。而不是调节反射率：就像下面一样。 参考资料 1. 基于物理渲染（PBR）的基础理论","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题3：特定深度结点链表","slug":"问题3：特定深度结点链表","date":"2020-07-08T07:53:49.000Z","updated":"2020-07-08T11:23:44.105Z","comments":false,"path":"2020/07/08/问题3：特定深度结点链表/","link":"2020/07/08/问题3：特定深度结点链表","permalink":"http://ssssshinji.github.io/2020/07/08/%E9%97%AE%E9%A2%983%EF%BC%9A%E7%89%B9%E5%AE%9A%E6%B7%B1%E5%BA%A6%E7%BB%93%E7%82%B9%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目描述 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。（提示在页尾） 个人思路 题目只说创建没有说返回，则可以不考虑返回值。可以用BFS遍历所有节点但是怎么样和深度产生联系呢?即使写一个函数求出深度，也不知道怎么和节点联系起来 个人解答 1无解答 题目解析 乍一看，你可能会认为这个问题需要逐一遍历，但其实并无必要。可用任意方式遍历整棵树，只需记住节点位于哪一层即可。 我们可以将前序遍历算法稍作修改，将level+1传入下一个递归调用。下面是使用深度优先搜索的实现代码。 标准解答（DFS） 12345678910111213141516171819void createLevelLinkedList(TreeNode root, ArrayList lists, int level)&#123; if(root &#x3D;&#x3D; null) return; LinkedList&lt;TreeNode&gt; list &#x3D; null; if(lists.Count &#x3D;&#x3D; level)&#123; list &#x3D; new LinkedList&lt;TreeNode&gt;(); lists.Add(list); &#125;else&#123; list &#x3D; (LinkedList&lt;TreeNode&gt;)lists[level]; &#125; list.AddLast(root); createLevelLinkedList(root.left, lists, level+1); createLevelLinkedList(root.right, lists, level+1);&#125;&#x2F;&#x2F;包装函数ArrayList createLevelLinkedList(TreeNode root)&#123; ArrayList lists &#x3D; new ArrayList(); createLevelLinkedList(root,lists,0); return lists;&#125; 另一种做法是对广度优先搜索稍加修改，即从根节点开始迭代，然后第2层，第3层，以此类推。处于第i层时，则表明我们已访问过第i-1层的所有节点，也就是说，要得到i层的节点，只需直接查看i-1层节点的所有子节点即可。 标准解答（BFS） 1234567891011121314151617181920ArrayList createLevelLinkedList(TreeNode root, int level)&#123; if(root &#x3D;&#x3D; null) return null; ArrayList result &#x3D; new ArrayList(); LinkedList&lt;TreeNode&gt; list &#x3D; new LinkedList&lt;TreeNode&gt;(); list.AddLast(root); while(list.Count !&#x3D; 0)&#123; result.Add(list); LinkedList&lt;TreeNode&gt; parents &#x3D; list; list &#x3D; new LinkedList&lt;TreeNode&gt;(); foreach(TreeNode node in parents)&#123; if(node.left !&#x3D; null)&#123; list.AddLast(node.left); &#125; if(node.right !&#x3D; null)&#123; list.AddLast(node.right); &#125; &#125; &#125; return result;&#125; 复杂度分析 两者的时间复杂度皆为O(N)，那么空间效率呢？乍一看，我们可能会以为第二种解法的空间效率更高。在某种意义上，这么说也对。第一种解法会用到O(logN)次递归调用（在平衡树中），每次调用都会在栈里增加一级。第二种解法采用迭代遍历法，不需要这部分额外空间。不过，两种解法都要返回O(N)的数据，因此，递归实现所需的额外的O(logN)空间，跟必须传回的O(N)数据相比，并不算多。虽然第一种解法确实使用了较多的空间，但从大O记法的角度来看，两者效率是一样的。 反思 这种BFS的变形是我怎么也没想到了，再看了一遍后边回忆边写还是会出错。 提示：#107，#123，#135 -尝试修改图形搜索算法，从根开始追踪深度。 -从层号映射到该层节点的散列表或数组也许有些用处。 -你应该能够提出一个既包括深度优先搜索又包含广度优先搜索的算法。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"问题精析：透明物体渲染","slug":"问题精析：透明物体渲染","date":"2020-07-07T18:01:28.000Z","updated":"2020-07-07T18:25:11.619Z","comments":false,"path":"2020/07/08/问题精析：透明物体渲染/","link":"2020/07/08/问题精析：透明物体渲染","permalink":"http://ssssshinji.github.io/2020/07/08/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E9%80%8F%E6%98%8E%E7%89%A9%E4%BD%93%E6%B8%B2%E6%9F%93/","excerpt":"","text":"丢弃片段(Discard) 些图片并不需要半透明，只需要根据纹理颜色值，显示一部分，或者不显示一部分，没有中间情况。比如说草，如果想不太费劲地创建草这种东西，你需要将一个草的纹理贴在一个2D四边形(Quad)上，然后将这个四边形放到场景中。然而，草的形状和2D四边形的形状并不完全相同，所以你只想显示草纹理的某些部分，而忽略剩下的部分。 下面这个纹理正是这样的，它要么是完全不透明的（alpha值为1.0），要么是完全透明的（alpha值为0.0），没有中间情况。你可以看到，只要不是草的部分，这个图片显示的都是网站的背景颜色而不是它本身的颜色。 所以当添加像草这样的植被到场景中时，我们不希望看到草的方形图像，而是只显示草的部分，并能看透图像其余的部分。我们想要丢弃(Discard)显示纹理中透明部分的片段，不将这些片段存储到颜色缓冲中。在此之前，我们还要学习如何加载一个透明的纹理。 要想加载有alpha值的纹理，我们并不需要改很多东西，stb_image在纹理有alpha通道的时候会自动加载，但我们仍要在纹理生成过程中告诉OpenGL，我们的纹理现在使用alpha通道了： 1glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data); 同样，保证你在片段着色器中获取了纹理的全部4个颜色分量，而不仅仅是RGB分量： 1234567891011121314#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D texture1;void main()&#123; vec4 texColor &#x3D; texture(texture1, TexCoords); if(texColor.a &lt; 0.1) discard; FragColor &#x3D; texColor;&#125; 这里，我们检测被采样的纹理颜色的alpha值是否低于0.1的阈值，如果是的话，则丢弃这个片段。片段着色器保证了它只会渲染不是（几乎）完全透明的片段。 注意，当采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE。 混合 OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。 虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用混合(Blending)。和OpenGL大多数的功能一样，我们可以启用GL_BLEND来启用混合： 1glEnable(GL_BLEND); 启用了混合之后，我们需要告诉OpenGL它该如何混合。OpenGL中的混合是通过下面这个方程来实现的： $$ C_result=C_source∗F_source+C_destination∗F_destination $$ Csource：源颜色向量。这是源自纹理的颜色向量。 Cdestination：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。 Fsource：源因子值。指定了alpha值对源颜色的影响。 Fdestination：目标因子值。指定了alpha值对目标颜色的影响。 片段着色器运行完成后，并且所有的测试都通过之后，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。我们先来看一个简单的例子： 我们有两个方形，我们希望将这个半透明的绿色方形绘制在红色方形之上。红色的方形将会是目标颜色（所以它应该先在颜色缓冲中），我们将要在这个红色方形之上绘制这个绿色方形。 问题来了：我们将因子值设置为什么？嘛，我们至少想让绿色方形乘以它的alpha值，所以我们想要将Fsrc设置为源颜色向量的alpha值，也就是0.6。接下来就应该清楚了，目标方形的贡献应该为剩下的alpha值。如果绿色方形对最终颜色贡献了60%，那么红色方块应该对最终颜色贡献了40%，即1.0 - 0.6。所以我们将Fdestination设置为1减去源颜色向量的alpha值。这个方程变成了： $$ \\begin{pmatrix} 0.0 &amp; \\\\ 1.0 &amp; \\\\ 0.0 &amp; \\\\ 0.6 &amp; \\\\ \\end{pmatrix} * 0.6 + \\begin{pmatrix} 1 &amp; \\\\ 0 &amp; \\\\ 0 &amp; \\\\ 1 &amp; \\\\ \\end{pmatrix} * (1-0.6) $$ 结果就是重叠方形的片段包含了一个60%绿色，40%红色的一种脏兮兮的颜色： 最终的颜色将会被储存到颜色缓冲中，替代之前的颜色。 glBlendFunc(GLenum sfactor, GLenum dfactor)函数接受两个参数，来设置源和目标因子。OpenGL为我们定义了很多个选项。 半透明物体遮挡问题 最前面窗户的透明部分遮蔽了背后的窗户？这为什么会发生呢？ 深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。 所以我们不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题了。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，我们需要首先绘制背后的这部分窗户。这也就是说在绘制的时候，我们必须先手动将窗户按照最远到最近来排序，再按照顺序渲染。 注意，对于草这种全透明的物体，我们可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）。 要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下： 1.先绘制所有不透明的物体。 2.对所有透明的物体排序。 3.按顺序绘制所有透明的物体。(从远到近，右手坐标系来说是-z到+z) 参考资料 1. 混合","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题3：删除中间节点","slug":"问题3：删除中间节点","date":"2020-07-07T16:46:15.000Z","updated":"2020-07-07T17:17:00.831Z","comments":false,"path":"2020/07/08/问题3：删除中间节点/","link":"2020/07/08/问题3：删除中间节点","permalink":"http://ssssshinji.github.io/2020/07/08/%E9%97%AE%E9%A2%983%EF%BC%9A%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目描述 实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。示例：（提示在页尾） 示例： 12输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c结果：不返回任何数据，但链表变为a-&gt;b-&gt;d-&gt;e-&gt;f 个人思路 删除操作需要知道被删除节点前面和后面的两个节点。由题意可知是单向链表，只能得知后面的节点。如果链表长度已知，则可以记录该节点之后的节点数目，长度减去该数目，可以计算出前面的节点。不过要求输入的参数为单个节点c，如何知道c和链表之间，头节点之间的联系呢？百思不得 个人解答 1无思路 题目解析 在这个问题中，你访问不到链表的首节点，只能访问那个待删除节点。解法很简单，直接将后继节点的数据复制到当前节点，然后删除这个后继节点。 标准解答 123456789 void DeleteMidNode(LinkedListNode&lt;T&gt; node)&#123; if(node &#x3D;&#x3D; null || null.next &#x3D;&#x3D; null)&#123; return false; &#125; LinkedListNode&lt;T&gt; next &#x3D; node.next; node.data &#x3D; next.data; node.next &#x3D; next.next; &#125;&#125; 复杂度分析 O(1)。 反思 思考的时候是从list的api入手的，只想着如何得到前一个结点。思维太固化了，应该还是积累不够的原因。 提示：#72 -列出清单1-&gt; 5-&gt; 9-&gt; 12。删除9会使它看起来像1-&gt; 5-&gt; 12。你只能访问9节点。你能让它看起来像正确的答案吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"问题精析：View矩阵的推导","slug":"问题精析：View矩阵的推导","date":"2020-07-06T16:48:32.000Z","updated":"2020-07-06T17:48:05.359Z","comments":false,"path":"2020/07/07/问题精析：View矩阵的推导/","link":"2020/07/07/问题精析：View矩阵的推导","permalink":"http://ssssshinji.github.io/2020/07/07/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AView%E7%9F%A9%E9%98%B5%E7%9A%84%E6%8E%A8%E5%AF%BC/","excerpt":"","text":"概念 观察空间(view space)也被称为摄像机空间，在观察空间中，摄像机位于原点，它决定了我们渲染游戏所使用的视角。前面说过，观察空间采用的是右手坐标系，所以+z轴指的是摄像机后方。（摄像机看着-z。unity和OpenGL都采用这种右手坐标系。顺带一提，unity里除了观察空间，都是左手坐标系。OpenGL则是除了NDC，都是右手坐标系。）顶点变化的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换叫观察变换(view transform)。 为了得到顶点在观察空间的位置，我们可以有两种方法。 一种方法是计算观察空间的三个坐标轴在世界空间的表示，然后按照“坐标空间的变换”的方法算出观察空间到世界空间的变换矩阵，再求逆得住世界空间到观察空间的变换矩阵。 第二种方法是平移整个观察空间，让摄像机原点位于世界空间原点，坐标轴与世界空间坐标轴重合。两种方法得到的变换矩阵是一样的。(一般采取第二种，比较直观) 第一种方法 UVN系统：本身是一个基。如下图所示，三个基向量U，V，N分别指向相机的右方、上方和后方从而构成右手坐标系，相机则处于坐标原点。 在参考系下（这里是世界坐标系），我们给定相机的位置——eye，被观察的小人的位置——lookat，以及一个辅助向量——参考系中表示“上方”的向量up，这个向量会影响U和V的生成，因为以后求出的V向量会在up和N向量所决定的平面上，所以可以通过这个向量让相机产生不同的偏转。 首先我们求出向量\\vec {N}： $$ \\vec {N} = lookat - eye $$ 然后，我们求出向量\\vec {U}。这一步需要使用辅助向量up，如果不希望相机产生偏转，一般取(0, 1, 0)： $$ \\vec {U} = \\vec {up} \\times \\vec {N}; $$ U使用向量的叉乘实现。最后，使用N和U计算出向量\\vec {V}： $$ \\vec {V} = \\vec {N} \\times \\vec {U}; $$ 按照“坐标空间的变换”的方法进行坐标系转换，并配合平移矩阵，便得到了观察矩阵。 第二种方法 要理解这个方法，重要的一点是，想象摄像机和场景中的每个物体都有一根棍子连接在一起，所谓的平移整个观察空间，是指摄像机带动场景内的物体一起移动，直到摄像机移动到坐标原点（屏幕中央），这时我们看到的屏幕就是摄像机的视角了。 举例：摄像机在世界空间中的变换是按(30,0,0)进行旋转，然后按(0,10,-10)进行了平移。那么，为了把摄像机重新移动回初始状态。（指原点位于世界坐标的原点，坐标轴和世界空间的坐标轴重合）我们需要进行逆向变换，即先按(0，-10，10)平移，以便摄像机回到原点，再按(-30,0,0)进行旋转，以便让坐标轴重合。因此，变换矩阵就是： $$ \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; cos\\theta &amp; -sin\\theta &amp; 0 \\\\ 0 &amp; sin\\theta &amp; cos\\theta &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\end{pmatrix} \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; 0 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{pmatrix} $$ 如果在unity中，因为左右手坐标系的变化，还需要对z轴取负。 $$ \\begin{pmatrix} 1 &amp; 0 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; 0 &amp; t_y \\\\ 0 &amp; 0 &amp; -1 &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\\\ \\end{pmatrix} $$ 参考资料 1. Unity Shader 入门精要 冯乐乐著 2. JungHyun Han - 3D Graphics for Game Programming-CRC Press (2011) 2. 观察矩阵推导","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题4：回文排列","slug":"问题4：回文排列","date":"2020-07-06T15:33:45.000Z","updated":"2020-07-06T16:48:09.065Z","comments":false,"path":"2020/07/06/问题4：回文排列/","link":"2020/07/06/问题4：回文排列","permalink":"http://ssssshinji.github.io/2020/07/06/%E9%97%AE%E9%A2%984%EF%BC%9A%E5%9B%9E%E6%96%87%E6%8E%92%E5%88%97/","excerpt":"","text":"题目描述 给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。 示例： 12输入:Tact Coa输出:True(排列有&quot;taco cat&quot;,&quot;atco cta&quot;,等等) 个人思路 和判断是否为回文字符串的题目有所区别，这道题的范围更广，要分辨其是否能重新排列成回文字符串。也可以利用数组，记录每个字符的出现次数，应该都是偶数次或者有一个为奇数次。 个人解答 1234567891011121314bool IsPermutationOfPalindrome(string str)&#123; char [] charSet &#x3D; new char[128]; for(int i &#x3D; 0; i &lt; str.Length; i++)&#123; charSet[str[i]] ++; &#125; int count &#x3D; 0; for(int i &#x3D; 0; i &lt; charSet.Length;i++)&#123; if(charSet[i]%2 &#x3D;&#x3D; 1)&#123; count ++; &#125; if(count &gt; 1)return false; &#125; return true;&#125; 题目解析 怎样才能给出一个正、反两个方向都一致的字符序列呢？对于大多数的字符，都必须出现偶数次，这样才能使得其中一半构成字符串的前半部分，另一半构成字符串的后半部分。至多只能有一个字符（即中间的字符）可以出现奇数次。例如，我们知道tactcoapapa是一个回文排列，因为该字符串有2个t、4个a、2个c、2个p以及1个o，其中o将会成为潜在的回文串的中间字符。 更准确地说，所有偶数长度的字符串（不包括非字母字符）所有的字符必须出现偶数次。奇数长度的字符串必须刚好有一个字符出现奇数次。当然，偶数长度的字符串不可能只包括一个出现奇数次的字符，否则其不会为偶数长度（一个出现奇数次的字符+若干个出现偶数次的字符=奇数个字符）。以此类推，奇数长度的字符串不可能所有的字符都出现偶数次（偶数的和仍然是偶数）。因此我们可以得知，一个回文串的排列不可能包含超过一个“出现奇数次的字符”。该推论同时涵盖了奇数长度和偶数长度字符串的例子。 标准解答 1234567891011121314&#x2F;&#x2F;和我的解答基本相同，多了对大小写的不敏感&#x2F;&#x2F;检查奇数个数的方法写的更简洁bool checkMaxOneOdd(int[] charSet)&#123; bool foundOdd &#x3D; false; foreach(int count in charSet)&#123; if(count % 2 &#x3D;&#x3D; 1)&#123; if(foundOdd)&#123; return false; &#125; foundOdd &#x3D; true; &#125; &#125; return true;&#125; 复杂度分析 O(n)。 解法2：任何算法都要遍历整个字符串，因此，无法对时间复杂度再进行优化，但可稍作优化。因为该题目相对简单，所以有必要对其稍作优化或调整。可以在遍历的同时检查是否有字符只出现了奇数次，而不需要在遍历结束时再进行检查。因此，在一次遍历结束时，我们即有了答案。 标准解答 1234567891011121314bool IsPermutationOfPalindrome(string str)&#123; int countOdd &#x3D; 0; int[] table &#x3D; new int[(int)(Char.GetNumericValue(&#39;z&#39;) - Char.GetNumericValue(&#39;a&#39;)+1)]; foreach(char c in str.ToCharArray())&#123; int x &#x3D; getCharNumber(c);&#x2F;&#x2F;使大小写不敏感的函数 if(x !&#x3D; -1)&#123; table[x]++; if(table[x] % 2 &#x3D;&#x3D; 1)&#123; countOdd++; &#125;else&#123;countOdd--;&#125; &#125; &#125; return countOdd &lt;&#x3D; 1;&#125; 需要清楚说明的是，该算法并不一定更优。该算法有着相同的时间复杂度，而且可能还会稍慢一些。我们最终没有遍历散列表，但是对于单个字符加入了几行额外的代码。你应该将该算法作为备选项而非最优解与面试官进行讨论。 解法3:如果你能更深入地思考该问题，或许会注意到字符出现的个数无关紧要。重要的是，字符出现是偶数次还是奇数次。你可以将其想象为开灯与关灯的操作（初始状态下灯是关着的）。如果灯最后是关闭状态，并不需要知道对其进行了多少次的开关操作，只需知道操作的次数是偶数次的。 因此，可以在本题中使用一个整数数值（或者位向量）。每当看到一个字符，就将其映射到0与26之间的一个数值（假设所有字符都是英语字母），然后切换该数值对应的比特位。在遍历结束后，需要检查是否最多只有一个比特位被置为1。 判断整数数值中没有比特位为1易如反掌，只需将整数数值与0进行比较。判断整数数值中是否刚好有一个比特位为1，则有一个很巧妙的办法。 例如有一个整数数值00010000。我们当然可以通过重复的移位操作判断是否只有一个比特位为1。另一种方法是，如果将该数字减1，则会得到00001111。可以发现，这两个数字之间比特位没有重叠（而对于00101000，将其减1会得到00100111，比特位发生了重叠）。因此，判断一个数是否刚好有一个比特位为1，可以通过将其减1的结果与该数本身进行与操作，如果其结果为0，则比特位中1刚好出现一次。 反思 对算法的优化以及位运算还不是很熟悉。 提示：#106，#121，#134，#136 -不必且也不应该生成所有的排列。这将极为低效。 -作为回文排列的字符串有什么特征？ -你试过散列表吗？你应该能把它降到O(N)的时间。 -使用位向量可以减少空间使用吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：Mipmap","slug":"问题精析：Mipmap","date":"2020-07-05T18:08:36.000Z","updated":"2020-07-05T18:17:48.009Z","comments":false,"path":"2020/07/06/问题精析：Mipmap/","link":"2020/07/06/问题精析：Mipmap","permalink":"http://ssssshinji.github.io/2020/07/06/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AMipmap/","excerpt":"","text":"概念 想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。 OpenGL使用一种叫做**多级渐远纹理(Mipmap)**的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的： 手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。 在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式： 过滤方式 描述 GL_NEAREST_MIPMAP_NEAREST 使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样 GL_LINEAR_MIPMAP_NEAREST 使用最邻近的多级渐远纹理级别，并使用线性插值进行采样 GL_NEAREST_MIPMAP_LINEAR 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样 GL_LINEAR_MIPMAP_LINEAR 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。 GL_TEXTURE_MIN_FILTER方式下，param有6种:不过上述4种都必须定义了Mipmap才能使用 如何选择合适的mipmap层？ 计算一个像素与其所覆盖的纹理区域的面积比例（取x,y方向上的最大缩放值），由此选定mipmap层。 如何生成Mipmap纹理？ 可以自己程序来生成，或者: 1.自己调用gluScaleImage()来逐级生成； 2.然后通过glTexImage2D(GLenum target,GLint level,…);进行加载 OpenGL3.0及以后，可使用glGenerateMipmap(GLenum target)来生成当前纹理的mipmap。也就是将mipmap从glu库中提到了核心库中！（现在常用此方法） Mipmap存在的问题 如果覆盖区域非常狭长，与正方形相差较大，效果不好。 克服方法：各向异性滤波 非均向性（anisotropy),或作各向异性，与各向同性相反，指问题的全部或部分物理、化学等性质方向的不同而有所变化的特性，例如石墨单晶的电导率在不同方向的差异可达到数千倍，又如天文学上，宇宙微波背景辐射亦拥有些微的非均向性。许多的物理量都具有非均向性，如弹性模量、点导率、在酸中的溶解速度等。 各向异性扩散滤波主要是用来平滑图像的，克服了高斯模糊的缺陷，各向异性扩散在平滑图像时是保留图像边缘的，和双边滤波很像。 参考资料 1. 纹理 2. 《图形编程技术学习》（五十一）Mipmap","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：URL编码规则与规范","slug":"问题精析：URL编码规则与规范","date":"2020-07-05T17:02:43.000Z","updated":"2020-07-05T17:59:47.185Z","comments":false,"path":"2020/07/06/问题精析：URL编码规则与规范/","link":"2020/07/06/问题精析：URL编码规则与规范","permalink":"http://ssssshinji.github.io/2020/07/06/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AURL%E7%BC%96%E7%A0%81%E8%A7%84%E5%88%99%E4%B8%8E%E8%A7%84%E8%8C%83/","excerpt":"","text":"为什么要编码？ **通常如果一样的东西需要编码，就说明这样的东西并不适合传输。**URL只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。 RFC 1738 规定 &quot;…Only alphanumerics [0-9a-zA-Z], the special characters &quot;$-.+!*'(),&quot; [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.&quot; “只有字母和数字[0-9a-zA-Z]、一些特殊符号“$-.+!*'(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。” (RFC3986文档规定，URL中只允许包含英文字母（a-zA-Z）、数字（0-9）、- _ . ~4个特殊字符以及所有的保留字符。) 这意味着如果URL存在汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致“URL编码”成为了一个混乱的领域。(之后详述) 另一方面，如果我的参数值中就包含=或者&amp;这样的特殊子字符的时候，该怎么办。比如说“name1=value1”,其中value1的值是“va&amp;lu=e1”，那么在传输过程中就会变成“name1=va&amp;lu=e1”。用户传输的本意是只有一个键值对，但是服务器端会解析成两个键值对，这样就自然的产生了歧义。 为了解决上述问题，我们就需要对URL进行编码。 URL 是如何编码的？ URL 编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。 URL编码只是简单的在特殊字符的各个字节（16进制）前加上”%”即可。例如，我们对上述会产生歧义的字符进行编码后的结果：name1=va%26lu%3D，这样服务器会把紧跟在”%”后的字节当成普通的字节，不会把它当成各个参数或键值对的分隔符。 首先需要把该字符的 ASCII 的值表示为两个16进制的数字，然后在其前面放置转义字符(“%”)，置入 URL 中的相应位置。(对于非 ASCII 字符, 需要转换为 UTF-8(或其他编码方式) 字节序, 然后每个字节按照上述方式表示。) 另外一个问题是，为什么要用ASCII码传输，可不可以用别的编码？ 当然可以用别的编码，你可以自己开发一套编码然后自己进行解析。就像大部分国家都有自己的语言一样。但是国家之间要怎么进行交流呢，用英语吧，英语的使用范围最广。 URL编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符 哪些字符需要编码？ US-ASCII字符集中没有对应的可打印字符 URL中只允许使用可打印的字符。US-ASCII码中的10-7F字节全都表示控制字符，这些字符不能直接出现在URL中。同时对于80-FF字节，由于已经超出了ASCII码定义字符的范围，因此也不能放在URL中。 保留字符:RFC3986中指定了以下字符为保留字符： ！ * ’ ( ) ; : @ &amp; = + $ , / ? # [ ] URL可以划分为干了组件，协议、主机、路径等。有一些字符（： / ? # [ ] @）是用作分隔不同组件的。例如：冒号用于分隔协议和主机组件，斜杠用于分隔主机和路径，问号用于分隔路径和查询参数，等等。还有一些字符（! $ &amp; * + , ; =）用于在每个组件中起到分隔作用，如等号用于表示查询参数中的键值对，&amp;符号用于分隔查询多个键值对。当组件中的普通数据包含这些特殊字符时，需要对其进行编码。 不安全字符 还有一些字符，当他们直接放在URL中的时候，可能会引起解析程序的歧义。这些字符被视为不安全的字符，原因有很多。 空格：URL在传输的过程，或者用户在排版的过程中，或者文本处理程序在处理URL的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。 引号 以及 &lt;&gt;：引号和尖括号通常用于在普通文本中起到分隔URL的作用。 #：通常用于表示书签或者锚点。 %：百分号本身用作对不安全的字符进行编码是使用的特殊字符，因此本身需要编码。 { } | \\ ^ [ ] ’ ~：某一些网关或者传输代理会篡改这些字符 空格编码问题 一个URL的基本组成部分包括协议(scheme),域名，端口号，路径和查询字符串（路径参数和锚点标记就暂不考虑了）。路径和查询字符串之间用问号?分离。例如http://www.example.com/index?param=1，路径为index，查询字符串(Query String)为param=1。URL中关于空格的编码正是与空格所在位置相关：空格被编码成加号+的情况只会在查询字符串部分出现，而被编码成%20则可以出现在路径和查询字符串中。 造成这种混乱局面的原因在于：W3C标准规定，当Content-Type为application/x-www-form-urlencoded时，URL中查询参数名和参数值中空格要用加号+替代，所以几乎所有使用该规范的浏览器在表单提交后，URL查询参数中空格都会被编成加号+。而在另一份规范(RFC 2396，定义URI)里, URI里的保留字符都需转义成%HH格式(Section 3.4 Query Component)，因此空格会被编码成%20，加号+本身也作为保留字而被编成%2B，对于某些遵循RFC 2396标准的应用来说，它可能不接受查询字符串中出现加号+，认为它是非法字符。所以一个安全的举措是URL中统一使用%20来编码空格字符。 Java中的URLEncoder本意是用来把字符串编码成application/x-www-form-urlencoded MIME格式字符串，也就是说仅仅适用于URL中的查询字符串部分，但是URLEncoder经常被用来对URL的其他部分编码，它的encode方法会把空格编成加号+，与之对应的是，URLDecoder的decode方法会把加号+和%20都解码为空格，这种违反直觉的做法造成了当初我对空格URL编码问题的困扰。因此后来我的做法都是，在调用URLEncoder.encode对URL进行编码后(所有加号+已被编码成%2B)，再调用replaceAll(“\\+”, “%20″)，将所有加号+替换为%20。 中文编码问题 如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致“URL编码”成为了一个混乱的领域。 下面就让我们看看，“URL编码”到底有多混乱。我会依次分析四种不同的情况，在每一种情况中，浏览器的URL编码方法都不一样。把它们的差异解释清楚之后，我再说如何用Javascript找到一个统一的编码方法。 情况1：网址路径中包含汉字 打开IE（我用的是8.0版），输入网址“http://zh.wikipedia.org/wiki/春节 ”。注意，“春节”这两个字此时是网址路径的一部分。查看HTTP请求的头信息，会发现IE实际查询的网址是“http://zh.wikipedia.org/wiki/春节 ”。也就是说，IE自动将“春节”编码成了“%E6%98%A5%E8%8A%82”。 我们知道，“春”和“节”的utf-8编码分别是“E6 98 A5”和“E8 8A 82”，因此，“%E6%98%A5%E8%8A%82”就是按照顺序，在每个字节前加上%而得到的。 结论1就是，网址路径的编码，用的是utf-8编码。 情况2：查询字符串包含汉字 在IE中输入网址“http://www.baidu.com/s?wd=春节 ”。注意，“春节”这两个字此时属于查询字符串，不属于网址路径，不要与情况1混淆。查看HTTP请求的头信息，会发现IE将“春节”转化成了一个乱码。切换到十六进制方式，才能清楚地看到，“春节”被转成了“B4 BA BD DA”。 我们知道，“春”和“节”的GB2312编码（我的操作系统“Windows XP”中文版的默认编码）分别是“B4 BA”和“BD DA”。因此，IE实际上就是将查询字符串，以GB2312编码的格式发送出去。“%E6%98%A5%E8%8A%82”就是按照顺序，在每个字节前加上%而得到的。Firefox的处理方法，略有不同。它发送的HTTP Head是“wd=%B4%BA%BD%DA”。也就是说，同样采用GB2312编码，但是在每个字节前加上了%。 结论2就是，查询字符串的编码，用的是操作系统的默认编码。 情况3：Get方法生成的URL包含汉字 前面说的是直接输入网址的情况，但是更常见的情况是，在已打开的网页上，直接用Get或Post方法发出HTTP请求。 根据台湾中兴大学吕瑞麟老师的试验 ，这时的编码方法由网页的编码决定，也就是由HTML源码中字符集的设定决定。 1&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=xxxx\"&gt; 如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。举例来说，百度是GB2312编码，Google是UTF-8编码。因此，从它们的搜索框中搜索同一个词“春节”，生成的查询字符串是不一样的。 结论3就是，GET和POST方法的编码，用的是网页的编码。 情况4：Ajax调用的URL包含汉字 前面三种情况都是由浏览器发出HTTP请求，最后一种情况则是由Javascript生成HTTP请求，也就是Ajax调用。还是根据吕瑞麟老师的文章，在这种情况下，IE和Firefox的处理方式完全不一样。 举例来说，有这样两行代码： 12url &#x3D; url + &quot;?q&#x3D;&quot; +document.myform.elements[0].value; &#x2F;&#x2F; 假定用户在表单中提交的值是“春节”这两个字http_request.open(&#39;GET&#39;, url, true); 那么，无论网页使用什么字符集，IE传送给服务器的总是“q=%B4%BA%BD%DA”，而Firefox传送给服务器的总是“q=%E6%98 %A5%E8%8A%82”。也就是说，在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。这就是我们的结论4。 参考资料 1. URL 如何编码解码？为什么要编码？ 2. 为什么要进行URL编码 3. 关于URL编码 对空格的处理问题 4. URL中文编码问题","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"问题2：返回倒数第k个节点","slug":"问题2：返回倒数第k个节点","date":"2020-07-05T15:51:27.000Z","updated":"2020-07-05T17:00:59.821Z","comments":false,"path":"2020/07/05/问题2：返回倒数第k个节点/","link":"2020/07/05/问题2：返回倒数第k个节点","permalink":"http://ssssshinji.github.io/2020/07/05/%E9%97%AE%E9%A2%982%EF%BC%9A%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目描述 返回倒数第k个节点。实现一种算法，找出单向链表中倒数第k个节点。（提示在页尾） 个人思路 经典双指针问题。 个人解答 123456789101112131415Node FindLast_Kth(List list,int k)&#123; if(list.Length &lt; k)&#123; return null; &#125; Node first &#x3D; list.head; Node second &#x3D; list.head; for(int i &#x3D; 0; i &lt; k; i++)&#123; first &#x3D; first.next; &#125; while(first.next !&#x3D; null)&#123; first &#x3D; first.next; second &#x3D; second.next; &#125; return second;&#125; 题目解析 下面会以递归和非递归的方式解决这个问题。一般来说，递归解法更简洁，但效率低下。例如，就这个问题来说，递归解法的代码量大概只有迭代解法的一半，但要占用O(n)的空间，其中n为链表中节点个数。 注意，在下面的解法中，k定义如下：传入k=1将返回最后一个节点，k=2返回倒数第二个节点，以此类推。当然，也可以将k定义为k=0返回最后一个节点。 解法1：链表长度已知 若链表长度已知，那么，倒数第k个节点就是第(length - k)个节点。直接迭代访问链表就能找到这个节点。不过，这个解法太过简单了，不大可能是面试官想要的答案。 解法2：递归 这个算法会递归访问整个链表，当抵达链表末端时，该方法会回传一个设置为0的计数器。之后的每次调用都会将这个计数器加1。当计数器等于k时，表示我们访问的是链表倒数第k个元素。 实现代码简洁明了，前提是我们要有办法通过栈“回传”一个整数值。可惜，无法用一般的返回语句回传一个节点和一个计数器，那该怎么办？ 方法A:不返回该元素 一种方法是对这个问题略作调整，只打印倒数第k个节点的值。然后，直接通过返回值传回计数器值。 标准解答 12345678910int printKthToLast(Node head, int k)&#123; if(head &#x3D;&#x3D; null)&#123; return 0; &#125; int index &#x3D; printKthToLast(head.next, k)+1; if(index &#x3D;&#x3D; k)&#123; System.Console.WriteLine(k+&quot;th to last node is&quot; + head.data); &#125; return index;&#125; 当然，只有得到面试官的首肯，这个解法才算有效。 方法B:使用C++ 另一种方法是使用C++，并通过引用传值。这样一来，就可以返回节点值，而且也能通过传递指针更新计数器。 方法C:使用包裹类 前面提到，这里的难点在于无法同时返回计数器和索引值。如果用一个简单的类（或一个单元素数组）包裹计数器值，就可以模仿如何通过引用传递。 标准解答 12345678910111213141516class Index&#123; public int value &#x3D; 0;&#125;Node kthTolast(Node head, int k)&#123; Index idx &#x3D; new Index(); return kthTolast(head,k,idx);&#125;Node kthTolast(Node head, int k, Index idx)&#123; if(head &#x3D;&#x3D; null) return null; Node node &#x3D; kthTolast(head.next,k,idx); idx.value &#x3D; idx.value + 1; if(idx.value &#x3D;&#x3D; k)&#123; return head; &#125; return node;&#125; 因为有递归调用，这些递归解法都需要占用O(n)的空间。 解法3：迭代 同个人思路。 反思 这次有记得处理边界情况。不过因为遇到过类似的题，没有去思考有没有别的做法。递归的解法又给了我一些启发。 提示：#8，#25，#41，#67，#126 -如果你知道链表大小，会怎么样？找到最后第k个元素和找到第x个元素有何区别？ -如果你不知道链表的大小，你能计算它吗？这将如何影响运行时间？ -尝试用递归法实现。如果你能找到(k-1)到最后一个元素，可以找到第k个元素吗？ -你可能会发现返回多个值大有用处。有些语言不直接支持这一点，但基本上使用任何语言都有解决方法。这些解决方法有哪些？ -你能通过递归做到吗？想象一下，如果有两个指针指向相邻节点，它们通过链表以相同的速度移动。当一个到达链表的结尾时，另一个在哪里？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"问题3：URL化","slug":"问题3：URL化","date":"2020-07-05T05:42:41.000Z","updated":"2020-07-05T15:44:32.698Z","comments":false,"path":"2020/07/05/问题3：URL化/","link":"2020/07/05/问题3：URL化","permalink":"http://ssssshinji.github.io/2020/07/05/%E9%97%AE%E9%A2%983%EF%BC%9AURL%E5%8C%96/","excerpt":"","text":"题目描述 编写一种方法，将字符串中的空格全部替换为%20。假定该字符串尾部有足够的空间存放新增字符，并且知道字符串的“真实”长度。（注：用Java实现的话，请使用字符数组实现，以便直接在数组上操作。） 示例： 12输入:&quot;Mr John Smith &quot;,13输出:&quot;Mr%20John%20Smith&quot; 个人思路 主要的是知道URL编码的转换规则，以及对一些特殊字符的转义处理。 个人解答 1无思路 题目解析 处理字符串操作问题时，常见做法是从字符串尾部开始编辑，从后往前反向操作。该做法是上佳之选，因为字符串尾部有额外的缓冲，可以直接修改，不必担心会覆写原有数据。 我们将采用上面这种做法。该算法会进行两次扫描。第一次扫描先数出字符串中有多少空格，从而算出最终的字符串长度。第二次扫描才真正开始反向编辑字符串。如果检测到空格，就将%20复制到下一个位置；若不是空格，就复制原先的字符。 标准解答 123456789101112131415161718192021222324public static void replaceSpaces(char[] str, int trueLength)&#123; int spaceCount &#x3D; 0,index &#x3D; 0,i; for(i &#x3D; 0;i&lt;trueLength;i++)&#123; if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123; spaceCount++; &#125; &#125; index &#x3D; trueLength + 2*spaceCount; char[] result &#x3D; new char[index]; for(i &#x3D; trueLength - 1; i &gt;&#x3D; 0; i--)&#123; System.Console.WriteLine(&quot;index:&quot; + index); System.Console.WriteLine(&quot;i:&quot; + i); if(str[i] &#x3D;&#x3D; &#39; &#39;)&#123; result[index - 1] &#x3D; &#39;0&#39;; result[index - 2] &#x3D; &#39;2&#39;; result[index - 3] &#x3D; &#39;%&#39;; index &#x3D; index - 3; &#125;else&#123; result[index - 1] &#x3D; str[i]; index--; &#125; System.Console.WriteLine(result); &#125;&#125; 复杂度分析 O(n)。 反思 忽略了在进行编码后数组长度会有所改变。不过原书算法好像有点问题，偶尔会数组溢出，这里为自己写的版本。顺便一提c#中string和char[]做参数的区别: 用string[]表示字符串中相应位置的字符时，仅可读，而char[]是可读写的。并且string和char[]在形参中不能互相转换，要利用string.ToCharArray()和char[].ToString()。 提示：#53，#118 -从尾到头开始修改字符串通常最容易。 -你可能需要知道空格的数量。你能数一下吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：OpenGL纹理采样模式","slug":"问题精析：OpenGL纹理采样模式","date":"2020-07-03T14:09:53.000Z","updated":"2020-07-05T17:07:37.234Z","comments":false,"path":"2020/07/03/问题精析：OpenGL纹理采样模式/","link":"2020/07/03/问题精析：OpenGL纹理采样模式","permalink":"http://ssssshinji.github.io/2020/07/03/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9AOpenGL%E7%BA%B9%E7%90%86%E9%87%87%E6%A0%B7%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"背景及概念 我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。艺术家和程序员更喜欢使用纹理(Texture)。纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。 为了能够把纹理映射(Map)到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。 纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。 我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。 对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉OpenGL该怎样对纹理采样。 纹理环绕方式 环绕方式 描述 GL_REPEAT 对纹理的默认行为。重复纹理图像。 GL_MIRRORED_REPEAT 和GL_REPEAT一样，但每次重复图片是镜像放置的。 GL_CLAMP_TO_EDGE 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。 GL_CLAMP_TO_BORDER 超出的坐标为用户指定的边缘颜色。 前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t（如果是使用3D纹理那么还有一个r）它们和x、y、z是等价的）： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT); 第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是WRAP选项，并且指定S和T轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。 如果我们选择GL_CLAMP_TO_BORDER选项，我们还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值： 12float borderColor[] &#x3D; &#123; 1.0f, 1.0f, 0.0f, 1.0f &#125;;glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor); 纹理过滤 纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。 Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素；注意不要和纹理坐标搞混，纹理坐标是你给模型顶点设置的那个数组，OpenGL以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色。 GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色： GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色： GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。 当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似： 12glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR); 参考资料 1. 纹理","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题精析：递归和迭代","slug":"问题精析：递归和迭代","date":"2020-07-03T10:12:32.000Z","updated":"2020-07-05T17:07:45.617Z","comments":false,"path":"2020/07/03/问题精析：递归和迭代/","link":"2020/07/03/问题精析：递归和迭代","permalink":"http://ssssshinji.github.io/2020/07/03/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3/","excerpt":"","text":"递归(recursion) 简而言之就是一种函数调用函数自身来完成算法设计的方法。是把问题转化为规模缩小了的同类问题的子问题。然后递归调用函数（或过程）来表示问题的解。 递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。 递归的标准模式（有可对函数的入口进行测试的基本情况） 1234if (条件) return (不需要递归的简单答案);else return (递归调用同一函数)； - 必须有递归终止的条件。 - 函数决定终止的参数有规律地递增或递减。 在数据结构中，链表和二叉树都具备鲜明的递归特性。 直接递归 也即是普通递归，单向递归，线性递归函数的最后一步操作不是递归操作，而是其他的操作。当数据量很大的时候，会造成栈溢出，这是因为，在每次递归调用时，递归函数中的参数，局部变量等都要保存在栈中，如果数据量很大的话，便可能会溢出。 尾递归 也即是线性迭代，尾递归函数的最后一步操作是递归，也即在进行递归之前，把全部的操作先执行完，这样的好处是，不用花费大量的栈空间来保存上次递归中的参数、局部变量等，这是因为上次递归操作结束后，已经将之前的数据计算出来，传递给当前的递归函数，这样上次递归中的局部变量和参数等就会被删除，释放空间，从而不会造成栈溢出。但是很多编译器并没有自动对尾递归优化的功能，也即当编译器判断出当前所执行的操作是递归操作时，不会理会它究竟是线性递归还是尾递归，这样也就不会删除掉之前的局部变量和参数等。另外，尾部递归一般都可转化为循环语句。 尾递归的原理：当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。 直接递归与尾递归的对比 一般来说，线性递归和尾递归的时间复杂度相差不大（当然也有例外情况，比如斐波拉契数列，这是因为其线性递归的实现，产生了大量冗余的计算，它的时间复杂度为指数级，而其尾递归的实现只需要线性级别的时间复杂度）。线性递归容易理解，尾部递归性能比较好。 但尾递归的空间复杂度比较小（这是在假定尾递归被优化的前提下）。尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如sum(n) = f(n) = f(n-1) + value(n) ;会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。 123456789线性递归int fact(int n) &#123; if (n &lt; 0) return 0; else if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1) return 1; else return n * fact(n - 1);&#125; 123456789101112尾递归int facttail(int n, int res)&#123; if (n &lt; 0) return 0; else if(n &#x3D;&#x3D; 0) return 1; else if(n &#x3D;&#x3D; 1) return res; else return facttail(n - 1, n *res);&#125; 在每次函数调用计算n倍的(n－1)!的值，让n=n－1并持续这个过程直到n=1为止。这种定义不是尾递归的，因为每次函数调用的返回值都依赖于用n乘以下一次函数调用的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。 函数比代码1多个参数res，除此之外并没有太大区别。res（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令res=n*res并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回res即可。 迭代(iteration) 重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B） 迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。 迭代的准备工作（同循环语句类似）： - 确定迭代变量； - 建立迭代关系式； - 对迭代过程进行控制。 递归与迭代对比 - 迭代程序复杂，但效率高。 - 递归程序逻辑清晰，但往往效率较低(空间复杂度高)。 迭代和递归均包括终止条件测试，迭代在循环继续条件失败时终止，递归在达到基本情况时终止。计数器控制的循环和迭代和递归都是逐步达到终止的。迭代修改计数器直到计数器的值使循环条件不满足；递归产生比原来的问题简单的版本直到达到基本情况。 递归与迭代相互转换 理论上递归和迭代可以相互转换，但实际从算法结构来说，递归声明的结构并不总能转换为迭代结构（原因有待研究）。迭代可以转换为递归，但递归不一定能转换为迭代。 将递归算法转换为非递归算法有两种方法，一种是直接求值（迭代/循环），不需要回溯；另一种是不能直接求值，需要回溯。前者使用一些变量保存中间结果，称为直接转换法；后者使用栈保存中间结果，称为间接转换法，下面分别讨论这两种方法。 直接转换法 直接转换法通常用来消除尾递归（tail recursion）和单向递归，将递归结构用迭代结构来替代。（单向递归 → 尾递归 → 迭代） 斐波那契数列的递归求解： 1234 int Fib(int n) &#123; if(n &lt;&#x3D; 1) return n; else return Fib(n - 1) + Fib(n - 2); &#125; 转化为迭代求解： 123456789101112int Fib(int n) &#123; if(n &lt;&#x3D; 1) return n; int twoBack &#x3D; 0; int oneBack &#x3D; 1; int cur; for(int i &#x3D; 2;i &lt; &#x3D; n; i++) &#123; cur &#x3D; twoBack + oneBack; twoBack &#x3D; oneBack; oneBack &#x3D; cur; &#125; return cur;&#125; 间接转换法 递归实际上利用了系统堆栈实现自身调用，我们通过使用栈保存中间结果模拟递归过程，将其转为非递归形式。 12345678910将初始状态s0进栈 while (栈不为空) &#123; 退栈，将栈顶元素赋给s; if (s是要找的结果) 返回; else &#123; 寻找到s的相关状态s1; 将s1进栈 &#125; &#125; 间接转换法在数据结构中有较多实例，如二叉树遍历算法的非递归实现、图的深度优先遍历算法的非递归实现等等。 参考资料 1. 浅析线性递归和尾递归 2. 递归和尾递归的区别和原理 3. 经典算法｜递归和递归消除的迭代法 4. 递归算法转换为非递归算法 5. 递归与迭代的区别","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题1：三合一","slug":"问题1：三合一","date":"2020-07-03T07:35:04.000Z","updated":"2020-07-03T10:10:25.183Z","comments":false,"path":"2020/07/03/问题1：三合一/","link":"2020/07/03/问题1：三合一","permalink":"http://ssssshinji.github.io/2020/07/03/%E9%97%AE%E9%A2%981%EF%BC%9A%E4%B8%89%E5%90%88%E4%B8%80/","excerpt":"","text":"题目描述 描述如何只使用一个数组来实现三个栈（提示在页尾） 个人思路 最简单的想法是把一个数组分成三个部分。一：将新元素放在a[0]，并将已有元素往后移动。二：将新元素放在a[n]，并将已有元素往前移动。三：放在中间位置并向左或向右移动？或者按kn,k(n+1),k(n+2)的分类方法将数组分成三个部分，每一个部分存储一个栈。 题目解析 和许多问题一样，这个问题的解法基本上取决于你要对栈支持到什么程度。若每个栈分配的空间大小固定，就能满足需要，那么照做便是。不过，这么做的话，有可能其中一个栈的空间不够用了，其他的栈却几乎是空的。另一种做法是弹性处理栈的空间分配，但这么一来，这个问题的复杂度又会大大增加。 方法1：固定分割： 将整个数组划分为三等份，并将每个栈的增长限制在各自的空间里。注意：记号[表示包含端点，（表示不包含端点。 栈1，使用[0, n/3) 栈2，使用[n/3, 2n/3) 栈3，使用[2n/3, n) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class FixedMultiStack&#123; private int numberOfStacks &#x3D; 3; private int stackCapacity; private int[] values; private int[] sizes; public FixedMultiStack(int stackSize)&#123; stackCapacity &#x3D; stackSize; values &#x3D; new int[stackSize * numberOfStacks]; sizes &#x3D; new int[numberOfStacks]; &#125; &#x2F;&#x2F;压栈 public void push(int stackNum, int value)&#123; if(isFull(stackNum))&#123; throw new Exception(&quot;空间不足&quot;); &#125; &#x2F;&#x2F;对栈顶指针加1并更新顶部的值 sizes[stackNum]++; values[indexOfTop(stackNum)] &#x3D; value; &#125; &#x2F;&#x2F;出栈 public int pop(int stackNum)&#123; if(isEmpty(stackNum))&#123; throw new Exception(&quot;栈为空&quot;); &#125; int topIndex &#x3D; indexOfTop(stackNum); int value &#x3D; values[topIndex];&#x2F;&#x2F;获取顶部元素 values[topIndex] &#x3D; 0;&#x2F;&#x2F;清零 sizes[stackNum]--; return value; &#125; &#x2F;&#x2F;返回顶部元素 public int peek(int stackNum)&#123; if(isEmpty(stackNum))&#123; throw new Exception(&quot;栈为空&quot;); &#125; return values[indexOfTop(stackNum)]; &#125; &#x2F;&#x2F;检查是否栈空 public Boolean isEmpty(int stackNum)&#123; return sizes[stackNum] &#x3D;&#x3D; 0; &#125; &#x2F;&#x2F;检查栈是否为满 public Boolean isFull(int stackNum)&#123; return sizes[stackNum] &#x3D;&#x3D; stackCapacity; &#125; &#x2F;&#x2F;返回栈顶元素的索引 private int indexOfTop(int stackNum)&#123; int offset &#x3D; stackNum * stackCapacity; int size &#x3D; sizes[stackNum]; return offset + size - 1; &#125;&#125; 方法2：弹性分割： 第二种做法是允许栈块的大小灵活可变。当一个栈的元素个数超出其初始容量时，就将这个栈扩容至许可的容量，必要时还要搬移元素。此外，我们会将数组设计成环状的，最后一个栈可能从数组末尾处开始，环绕到数组起始处。请注意，这种解法的代码远比面试中常见的要复杂得多。你可以试着提供伪码，或是其中某几部分的代码，但要完整实现的话，难度就有点大了。 反思 用一个数据结构实现另一个数据结构时，不光要想怎么完成空间上的划分和基本逻辑的实现，还要根据所求数据结构的API，尽量做到易维护，可读性强。 提示：#2，#12，#38，#58 -栈只是一个数据结构，其中最近添加的元素首先被删除。你能用一个数组来模拟单个栈吗？请记住，有很多可能的解法且每个解法都有其利弊。 -我们可以通过将数组的前三分之一分配到第一个栈、第二个三分之一分配到第二个栈、最后的第三个三分之一分配到第三个栈，来模拟数组中的三个栈。然而，实际上某个栈可能比其他的大得多。能更灵活地分配吗？ -如果你想考虑灵活划分，可以移动栈。你能保证使用所有可用的容量吗？ -试着把数组看作是循环的，这样数组的结尾就“环绕”到了数组的开始部分。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"栈与队列","slug":"栈与队列","permalink":"http://ssssshinji.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"}]},{"title":"问题2：最小高度树","slug":"问题2：最小高度树","date":"2020-07-01T04:29:57.000Z","updated":"2020-07-03T07:57:56.748Z","comments":false,"path":"2020/07/01/问题2：最小高度树/","link":"2020/07/01/问题2：最小高度树","permalink":"http://ssssshinji.github.io/2020/07/01/%E9%97%AE%E9%A2%982%EF%BC%9A%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/","excerpt":"","text":"题目描述 给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。（提示在页尾） 个人思路 从叶子节点往上，依次让每个节点都尽量平衡。但是不知道要怎么写，看了提示也没有思路。试试连续用二分查找写一写吧。 个人解答 1234567static Node CreateNode(int[] a,int low, int high)&#123; int mid &#x3D; (low + high)&#x2F;2; Node root &#x3D; new Node(a[mid]); root.left &#x3D; CreateNode(a,low, mid-1); root.right &#x3D; CreateNode(a,mid+1, high); return root;&#125; 题目解析 要创建一棵高度最小的树，就必须让左右子树的节点数量尽量接近，也就是说，我们要让数组中间的值成为根节点，这么一来，数组左边一半就成为左子树，右边一半成为右子树。 然后，我们继续以类似方式构造整棵树。数组每一区段的中间元素成为子树的根节点，左半部分成为左子树，右半部分成为右子树。 一种实现方式是使用简单的root.insertNode(int v)方法，从根节点开始，以递归方式将值v插入树中。这么做的确能构造最小高度的树，但不太高效。每次插入操作都要遍历整棵树，用时为O(NlogN)。另一种做法是以递归方式运用createMinimalBST方法，从而删去部分多余的遍历操作。这个方法会传入数组的一个区段，并返回最小树的根节点。 标准解答（BFS） 12345678910static Node CreateNode(int[] a,int low, int high)&#123; if(low &lt; high)&#123; return null; &#125; int mid &#x3D; (low + high)&#x2F;2; Node root &#x3D; new Node(a[mid]); root.left &#x3D; CreateNode(a,low, mid-1); root.right &#x3D; CreateNode(a,mid+1, high); return root;&#125; 复杂度分析 递归的时间复杂度往往是（偶尔不是）O(分支数^数的深度)，本题为O(2^N); 反思 又忘记了边界检查。 （提示：#19，#73，#116） -最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？ -你可以通过找到“理想”的下一个要添加的元素和多次调用insertValue来实现。这样效率会有点儿低，因为你必须反复遍历树。尝试用递归代替。你能把这个问题分解为子问题吗？ -最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"问题精析：渲染管线","slug":"问题精析：渲染管线","date":"2020-06-30T18:32:28.000Z","updated":"2020-07-23T10:31:45.820Z","comments":false,"path":"2020/07/01/问题精析：渲染管线/","link":"2020/07/01/问题精析：渲染管线","permalink":"http://ssssshinji.github.io/2020/07/01/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/","excerpt":"","text":"概念 渲染管线的主要功能是决定在给定虚拟相机、三维物体、光源、照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。 步骤 应用程序阶段 Application 几何阶段 Geometry Processing 顶点着色器 Vertex Shader 变换 MV Transformation 投影 Projection 可选阶段 Optional Stage 表面细分 Tessellation 几何着色器 Geometry Shader 流输出 Stream Output 图元装配 Primitive Assembly （在顶点着色器之后进行，容易记不清楚） 裁剪与屏幕映射 Clipping &amp; Screen Mapping 光栅化阶段 The Rasterizer Stage 三角形设定 Triangle Setup 三角形遍历 Triangle Traversal 像素处理 Pixel Processing 像素着色器 Pixel Shader 合并 Merging 应用程序阶段 应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件基础上，因此要改变实现过程会非常困难。 应用程序阶段通常实现的方法有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。 几何阶段 输入是顶点与图元的顶点索引，输出是屏幕空间的顶点。简单来说，几何阶段就是负责把顶点都转换到屏幕空间，以便光栅化阶段处理。 顶点着色器的输入是顶点和顶点属性，顶点着色器负责将顶点的位置从局部空间转换到齐次剪切空间 (Homogeneous Clipping Space)，顶点着色器还可以操作顶点相关的属性，比如颜色，法线，纹理坐标等，一般会在顶点着色器会计算逐顶点的光照。 还会在顶点着色器做其他一些操作，比如 Instancing (将同一个物体的顶点绘制在多个地方)，或者做关节动画，蒙皮，顶点动画。 可选阶段 Optional Stage 表面细分 Tessellation：主要用来做面的细分，可以将现有的面数拆分得更多，提供更多得细节。这个阶段常用来生成更精细的地形或其他表面。 几何着色器 Geometry Shader：几何着色器的输入是整个图元，还可以获得邻接图元的信息。几何着色器可以丢弃一些图元，还可以生成新的图元。这个阶段可以简化图元，例如用来做细节等级 (Level of detail，LOD)。也可以用来生成图形，例如用来做粒子生成。 与 Tessellation 相比，几何着色器可以丢弃图元，也可以将现有的图元转换成其他图元。而 Tessellation 只能增加面数。 流输出 Stream Output：在几何着色器中生成的顶点数据可以流输出到 GPU Memory 。这些数据可以再次放到流水线里，或者被 CPU 读取。这种方式可以迭代处理数据，常用来做水流模拟，或者粒子效果。 光栅化阶段 The Rasterizer Stage 经过裁剪和挑选剩下的多边形必须被光栅化。光栅化是一个决定哪些像素被几何图元覆盖的过程。多边形、线段和点根据为每种图元指定的规则分别被光栅化。光栅化的结果是像素位置的集合和片段的集合。当光栅化后，一个图元拥有的顶点数目和产生的片段之间没有任何关系。例如，一个由三个顶点组成的三角形占据整个屏幕，因此需要生成上百万的片段。 片段和像素之间的区别变得非常重要。术语像素（Pixel）是图像元素的简称。一个像素代表帧缓存中某个指定位置的内容，例如颜色，深度和其它与这个位置相关联的值。一个片段（Fragment）是更新一个特定像素潜在需要的一个状态。 之所以术语片段是因为光栅化会把每个几何图元（例如三角形）所覆盖的像素分解成像素大小的片段（扫描转换）。一个片段有一个与之相关联的像素位置、深度值和经过插值的参数，例如颜色，第二（反射）颜色和一个或多个纹理坐标集。这些各种各样的经过插值的参数是来自变换过的顶点，这些顶点组成了某个用来生成片段的几何图元。你可以把片段看成是潜在的像素。如果一个片段通过了各种各样的光栅化测试（在光栅操作将做讨论），这个片段将被用于更新帧缓存中的像素。 三角形设定 Triangle Setup（有些不清楚） 之前得到的都是三角形的顶点，而之后要计算屏幕上三角形会覆盖那些像素。三角形设定阶段会计算三角形边上 (及内部？)的像素坐标及相关的属性。 (推测：应该是在这个阶段进行 反面剔除 (Backface Culling)，将反面朝向相机的三角形扔掉。) 另一种说法是三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用。该过程在专门为其设计的硬件上执行。 三角形遍历 Triangle Traversal（有些不清楚） 这个阶段会进行逐像素检查，检查每个像素 (或采样点)是否被三角形覆盖，如果覆盖则生成一个片元 (Fragment)。这一阶段也被称为扫描转换 (Scan Conversion)。 另一种说法在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成片段（fragment）。找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。每个三角形片段的属性均由三个三角形顶点的数据插值而生成（在第五章会有讲解）。这些属性包括片段的深度，以及来自几何阶段的着色数据。 像素处理 Pixel Processing 像素着色器 Pixel Shader：也被叫做片元着色器 (Fragment Shader)，用来逐像素的计算着色使用插值得来的着色数据作为输入，输出结果为一种或多种将被传送到下一阶段的颜色信息。纹理贴图和纹理过滤一般都是在这个阶段进行的。 像素着色器的输入是逐像素的属性，这些属性是根据上个阶段中的顶点插值而得到的，插值一般使用透视纠正插值 (Perspective Correct Interpolation)由硬件完成，需要借助深度值才能正确地插值。 像素着色器还可以获取邻近像素插值的变化量，可以进行梯度计算，这个特性主要用来做纹理过滤。 像素着色器会输出一个该像素 (片元)的颜色，也可以选择不输出。像素着色器还可以修改深度缓冲 (Depth Buffer)，甚至是模板缓冲 (Stencil Buffer)的值。 在现代 GPU 上，像素着色器 可以将进行不同类型的输出，并写入多重渲染目标 (Multiple Render Targets，MRT)，一个 RT 就是一个 buffer，可以将不同的信息写入不同的 RT，然后在下个阶段合成 合并 Merging 这个阶段主要是将目前这一帧计算出来的 Fragment 颜色和系统中所有的 buffer 合并（合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色），得到最终的颜色值。合并阶段不可编程，但是高度可配置。 通常会在这个阶段根据 Z-buffer 进行 可见性测试 (Depth test，深度测试)，只渲染能看见的片元。也会进行透明度测试 (Alpha Test)，混合半透明物体与透明物体的颜色。模板缓冲也会用来控制颜色合并。 经过合并阶段就可以得到最终屏幕显示的颜色了。 参考资料 1. 《Real-Time Rendering 3rd》 提炼总结 2. 3D图形渲染管线 3. 图形渲染管线简介","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题2：判定是否互为字符重排","slug":"问题2：判定是否互为字符重排","date":"2020-06-30T17:35:53.000Z","updated":"2020-07-26T14:36:11.767Z","comments":false,"path":"2020/07/01/问题2：判定是否互为字符重排/","link":"2020/07/01/问题2：判定是否互为字符重排","permalink":"http://ssssshinji.github.io/2020/07/01/%E9%97%AE%E9%A2%982%EF%BC%9A%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/","excerpt":"","text":"题目描述 给定两个字符串，请编写程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。（提示在页尾） 个人思路 和前一个问题一样，可以使用字符数组来解决。搜索第一个字符串时，每遇到一个字符，相应数组位置加1，搜索第二个字符串时，每遇到一个字符，相应数组位置减1。如果两个互为字符重排的话，数组的每一个元素应该为0。 个人解答 1234567891011121314151617181920static bool IsAnagram(string str1, string str2)&#123; if(str1.Length !&#x3D; str2.Length)&#123; return false; &#125; int[] char_set &#x3D; new int[128]; for(int i &#x3D; 0; i &lt; str1.Length; i++)&#123; int val &#x3D; str1[i]; char_set[val] +&#x3D; 1; &#125; for(int i &#x3D; 0; i &lt; str2.Length; i++)&#123; int val &#x3D; str2[i]; char_set[val] -&#x3D; 1; &#125; for(int i &#x3D; 0; i &lt; char_set.Length; i++)&#123; if(char_set[i] !&#x3D; 0)&#123; return false; &#125; &#125; return true;&#125; 时间复杂度 经典O(n)。 题目解析 -若两个字符串互为重排字符串，那么它们拥有同一组字符，只不过顺序不同。因此，对字符串排序，组成这两个重排字符串的字符就会有相同的顺序。我们只需比较排序后的字符串。 -还可以充分利用变位词的定义——组成两个单词的字符数相同——来实现这个算法。创建一个类似于散列表的数组（从第4行到第7行），将其每个字符映射到其字符出现的次数。增加第一个字符串，然后减少第二个字符串，如果两者互为重排，则该数组最终将为0。若值为负值（一旦为负，则值将永为负值，不会为非0），就提早终止。若不这样做，则数组就会为0。原因在于，字符串长度相同，增加的次数与减少的次数也相同。若数组无负值，则不会有正值。（和我想得一模一样，优秀） 标准解答 1234567891011static string Sort(string s)&#123; char[] content &#x3D; s.ToCharArray(); Array.Sort(content); return new string(content);&#125;bool Permutation(string s, string t)&#123; if(s.Length !&#x3D; t.Length)&#123; return false; &#125; return Sort(s).Equals(Sort(t));&#125; 标准解答（进阶） 123456789101112131415161718static bool IsAnagram(string str1, string str2)&#123; if(str1.Length !&#x3D; str2.Length)&#123; return false; &#125; int[] char_set &#x3D; new int[128]; for(int i &#x3D; 0; i &lt; str1.Length; i++)&#123; int val &#x3D; str1[i]; char_set[val] +&#x3D; 1; &#125; for(int i &#x3D; 0; i &lt; str2.Length; i++)&#123; int val &#x3D; str2[i]; char_set[val] -&#x3D; 1; if(char_set[val] &lt; 0)&#123; return false; &#125; &#125; return true;&#125; 复杂度分析 可以认为在内省排序中时间复杂度是O(nlogn)。 这题解的比较顶了，不过还是忽略了可以优化的地方。 提示：#1，#84，#122，#131 -描述两个字符串是否互为字符重排的含义。现在，看看你提供的定义，你能否根据这个定义检查字符串？ -有一种解法需要O(NlogN)的时间。另一种解法需要使用一些空间，但需要运行时间为O(N)。 -散列表有用吗？ -两个重排的字符串应该具有相同的字符，但顺序不同。你可以让它们的顺序一样吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"问题精析：延迟着色（deferred Shading）","slug":"问题精析：延迟着色（deferred Shading）","date":"2020-06-29T18:42:23.000Z","updated":"2020-07-18T06:04:55.396Z","comments":false,"path":"2020/06/30/问题精析：延迟着色（deferred Shading）/","link":"2020/06/30/问题精析：延迟着色（deferred Shading）","permalink":"http://ssssshinji.github.io/2020/06/30/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E5%BB%B6%E8%BF%9F%E7%9D%80%E8%89%B2%EF%BC%88deferred%20Shading%EF%BC%89/","excerpt":"","text":"背景以及概念 我们现在一直使用的光照方式叫做正向渲染(Forward Rendering)或者正向着色法(Forward Shading)，它是我们渲染物体的一种非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此类推。它非常容易理解，也很容易实现，但是同时它对程序性能的影响也很大，因为对于每一个需要渲染的物体，程序都要对每一个光源每一个需要渲染的片段进行迭代，这是非常多的！因为大部分片段着色器的输出都会被之后的输出覆盖，正向渲染还会在场景中因为高深的复杂度(多个物体重合在一个像素上)浪费大量的片段着色器运行时间。 延迟着色法(Deferred Shading)，或者说是延迟渲染(Deferred Rendering)，为了解决上述问题而诞生了，它大幅度地改变了我们渲染物体的方式。这给我们优化拥有大量光源的场景提供了很多的选择，因为它能够在渲染上百甚至上千光源的同时还能够保持能让人接受的帧率。 延迟着色法基于我们延迟(Defer)或推迟(Postpone)大部分计算量非常大的渲染(像是光照)到后期进行处理的想法。它包含两个处理阶段(Pass)：在第一个几何处理阶段(Geometry Pass)中，我们先渲染场景一次，之后获取对象的各种几何信息，并储存在一系列叫做G缓冲(G-buffer)的纹理中；像位置向量(Position Vector)、颜色向量(Color Vector)、法向量(Normal Vector)和/或镜面值(Specular Value)。场景中这些储存在G缓冲中的几何信息将会在之后用来做(更复杂的)光照计算。G缓冲，G-Buffer，全称Geometric Buffer ，译作几何缓冲区，它主要用于存储每个像素对应的位置（Position），法线（Normal），漫反射颜色（Diffuse Color）以及其他有用材质参数。根据这些信息，就可以在像空间（二维空间）中对每个像素进行光照处理。（G缓冲中的内容不是固定的，是可以根据需要来增删的。比如说OpenGL教程中就多存储了镜面值 Specular Value） 我们会在第二个光照处理阶段(Lighting Pass)中使用G缓冲内的纹理数据。在光照处理阶段中，我们渲染一个屏幕大小的方形，并使用G缓冲中的几何数据对每一个片段计算场景的光照；在每个像素中我们都会对G缓冲进行迭代。我们对于渲染过程进行解耦，将它高级的片段处理挪到后期进行，而不是直接将每个对象从顶点着色器带到片段着色器。光照计算过程还是和我们以前一样，但是现在我们需要从对应的G缓冲而不是顶点着色器(和一些uniform变量)那里获取输入变量了。 片元着色器代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#version 330 coreout vec4 FragColor;in vec2 TexCoords;uniform sampler2D gPosition;uniform sampler2D gNormal;uniform sampler2D gAlbedoSpec;struct Light &#123; vec3 Position; vec3 Color; float Linear; float Quadratic;&#125;;const int NR_LIGHTS = 32;uniform Light lights[NR_LIGHTS];uniform vec3 viewPos;void main()&#123; // // 从G缓冲中获取数据 vec3 FragPos = texture(gPosition, TexCoords).rgb; vec3 Normal = texture(gNormal, TexCoords).rgb; vec3 Diffuse = texture(gAlbedoSpec, TexCoords).rgb; float Specular = texture(gAlbedoSpec, TexCoords).a; // 然后和往常一样地计算光照 vec3 lighting = Diffuse * 0.1; // hard-coded ambient component vec3 viewDir = normalize(viewPos - FragPos); for(int i = 0; i &lt; NR_LIGHTS; ++i) &#123; // Diffuse vec3 lightDir = normalize(lights[i].Position - FragPos); vec3 diffuse = max(dot(Normal, lightDir), 0.0) * Diffuse * lights[i].Color; // Specular vec3 halfwayDir = normalize(lightDir + viewDir); float spec = pow(max(dot(Normal, halfwayDir), 0.0), 16.0); vec3 specular = lights[i].Color * spec * Specular; // Attenuation float distance = length(lights[i].Position - FragPos); float attenuation = 1.0 / (1.0 + lights[i].Linear * distance + lights[i].Quadratic * distance * distance); diffuse *= attenuation; specular *= attenuation; lighting += diffuse + specular; &#125; FragColor = vec4(lighting, 1.0);&#125; 优点 Deferred Rendering 的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开。也就是说场景中不管是一个三角形还是一百万个三角形，最后的复杂度不会随光源数目变化而产生巨大变化。 一些要点： - 复杂度仅O(n+m)。 - 只渲染可见的像素，节省计算量。 - 用更少的shader（也算缺点，见缺点4）。 - 对后处理支持良好。 - 在大量光源的场景优势尤其明显。 缺点 一些要点： - 内存开销较大。 - 读写G-buffer的内存带宽用量是性能瓶颈。 - 对透明物体的渲染存在问题。在这点上需要结合正向渲染进行渲染（因为不能使用混合 Blending）。 - 对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启MRT。 - 迫使你对大部分场景的光照使用相同的光照算法，你可以通过包含更多关于材质的数据到G缓冲中来减轻这一缺点。 与正向渲染比较 正向渲染 - 正向渲染（Forward Rendering），先执行着色计算，再执行深度测试。 - 正向渲染渲染n个物体在m个光源下的着色，复杂度为O(n*m)次。 - Forward Rendering，光源数量对计算复杂度影响巨大，所以比较适合户外这种光源较少的场景。 - Forward Rendering的核心伪代码可以表示为： 123For each light: For each object affected by the light: framebuffer +&#x3D; object * light - Forward Rendering的管线流程如下：顶点 -&gt; 图元 -&gt; 光栅化 -&gt; 片元 -&gt; 可选帧缓冲（实现后处理之类） -&gt; 帧缓冲 延迟渲染 - 延迟渲染( Deferred Rendering)，先执行深度测试，再执行着色计算。 - 将光源的数目和场景中物体的数目在复杂度层面上完全分开。 - 延迟渲染渲染n个物体在m个光源下的着色，复杂度为O(n+m)次。 - Deferred Rendering的核心伪代码可以表示如下： 123For each object: Render to multiple targets For each light: Apply light as a 2D postprocess - Deferred Rendering的管线流程如下：顶点 -&gt; 图元 -&gt; 光栅化 -&gt; 几何处理阶段 -&gt; 可选帧缓冲（实现后处理之类）-&gt; G-buffer -&gt; 光照处理阶段 -&gt; 帧缓冲 参考资料 1. 《Real-Time Rendering 3rd》 提炼总结 2. 延迟着色法","categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"问题2：迷路的机器人","slug":"问题2：迷路的机器人","date":"2020-06-29T17:06:28.000Z","updated":"2020-06-29T18:38:01.800Z","comments":false,"path":"2020/06/30/问题2：迷路的机器人/","link":"2020/06/30/问题2：迷路的机器人","permalink":"http://ssssshinji.github.io/2020/06/30/%E9%97%AE%E9%A2%982%EF%BC%9A%E8%BF%B7%E8%B7%AF%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA/","excerpt":"","text":"题目描述 设想有个机器人坐在一个网格的左上角，网格r行c列。机器人只能向下或向右移动，但不能走到一些被禁止的网格。设计一种算法，寻找机器人从左上角移动到右下角的路径。（提示在页尾） 个人思路 这个应该属于动态规划的范围内，从最后一步往前倒着思考试试。想了想好像能结合DFS写出来。 个人解答 12345678910111213141516171819202122232425262728static ArrayList FindPath(bool[][] maze)&#123; if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123; return null; &#125; ArrayList path &#x3D; new ArrayList(); if(maze.Length &#x3D;&#x3D; 1)&#123; path.Add(new Point(0,0)); return path; &#125; if(FindPath(maze,maze.Length-1,maze[0].Length-1,path))&#123; return path; &#125; return null;&#125;static bool FindPath(bool[][] maze,int row, int col,ArrayList path)&#123; if(isAtOrigin())&#123; return true; &#125; if(FindPath(maze,row-1,col,path))&#123; path.Add(new Point(row,col)); return true; &#125; if(FindPath(maze,row,col-1,path))&#123; path.Add(new Point(row,col)); return true; &#125; return false;&#125; 复杂度分析 O(2^(r+c))。 标准解答 123456789101112131415161718192021222324252627static ArrayList FindPath(bool[][] maze)&#123; if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123; return null; &#125; ArrayList path &#x3D; new ArrayList(); if(maze.Length &#x3D;&#x3D; 1)&#123; path.Add(new Point(0,0)); return path; &#125; if(FindPath(maze,maze.Length-1,maze[0].Length-1,path))&#123; return path; &#125; return null;&#125;static bool FindPath(bool[][] maze,int row, int col,ArrayList path)&#123; &#x2F;&#x2F;边界检查 if(col &lt; 0 || row &lt; 0 || !maze[row][col])&#123; return false; &#125; bool isAtOrigin &#x3D; (row &#x3D;&#x3D; 0) &amp;&amp; (col &#x3D;&#x3D; 0); if(isAtOrigin||FindPath(maze,row-1,col,path)||FindPath(maze,row,col-1,path))&#123; path.Add(new Point(row,col)); return true; &#125; return false;&#125; 复杂度分析 O(2^(r+c))。 题目解析 -如果把网格画出来，你会发现移动到位置(r,c)的唯一方式，就是先移动到它的相邻点，即(r-1,c)或(r,c-1)。因此，我们需要找到一条移至(r-1,c)或(r,c-1)的路径。 -怎么才能找出前往这些位置的路径呢？要找出前往(r-1,c)或(r,c-1)的路径，我们需要先移至其中一个相邻点。因此，要找到一条路径移动到(r-1,c)的相邻点，坐标为(r-2,c)和(r-1,c-1)或(r,c-1)的相邻点，其坐标为(r-1,c-1)和(r,c-2)。注意，坐标(r-1,c-1)一共出现了两次。 -理想情况下，我们应该能记住访问过(r-1,c-1)节点以节省时间。 标准解答（进阶） 12345678910111213141516171819202122232425262728293031323334static ArrayList FindPath(bool[][] maze)&#123; if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123; return null; &#125; ArrayList path &#x3D; new ArrayList(); HashSet&lt;Point&gt; failedPoints &#x3D; new HashSet&lt;Point&gt;(); if(maze.Length &#x3D;&#x3D; 1)&#123; path.Add(new Point(0,0)); return path; &#125; if(FindPath(maze,maze.Length-1,maze[0].Length-1,path,failedPoints))&#123; return path; &#125; return null;&#125;static bool FindPath(bool[][] maze,int row, int col,ArrayList path,HashSet&lt;Point&gt; failedPoints)&#123; &#x2F;&#x2F;边界检查 if(col &lt; 0 || row &lt; 0 || !maze[row][col])&#123; return false; &#125; Point p &#x3D; new Point(row,col); if(failedPoints.Contains(p))&#123; return false; &#125; bool isAtOrigin &#x3D; (row &#x3D;&#x3D; 0) &amp;&amp; (col &#x3D;&#x3D; 0); if(isAtOrigin||FindPath(maze,row-1,col,path,failedPoints)||FindPath(maze,row,col-1,path,failedPoints))&#123; path.Add(p); return true; &#125; failedPoints.Add(p); return false;&#125; 反思 又忘记了边界检查，有先后顺序的if可以利用||运算符写在一个if里,在完成算法之后尽量优化。 提示：#331，#360，#388 -为了让机器人到最后一个格子，必须找出到倒数第二个格子的路径。为了到倒数第二个格子，必须找出到倒数第三个格子的路径。 -首先明确是否有路径，以便稍微简化这个问题。然后，修改你的算法跟踪路径。 -再考虑一下你算法的效率。你能优化它吗？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"递归与动态规划","slug":"递归与动态规划","permalink":"http://ssssshinji.github.io/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"问题1：三步问题","slug":"问题1：三步问题","date":"2020-06-28T04:55:16.000Z","updated":"2020-06-28T05:53:46.797Z","comments":false,"path":"2020/06/28/问题1：三步问题/","link":"2020/06/28/问题1：三步问题","permalink":"http://ssssshinji.github.io/2020/06/28/%E9%97%AE%E9%A2%981%EF%BC%9A%E4%B8%89%E6%AD%A5%E9%97%AE%E9%A2%98/","excerpt":"","text":"题目描述 有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。（提示在页尾） 个人思路 经典斐波拉契数列问题的变形。 个人解答 1234567int Count(int n)&#123; if(n &lt; 0)return 0; else if(n &#x3D;&#x3D; 0)&#123; return 1; &#125; else return count(n-1)+count(n-2)+count(n-3);&#125; 复杂度分析 每次都有3个分支，经典O(3^n)。 题目解析 -蛮力法: 用递归法可以很容易就实现这个算法，只需要遵循如下思路，即countWays(n-1)+countWays(n-2)+countWays(n-3)。 -制表法: 记录已经计算过的结果方式重复计算。（原来也遇到过，又给忘了） 重要的一点是，无论是否使用制表法，注意上楼梯的方式总数很快就会突破整数（int型）的上限而溢出。当n=37时，结果就会溢出。使用long可以撑久一点儿，但也不能从根本上解决问题。 标准解答（制表法） 12345678910111213141516171819static int CountWay(int n)&#123; int[] memo &#x3D; new int[n+1]; for(int i &#x3D; 0; i &lt; memo.Length; i++)&#123; memo[i] &#x3D; -1; &#125; return CountWay(n,memo); &#125;static int CountWay(int n, int[] memo)&#123; if(n &lt; 0)return 0; else if(n &#x3D;&#x3D; 0)return 1; else if(memo[n] &gt; -1)&#123; return memo[n]; &#125; else&#123; memo[n] &#x3D; CountWay(n-1,memo) + CountWay(n-2,memo) + CountWay(n-3,memo); return memo[n]; &#125; &#125; 复杂度分析 也是经典O(3^n)，不过会快很多。 反思 对性能以及算法的可行性不敏感，没有考虑边界问题。 提示：#152，#178，#217，#237，#262，#359 -自上而下地处理这个问题。小孩的最后一跳是什么？ -如果知道跳到第100级台阶之前的每一级台阶的跳法数量，可以计算第100级台阶的跳法数量吗？ -可以通过步数99、98、97的数量，来计算100步的数量。这对应孩子最后迈1步、2步或3步。我们把它们加起来还是相乘？也就是说，它是f(100)=f(99)+f(98)+f(97)或者f(100)=f(99)×f(98)×f(97)吗？ -当“我们这样做然后那样做”时，将这些值相乘。当“我们这样做或者那样做”时，将这些值相加。 -这个方法的运行时间是多少？仔细想想。你能优化它吗？ -尝试用制表法的方式优化效率低下的递归过程。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"递归与动态规划","slug":"递归与动态规划","permalink":"http://ssssshinji.github.io/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"问题合集：逻辑类","slug":"问题合集：逻辑类","date":"2020-06-28T04:08:30.000Z","updated":"2020-07-19T12:45:44.566Z","comments":false,"path":"2020/06/28/问题合集：逻辑类/","link":"2020/06/28/问题合集：逻辑类","permalink":"http://ssssshinji.github.io/2020/06/28/%E9%97%AE%E9%A2%98%E5%90%88%E9%9B%86%EF%BC%9A%E9%80%BB%E8%BE%91%E7%B1%BB/","excerpt":"","text":"题目描述 较重的药丸。有20瓶药丸，其中19瓶装有1.0克的药丸，余下1瓶装有1.1克的药丸。给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次。（提示在后面） 个人思路 只能称重一次，可能的操作无非就是分成两组称重罢了。分成2组，一组10个药丸。这时候一边重一边轻。依次对调两边相同位置的药丸，比较重的药丸在对调后使轻的那一侧变重。 题目解析 -有时候，严格的限制条件反倒能提供解题的线索。在这个问题中，限制条件是天平只能用一次。天平只能用一次，从而得出一个有趣的事实，即一次必须同时称很多药丸，其实更准确地说，是必须从19瓶中拿出药丸进行称重。否则，如果跳过2瓶或更多瓶药丸，又该如何区分没称过的那几瓶呢？别忘了，天平只能用一次。 那么，该怎么称重取自多个药瓶的药丸，并确定哪一瓶装有比较重的药丸？假设只有2瓶药丸，其中一瓶的药丸比较重。每瓶取出一粒药丸，称得重量为2.1克，但无从知晓这多出来的0.1克来自哪一瓶。我们必须设法区分这些药瓶。 如果从药瓶#1取出一粒药丸，从药瓶#2取出两粒药丸，那么，称得重量为多少呢？结果要依情况而定。如果药瓶#1的药丸较重，则称得重量为3.1克。如果药瓶#2的药丸较重，则称得重量为3.2克。这就是这个问题的接替窍门。 称一堆药丸时，我们会有个“预期”重量。借由预期重量和实测重量之间的差别，就能得出哪一瓶药丸比较重，前提是从每个药瓶取出不同数量的药丸。 将之前两瓶药丸的解法加以推广，就能得到完整解法，即从药瓶#1取出一粒药丸，从药瓶#2取出两粒，从药瓶#3取出三粒，以此类推。如果每粒药丸均重1克，则称得总重量为210克（1+2+…+20=20×21/2=210），“多出来的”重量必定来自每粒多0.1克的药丸。 药瓶的编号可由下列算式得出： $$\\frac{weight - 210grams} {0.1grams}$$ 因此，若这堆药丸称得重量为211.3克，则药瓶#13装有较重的药丸。 反思 自己的思路实际上是用了多次天平，违背了题意。忽略了重量与数量之间的，预期重量与实际重量之间的关系。 提示 -你只能使用天平一次。这意味着必须使用所有或几乎所有的药瓶。还必须使用不同的处理方法，否则你无法将它们区分开来。 -如果你把每个瓶子中的一粒药丸放在天平上，会怎么样？如果你从每个瓶子中取两粒药丸放在天平上，又会如何？ -想象一下只有3个瓶子，其中一瓶中有更重的药丸。假设你从每个瓶子中分别取出不同数量的药丸放在天平上（例如，从药瓶#1中取出5粒药丸，从药瓶#2中取出2粒药丸，从药瓶#3中取出9粒药丸），天平会怎样？ -你应该能得到一个会告诉你哪一个是重瓶子的基于重量的方程。 题目描述 有个篮球框，下面两种玩法可任选一种。 玩法1：一次出手机会，投篮命中得分。 玩法2：三次出手机会，必须投中两次。 如果p是某次投篮命中的概率，则p的值为多少时才会选择玩法1或玩法2？（提示在后面） 个人思路 第一种玩法得分的概率和第二种玩法得分的概率比较即可。第一种是\\(p\\),第二种是\\(1-c_3^1 p^1(1-p)^2\\)。 题目解析 与个人思路基本相同 提示 -分别计算赢得第一场比赛和赢得第二场比赛的概率，然后对其进行比较。 -要计算玩法2获胜的概率，首先要计算第1、2次投中，第3次未投中的概率。 -如果两个事件是互斥的（它们不能同时发生），你可以将它们的概率加在一起。你能找到一组互斥的事件，代表三次投篮中的两次吗？ -三投两中的概率为：（第1、2次投中，第3次未投中）的概率+（第1、3次投中，第2次未投中）的概率+（第1次未投中，第2、3次投中）的概率+（3次全投中）的概率。 题目描述 有个8×8棋盘，其中对角的角落上，两个方格被切掉了。给定31块多米诺骨牌，一块骨牌恰好可以覆盖两个方格。用这31块骨牌能否盖住整个棋盘？请证明你的答案（提供范例或证明为什么不能）。 个人思路 从2*2的棋盘开始试验，试到5*5发现好像都没有办法铺满。看了提示后意识到，一个多米诺骨牌会占据一个黑色格子和一个白色各自，而对角的两个格子始终是同一种颜色的，会出现一种格子比另一种多两个的情况，则永远没有办法铺满整个棋盘。 题目解析 乍一看，似乎是可以盖住的。棋盘大小为8×8，共有64个方格，但其中两个方格已被切掉，因此只剩62个方格。31块骨牌应该刚好能盖住整个棋盘，对吧？ 尝试用骨牌盖住第1行，而第1行只有7个方格，因此有一块骨牌必须铺至第2行。而用骨牌盖住第2行时，我们又必须将一块骨牌铺至第3行。 要盖住每一行，总有一块骨牌必须铺至下一行。无论尝试多少次，使用多少种方法，我们都无法成功铺下所有骨牌。 其实，可以更简洁而严谨地证明为什么不可能。棋盘原本有32个黑格和32个白格。将对角角落上的两个方格（相同颜色）切掉，棋盘只剩下30个同色的方格和32个另一种颜色的方格。为了方便论证，我们假定棋盘上剩下30个黑格和32个白格。 放在棋盘上的每块骨牌必定会盖住一个白格和一个黑格。因此，31块骨牌正好盖住31个白格和31个黑格。然而，这个棋盘只有30个黑格和32个白格，所以，31块骨牌盖不住整个棋盘。 提示：#367，#397 -想象一块多米诺骨牌放在棋盘上。它盖住了多少个黑色方格？多少个白色方格？ -棋盘上有多少个黑色方格？多少个白色方格？ 题目描述 三角形的三个顶点上各有一只蚂蚁。如果蚂蚁开始沿着三角形的边爬行，两只或三只蚂蚁撞在一起的概率有多大？假定每只蚂蚁会随机选一个方向，每个方向被选到的概率相等，而且三只蚂蚁的爬行速度相同。 个人思路 只有都同向的时候才不会相撞。 $$ 1-(1/2)^3 - (1/2)^3 $$ 题目解析 与个人思路基本相同。 若要将这个方法推广至n个顶点的多边形，同样地，蚂蚁也只有以顺时针或逆时针同方向。 $$ P_(碰撞)= 1-P_(同方向)=1-(1/2)^(n-1) $$ 提示：#157，#195，#296 -在什么情况下其不会碰撞？ -只有三只蚂蚁都向同一个方向爬行，它们才不致相撞。三只蚂蚁都按顺时针爬行的概率是多少？ -你可以认为这是概率（3只蚂蚁走顺时针方向）+概率（3只蚂蚁走逆时针方向）。或者，你可以把它看作：第一只蚂蚁选择了一个方向。其他蚂蚁选择同一方向的概率是多少？ 题目描述 有两个水壶，容量分别为3夸脱[插图]和5夸脱，若水的供应不限量（但没有量杯），怎么用这两个水壶得到刚好4夸克的水？注意，这两个水壶呈不规则状，无法精准地装满“半壶”水。 个人思路 倒一倒就出来了。装满5夸克容器，倒进3夸克容器，5夸克容器剩余2夸克，3夸克容器清空，将2夸克水倒进3夸克容器，重新装满5夸克容器，用其装满3夸克容器，5夸克容器中剩余即为4夸克。 题目解析 5夸克水壶 3夸克水壶 5 0 2 3 2 0 0 2 5 2 4 3 提示：#149，#379，#400 -把玩水壶，来回倒水，看看你能否测量3夸脱或5夸脱以外的东西。这是一个开始。 -如果你装满5夸脱的水壶，再用它装满3夸脱的水壶，那么5夸脱的水壶里就剩下2夸脱了。你可以把这2夸脱放在那里，也可以把小水壶里的水倒干净，然后倒入这2夸脱。 -一旦你找到一个解决这个问题的方法，就可以从更具普遍意义的角度去考虑它。如果给你一个大小为X的水壶和另一个大小为Y的水壶，你能用它们来测量出Z吗？ 题目描述 有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人有蓝眼睛，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？（提示在后面） 个人思路 题目有些描述不清楚的地方。比如说要是A旁边的人说A的眼睛是蓝色的，A会不会相信然后离岛。还有面对离岛这件事，蓝眼睛的人是积极的还是消极的，身边的人是积极还是消极。此处我们假设，周围的人不会告知他人的眼睛颜色，只有蓝色眼睛的人自身通过推理确认了自己眼睛的颜色后才会离岛。 题目解析 下面将采用简单构造法。假定这个岛上一共有n人，其中c人有蓝眼睛。由题目可知，c&gt; 0。 1. 情况c=1：只有一人眼睛是蓝色的： 假设岛上所有人都智力超群，蓝眼睛的人四处观察之后，发现没有人的眼睛是蓝色的。但他知道至少有一人眼睛是蓝色的，于是就推导出自己的眼睛一定是蓝色的。因此，他会搭乘当晚的飞机离开。 2. 情况c=2：只有两人眼睛是蓝色的： 两个蓝眼睛的人看到对方，并不确定c是1还是2，但是由上一种情况得知，如果c=1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出c=2，也就意味着他自己的眼睛也是蓝色的。于是，两个蓝眼睛的人都会在第二晚离岛。 3. 情况c&gt; 2：一般情况： 逐步增加c时，我们可以看出上述公式仍旧适用。如果c=3，那么，这三个人会立即意识到有两到三人的眼睛是蓝色的。如果有两人眼睛是蓝色的，那么这两人会在第二晚离岛。因此，如果过了第二晚另外两人还在岛上，每个蓝眼睛的人都能推断出c=3，因此这三人都有蓝眼睛。他们会在第三晚离岛。 无论c为何值，都可套用这个公式。所以，如果有c人有蓝眼睛，则所有蓝眼睛的人要用c晚才能离岛，且都在同一晚离开。 反思 本来觉得有些逻辑问题，后来还是想通了。假如有三个蓝眼睛的人，他们分别能看到另外的两个蓝眼睛的人，所以要是第二天晚上还没人离开的话，就会同时在第三天离开。非蓝色眼睛的人能看到3个蓝眼睛的人，所以即使要推测自己是蓝眼睛然后离开，也是在第四天。而第三天时三个人已经离开了的话，他也就可以判断出自己不是蓝眼睛。 提示：#218，#282，#341，#370 -这是一个逻辑问题，而不是一个巧妙的单词问题。使用逻辑/数学/算法来解决该问题。 -假设只有一个蓝眼睛的人。那个人会看到什么？他们什么时候离开？ -现在假设有两个蓝眼睛的人。他们会看到什么？他们会知道什么？他们什么时候离开？从先前的提示想一下你的答案。假设他们知道前面提示的答案。 -由此推导下去。如果有3个蓝眼睛的人呢？如果有4个蓝眼睛的人呢？ 题目描述 在大灾难后的新世界，世界女王非常关心出生率。因此，她规定所有家庭都必须有一个女孩，否则将面临巨额罚款。如果所有的家庭都遵守这个政策——所有家庭在得到一个女孩之前不断生育，生了女孩之后立即停止生育——那么新一代的性别比例是多少（假设每次怀孕后生男生女的概率是相等的）？通过逻辑推理解决这个问题，然后使用计算机进行模拟。（提示在后面） 个人思路 应该需要计算期望，算出来是1：1，脑海里总觉得应该是男生比较多，差得很远，故选择看答案。 题目解析 如果每个家庭都遵守该政策，那么每个家庭都会先生育0至多个男孩，再生育一个女孩。换句话说，如果用G表示女孩，B表示男孩，那么孩子出生的序列可由以下任意一种序列表示，即G，BG，BBG，BBBG，以此类推。 1. 数学方法： 如果从药瓶#1取出一粒药丸，从药瓶#2取出两粒药丸，那么，称得重量为多少呢？结果要依情况而定。如果药瓶#1的药丸较重，则称得重量为3.1克。如果药瓶#2的药丸较重，则称得重量为3.2克。这就是这个问题的接替窍门。 P(G)=1/2。换句话说，50%的家庭会首先生育一个女孩，其他家庭则会生育更多的孩子。 P(BG)=1/4。对于那些可以生育第二个孩子的家庭（占总家庭数的50%），第二个有50%会生育一个女孩。 P(BBG)=1/8。对于那些可以生育第三个孩子的家庭（占总家庭数的25%），第三个50%会生育一个女孩。 我们知道每个家庭都有且只有一个女孩。那么每个家庭平均生育多少个男孩？为了回答该问题，我们可以计算生育男孩数量的期望值，而该期望值可以通过计算每种生育序列的概率与序列中男孩的数量的乘积得出。 序列 男孩数量 概率 男孩数量*概率 G 0 1/2 0 BG 1 1/4 1/4 BBG 2 1/8 2/8 BBBG 3 1/16 3/16 BBBBG 4 1/32 4/32 BBBBBG 5 1/64 5/64 换句话说，期望值可以通过计算级数“i除以2^i”的求和公式得到，其中i的范围为0至无穷大，公式如下。 $$ \\sum_{i=0}^{\\infty} = \\frac{i}{2^{i+1}} $$ 利用上面的公式求期望，结果接近于64/64（即1）。该估值方法大有用处，但是并不是严格意义上的数学推导。然而，其可以助下面所述的逻辑方法一臂之力。结果会是1吗？ 2. 逻辑方法： 如果上面方法得出的和为1，那么这就意味着性别比例是平衡的。每个家庭刚好生育一个女孩，而平均生育一个男孩。因此该生育政策是无效的。你觉得这样的结论合理吗？ 第一眼看上去，这似乎是一个错误的答案。该生育政策设计之初是为了生育更多的女孩，原因在于该政策确保了每个家庭都能够生育女孩。但是另一方面，每个家庭都有可能生育多个男孩。这会对冲掉“生育一个女孩”政策的影响。 思考该问题的另一个方法是，我们可以将所有家庭的生育序列表示为一个巨大的字符串。如果家庭1生育序列为BG，家庭2生育序列为BBG，家庭3生育序列为G，我们可以将所有家庭的生育序列记作BGBBGG。 事实上，我们不需要关心如何以家庭为单位列出字符串，这是因为我们真正关心的是总人口的性别比例。只要有一个孩子出生，我们即可将其性别B或者G加入到字符串的尾部。 下一个字符是G的可能性有多大？其实，如果生育男孩和女孩的可能性是一样的，那么下一个字符为G的可能性即为50%。因此，大体上一半的字符串会是G字符，另一半会是B字符，也就是说性别的比例是一致的。 这样看来就合理多了。生物学并没有被改变。一半新出生的婴儿是男孩，一半新出生的婴儿是女孩。遵守任何关于“在某一时刻停止生育”的政策不会改变生物学这一事实。 因此，性别比例是50%的男孩和50%的女孩。 3. 算法模拟： 1234567891011121314151617181920212223static double p()&#123; int[] genders &#x3D; new int[2]; for(int i &#x3D; 0; i &lt;&#x3D; 10000; i++)&#123; int[] gerder &#x3D; OneFamily(); genders[0] +&#x3D; gerder[0]; genders[1] +&#x3D; gerder[1]; &#125; return (double)genders[0]&#x2F;genders[1];&#125;static int[] OneFamily()&#123; int[] gerder &#x3D; new int[2]; gerder[0] &#x3D; 0; gerder[1] &#x3D; 0; while(gerder[1] &#x3D;&#x3D; 0)&#123; if(new Random().Next(2) &lt; 1)&#123; gerder[1] +&#x3D; 1; &#125; else&#123; gerder[0] +&#x3D; 1; &#125; &#125; return gerder;&#125; 反思 概率论的基础不扎实，生怕是自己算错了。 提示：#154，#160，#171，#188，#201 -注意每个家庭都有一个女孩。 -考虑将每个家庭写成Bs和Gs的序列。 -虽然数学很难，但你可以试着使用数学方法。估算一下比如6个孩子的家庭可能会较为容易。这不会给你一个很好的数学证明方法，但可能会向你指出获得答案的正确方向。 -逻辑可能比数学容易。想象一下，我们把每次出生都写进了一个巨大的字符串，它由字符B和G组成。注意家庭的分组对于这个问题是无关紧要的。字符串的下一个字符是B还是G的概率是多少？ -请注意生物学并没有改变，只有家庭停止生孩子的条件有所改变。每一次怀孕生男孩和生女孩的可能性均为50%。 题目描述 有栋建筑物高100层，若从第N层或更高的楼层扔下来，鸡蛋就会破碎；若从第N层以下的楼层扔下来则不会破碎。给你两个鸡蛋，请找出N，并要求最差情况下扔鸡蛋的次数为最少。（提示在后面） 个人思路 只有两个鸡蛋，为了防止一次全部破碎，只能从最底层往上试验。最多可以相隔一个楼层。比如说，一个从1楼，一个从3楼，如果没碎，就抬高到4，6楼。如果3楼的碎了，剩下的那个从2楼扔下便知道N是2还是1。 题目解析 我们发现，无论怎么扔鸡蛋1（Egg 1），鸡蛋2（Egg 2）都必须在“破碎那一层”和下一个不会破碎的最高楼层之间，逐层扔下楼（从最低的到最高的）。例如，若鸡蛋1从第5层和第10层扔下没破碎，但从第15层扔下时破碎了，那么，在最差情况下，鸡蛋2必须尝试从第11、第12、第13和第14层扔下楼。 首先，让我们试着从第10层开始扔鸡蛋，然后是第20层，以此类推。 如果鸡蛋1第一次扔下楼（第10层）就破碎了，那么，最多需要扔10次。 如果鸡蛋1最后一次扔下楼（第100层）才破碎，那么，最多要扔19次（第10层，第20层……第90层，第100层，然后是第91到第99层）。 这么做也挺不错，但只考虑了绝对最差情况。我们应该进行“负载均衡”，让这两种情况下扔鸡碎的次数更均匀。 我们的目标是设计一种扔鸡蛋的方法，使得扔鸡蛋1时，不论是在第一次还是最后一次扔下楼才破碎，扔鸡蛋的次数尽量一致。 (1) 完美负载均衡的方法应该是，扔鸡蛋1的次数加上扔鸡蛋2的次数，不论什么时候都一样，不管鸡蛋1是从哪层楼扔下时破碎的。 若有这种扔法，每次鸡蛋1多扔一次，鸡蛋2就可以少扔一次。 因此，每扔一次鸡蛋1，就应该减少鸡蛋2可能需要扔下楼的次数。例如，如果鸡蛋1先从第20层扔下楼，然后从第30层扔下楼，此时鸡蛋2可能就要扔9次。若鸡蛋1再扔一次，我们必须让鸡蛋2扔下楼的次数降为8次。这也就是说，我们必须让鸡蛋1从第39层扔下楼。 由此可知，鸡蛋1必须从第X层开始往下扔，然后再往上增加X-1层，之后增加X-2层……直至到达第100层。 求解X。X+(X-1)+(X-2)+…+1=100X(X+1)/2=100 X≈13.65 X显然是一个整数值。我们应该向上取整还是向下取整呢？ 如果向上取整为14，那么需要按照增加14层、增加13层、增加12层的规律向上增加扔鸡蛋的层数。最后增加的数量为4层，届时将达到第99层。如果在此过程中鸡蛋1在任意一层破碎，可以确定已经对最差情况进行了平衡，扔鸡蛋1和鸡蛋2的次数之和最差为14次。如果鸡蛋1在第99层仍没有破碎，那么只需要再扔一次以确定鸡蛋是否会在第100层破碎。无论哪一种方法，扔鸡蛋的次数不会超过14次。 如果向下取整为13，那么需要按照增加13层、增加12层、增加11层的规律向上增加扔鸡蛋的层数。最后增加的数量为1层，届时将达到第91层。在此情况下，我们已经扔了13次。第92至100层尚没有进行测试。我们没有办法通过扔一次鸡蛋来确定余下的这些楼层（即没有办法取得和“向上取整”相近的结果）。 因此，应该向上取整为14，也就是说，需要先在第14层测试，然后是第27层，接着是第39层……最坏情况下，需要14次测试。 正如解决其他许多最大化/最小化的问题一样，这类问题的关键在于“平衡最差情况”。 123456789101112131415161718192021222324int breakingPoint &#x3D; 某个数;int countDrops &#x3D; 0;bool drop(int floor)&#123; countDrops++; return floor &gt;&#x3D; breakingPoint;&#125;&#x2F;&#x2F;参数是楼层数int findBreakingPoint(int floors)&#123; int interval &#x3D; 14; int previousFloor &#x3D; 0; int egg1 &#x3D; interval; &#x2F;&#x2F;递减间隔扔鸡蛋1 while(!drop(egg1) &amp;&amp; egg1 &lt;&#x3D; floors)&#123; interval -&#x3D; 1; previousFloor &#x3D; egg1; egg1 +&#x3D; interval; &#125; int egg2 &#x3D; previousFloor + 1; &#x2F;&#x2F;每层加1扔鸡蛋2 while(egg2 &lt; egg1 &amp;&amp; egg2 &lt;&#x3D; floors &amp;&amp; !drop(egg2))&#123; egg2 +&#x3D; 1; &#125; return egg2 &gt; floors ? -1:egg2;&#125; 反思 注意如何优化最坏的情况。 提示：#156，#233，#294，#333，#357，#374，#395 -这实际上是一个算法问题，你应该这样做。给出一个蛮力算法，计算最坏情况下扔鸡蛋的次数，然后尝试优化。 -作为第一种方法，你可以尝试类似二分查找的方法。从第50层或第75层，然后到第88层，等等。问题是，**如果鸡蛋1从50层下落破碎，那么你需要从第1层开始往下扔鸡蛋2，逐层往上走。最糟糕的情况下，这可能需要50次（第50层扔，第1层和第2层扔，直到第49层扔）。**你能改进这一情况吗？ -实际上，第一次扔要稍低一些。例如，你可以在第10层扔，然后是第20层，再然后是第30层，以此类推。最坏的情况是19次（第10层，第20层……第100层，第91层，第92层……第99层）。你能做得比这更好吗？不要随意猜测不同的解题方案，而是要深入思考。最坏的情况如何定义？每个鸡蛋被扔的次数是怎样被影响的？ -如果我们以固定间隔扔鸡蛋1（例如，每10层），这样最坏的情况是：鸡蛋1的最坏情况+鸡蛋2的最坏情况。上述解法的问题在于，即使鸡蛋1做更多的工作，鸡蛋2的工作也不会更少。理想情况下，我们想平衡一下。由于鸡蛋1做了更多的工作（从更多次扔下中幸存），因此鸡蛋2需要做的工作应该更少。这意味着什么？ -一开始尝试以较大的间隔扔鸡蛋1，然后逐渐缩小间隔。我们的想法是尽可能保持扔鸡蛋1和扔鸡蛋2次数之和不变。每多扔一次鸡蛋1，鸡蛋2就少扔一次。正确的间隔是多少？ -假设X是第一次扔鸡蛋1的层数。如果鸡蛋1破碎，则意味着鸡蛋2会被扔X-1次。我们希望尽可能地保持鸡蛋1和鸡蛋2扔下的次数总和一致。如果鸡蛋1在第二次扔下时破碎，那么鸡蛋2需要被扔X-2次。如果鸡蛋1在第三次扔下时破碎，那么鸡蛋2需要被扔X-3次。这样扔鸡蛋1和鸡蛋2的次数之和恒定。X是多少？ -最坏情况我扔了14次。你的最坏情况呢？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数学与逻辑题","slug":"数学与逻辑题","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E5%AD%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E9%A2%98/"}]},{"title":"面试经验汇总","slug":"面试经验汇总","date":"2020-06-27T14:12:05.000Z","updated":"2020-07-26T16:49:43.153Z","comments":false,"path":"2020/06/27/面试经验汇总/","link":"2020/06/27/面试经验汇总","permalink":"http://ssssshinji.github.io/2020/06/27/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E6%B1%87%E6%80%BB/","excerpt":"","text":"腾讯IEG 技术美术 准备资料 简历+作品集（ai&amp;ps、blender&amp;3dsmax、ae、unity shader样例、unity shader综合场景） 面试官提问（一面） 1.自我介绍 2.对PBR的理解 3.迪士尼pbr材质实现方式 4.有没有做过pbr样例（衣服、头发、皮肤），遇到过什么难题 5.挑了几个shader，讲一下具体代码实现，如何优化 6.法线贴图的原理 7.写过什么配合dcc的脚本 8.假如ik骨模型，手臂末端出现扭曲，原因是、如何解决、有没有写过处理模型骨骼错误的脚本 9.比较喜欢什么风格的游戏？具体是什么游戏？假如实现某个游戏里某个效果，怎么写shader 10.在网易实习的时候负责的游戏项目是？项目中遇到的难点、如何解决 11.对TA各个方面学习的规划是什么、通过什么途径进行学习 受验者提问 1.进组之后，会负责的游戏是？什么风格？答： 秦时明月（ARPG） 2.在项目中，期望我主攻的方向是？答：看你的想法。 面试官提问（二面） 1.渲染管线的流程 2.对PBR的看法（问题重复了，这个问题感觉是必问的了，注意一定要回答的全面一些，不要局限于材质） 3.对作品集里比较复杂一些的shader问了一些实现原理 反思 每个作品都应该是你的脸，给别人看的脸要是丑陋的话，只能认为自己的审美问题很大。问题里PBR应该是标配。我的理解里PBR是：尝试用计算机，呈现一个符合现实世界中物理定律的画面。那这里就包含：美术资源，摄像机，光照，渲染管线，Shader，后期。并不只是一个材质，一个光照算法，而且综合起来的所有种种。看到一句话感触很深：**瓶颈的存在更多的是因为自身知识的匮乏。**你不了解它或者你自以为了解它，就是最大的瓶颈。 网易互娱 游戏研发 面试官提问 1.介绍一下自己吧 2.说一说你实习期间做过的具体内容，以及部分的实现（包括常规的Unity客户端开发、引擎小工具插件的制作、渲染和优化相关） 3.你觉得自己在实习期间解决的最难的一个问题是什么，以及如何解决的 4.你觉得自己在项目组里面自身水平能占前百分之多少 5.你觉得自己和正式员工相比，最大的差距是什么 6.你有和团队合作的经验吗，期间碰到的问题是怎么一起解决的 7.讲一讲你在校期间的项目（主要讲楼主本科期间做过的一个游戏Demo和研究生期间的一个图形学项目） 8.最近有在看一些什么东西吗，分享一个相关内容？ 中间的技术问题（基本都是图形学基础相关的问题）： 1.描述一下渲染管线 2.几何着色器和细分着色器的作用（这里着重问了几何着色器） 3.几何着色器可以实现细分着色器的功能吗 4.顶点着色器的作用、细分着色器的作用 5.一个几何体会走几次顶点着色器 6.深度测试有办法提前吗，为什么要提前，怎么提前的（Early-Z） 7.Early-Z有使用限制吗（一般不能与AlphaTest混用），为什么不能 7.几何着色器处理的对象是什么，片元着色器处理的对象是什么 8.多个不透明几何体在摄像机前完全重叠会渲染几次（非透明物体的渲染顺序） 9.非透明物体是怎么实现从前往后渲染的 10.透明物体的渲染顺序，为什么透明物体要从后往前渲染 11.顶点光照和像素光照是怎么做的，假如要用高质量的光照用哪个 12.SSAO具体说一下，其中SS是什么意思，为什么叫SS 13.假如一个场景很复杂且有很多个光源，如何优化（延迟渲染，以及具体的实现） 14.NormalMap了解吗，有没有在不使用NormalMap的情况下计算出法线 后面的一个算法问题： 1.手写push_back 2.针对写出的代码的一些问题（楼主一开始写的代码用了memcpy，就问了用memcpy会出现什么问题，主要是浅拷贝和深拷贝的问题。还包括对push_back的时间复杂度的分析） 最后的一些HR问题： 1.有其他想问的吗 2.给了offer有多大把握会去 3.手上有其他offer吗 4.对来上海工作有问题吗 腾讯 游戏客户端开发 字节跳动 游戏引擎研发 面试官提问(一面) C++基础： 1.stl的vector和list的区别，增删分别的时间复杂度 2.虚函数机制 3.C11的新特性 计算机网络： 1.解释TCP3次握手 图形学： 1.速度过快/体积过小导致物理引擎检测不到碰撞，如何解决 开放性问题： 1.如何优化内存，实际开发过程中用过什么优化内存的方法 2.如果有对象要频繁创建和删除，用什么减少开销。(对象池) 3.对象池的大小通常如何决定 面试官提问(二面) 二面面试官给我发了一个腾讯文档，考8道C++基础题，涉及到C++自定义类的大小如何决定(默认大对齐)、右值引用、模板类、STL的iterator使用等等，在面试官纠正下我勉勉强强做出了7道，感觉还是蛮难的。题就不公开放了，有小伙伴需要的话私信我单独发吧。 三面给我印象不是很深，好像是问了问我简历里的项目，然后我叽里咕噜跟面试官说了一堆，说了啥我已经忘了，毕竟面试里说的那些高大上的话太羞耻了根本不敢回忆😂 字节 游戏引擎研发 面试官提问(一面) C++基础： 1.几个stl容器的底层实现 2.右值引用和move构造 3.const、static关键字 4.C++里的lambda函数 5.指针和引用的区别 软件工程： 1.介绍几个设计模式 2.C++里的面向对象 图形学： 1.介绍渲染管线 2.解释纹理采样的两个模式 手撕代码：前序遍历 面试官提问(二面) C++基础： 1.解释C++的多态如何实现 2.解释类模板和模板类的区别 3.右值引用、move语义 图形学： 1.介绍顶点处理中涉及到的矩阵变换 2.介绍一个光照渲染模型(我介绍的是冯氏光照) 3.介绍一个消除隐藏面的算法(我介绍的是Z缓存) 4.如何解决因为顶点过近和浮点数的精度不足带来的穿模问题 手撕代码：快排 面试官提问(三面) 开放性问题： 1.在特定场景如何选择stl容器，以什么为标准？你最近一个应用到这个容器的场景是什么？ 2.在N*N棋盘地图上放一个圆形技能，检测影响到的玩家对象，用什么数据结构实现？ 3.不关心顺序的数组如何实现O(1)的删除操作 4.以上3个是我印象比较深的问题，后面是一些关于项目经历的提问了，比如有没有值得分享的优化点，最有成就感的是哪个等等。 反思 字节的面试是体验最好的，一个下午就连续完成了3面，第二天就完成了HR面，几天后就来了OC，可以说是非常省时间了。暂且不论最后结果，我在面试的过程也学到了很多东西，面试官很看重思考能力和算法数据结构功底，我问的一些问题面试官也回答得非常有干货。 网易 客户端引擎 面试官提问(一面) 1.自我介绍 2.一道简单的概率题 3.一段c语言指针字符串拷贝程序找bug 4.法线矩阵和模型矩阵的关系 5.列举了解的反走样算法 6.TAA实现原理相关的一些问题 7.次表面散射怎么做的 8.虚拟视点方法的原理，怎么计算透射 9.了解商业引擎中透射是怎么做的吗 10.HIVE渲染引擎里面支持多线程吗 11.shadertoy中的体积云怎么实现的 面试官提问(二面) 1.主要做什么东西？做实时渲染多久了？ 2.介绍一下半透明材质渲染项目 3.虚拟视点的缺陷 4.虚拟视点怎么计算透射厚度的 5.怎么进行采样计算的 6.介绍一下HIVE渲染引擎项目 7.HIVE引擎具体提供了什么样的功能？实验室使用HIVE一般用来做什么？ 8.关于opengl和vulkan的shader的区别 9.有考虑过引擎怎么支持DX吗 10.介绍一下峨眉山渲染项目 11.TAA怎么解决重影问题 12.SSAO、Bloom、树叶透光的一些原理介绍 13.为什么需要HDR和Tone mapping 14.介绍一下VR照片墙项目 15.用unity用了多久了，做过什么 16.如何用程序帮助美术实现雪的绘制效果 17.了解AI算法吗 18.关于寻路的一些问题 19.平面中有很多矩形，给出一个坐标，如何快速找出该坐标属于哪个矩形 面试官提问（三面） 1.在家还是在学校？实习会受疫情影响吗？能实习多久？ 2.介绍一个你觉得比较好的项目？ 3.关于虚拟视点原理的解释 4.为什么要计算透射厚度 5.SSSS算法最普适的原理是什么 6.项目能否用于布料绘制相关的一些问题 7.解释PBR中用到的公式原理 8.TAA的原理 9.为什么shading时纹理颜色要转换到线性空间 10.reflect反射公式底层怎么写 11.空间中怎么判断直线与圆是否想交 12.空间中点到直线距离公式 13.有什么了解动画相关的？比如骨骼动画？ 14.一个矩阵插值问题，记不清楚了 15.在构造函数里面调用delete this，然后printf(“xxxxx”)，会不会崩溃？ 为什么不会崩溃？“xxxx”在什么内存区? 16.二维数组按行打印与按列打印那个更快？ 17.解释一下cache？cache line有多大？ 18.a++是线程安全的吗？为什么不是线程安全？ a++翻译成汇编是什么能写出来吗？ 19.有什么问题要问吗？ 面试官提问(HR面) 1.自我介绍 2.关于学校的问题 3.想做哪方面的东西？ 4.平时学习什么东西，怎么学习的？ 5.介绍一下你做的小游戏？ 6.怎么学习c++的？ 7.介绍一个最有成就感的项目？ 8.遇到过什么困难，怎么解决的？ 9.工作时对团队与项目有什么要求？ 10.有什么兴趣爱好？ 11.平时怎么安排学习时间的？ 12.目前投了哪些公司？投的什么岗位？ 13.为什么要来网易？ 14.之前对网易有什么了解吗？ 15.为什么想去杭州？ 16.能实习多久？ 17.有什么问题吗？ 腾讯IEG光子 游戏引擎研发 面试官提问（提前批一面） 1.Blinn-Phong原理 2.Shadow Mapping原理 3.Perlin噪声原理 4.碰撞检测方法 5.碰撞检测中高速物体直接穿过包围盒问题 6.平滑纹理双线性插值，三线性插值 原理 7.为什么uv是在区间[0,1] 8.纹理环绕模式有哪些 uv大于1怎么处理 9.tcp/udp区别 用途 10.排序有哪些，有什么区别 11.算法题 单调栈 12.玩过哪些游戏 面试官提问（提前批二面） 1.网络有哪几层？ 2.tcp/udp区别 3.为什么会有丢包，丢包时发生了什么？ 4.在游戏运行时，从服务器发来一段编译好的二进制程序，要怎么在客户端中使用它（非脚本语言）？ 5.运行时动态链接的原理，过程？ 6.介绍一下c++的面向对象？ 7.多态的实现方式？ 8.虚指针虚表，虚表存在哪里？ 9.设计一个数据结构，使得两个线程一个写入一个读出互不影响，但是不能用锁？（怎么实现无锁数据结构） 10.链表和线性表实现队列的区别？ 11.说一下A* 算法？ 12.A* 算法的复杂度？ 面试官提问（正式批一面） 1.虚函数多态 2.虚表存在哪里 3.拷贝构造函数和赋值函数的区别 4.Blinn-Phong原理 5.渲染管线 6.骨骼蒙皮原理 7.骨骼动画插值 8.渲染方程 9.图的存储方式 10.寻路方法有哪些 11.聊一下A*算法 12.聊项目 面试官提问（正式批二面） 1.问项目 2.带有深度图片中的像素到空间中坐标的变换 3.点到平面距离 4.碰撞检测 5.Shadow Mapping 6.阴影失真的解决方案 7.齐次坐标的作用 8.实例化渲染，降低渲染调用 9.基于物理的渲染PBR 10.10万个数据选出最大的1万个 11.二叉树最近公共祖先 12.什么时候能来实习 面试官提问（HR面） 1.自我介绍 2.游戏经历 3.社团经历 4.为什么读双学位 5.学习的方法 6.什么时候来实习 7.有什么其他offer 整体总结 游戏引擎岗位 面试官提问 C++： 1.new和malloc区别 2.STL中map的实现原理，怎么解决hash冲突 3.STL迭代器失效的情况 4.右值引用的作用？std::move怎么实现的？ 5.三个智能指针说一下，weak_ptr如何判断是否失效？sizeof(shared_ptr)多少？ 6.如何将C++类设置为不可继承 7.能否将构造函数设为虚函数 8.继承下虚表的变化情况？ 9.sizeof空结构体 10.register变量可以取地址吗？ 11.指针和引用的区别 12.深拷贝和浅拷贝 13.函数如何返回多个值（引用或者std::pair,std::tuple) 14.C++ UB说几个 15.带有虚继承的子类内存分布 16.C99变长数组是堆还是栈实现的？ 操作系统&amp;&amp;计算机网络&amp;&amp;多线程: 1.线程和进程的区别 2.多发射了解吗 3.C++中多线程库实现PV操作用什么？ 4.TCP/IP三次握手，拥塞处理，滑动窗口 5.指令重排发生在编译阶段还是运行阶段？ 6.智能指针是线程安全的吗？ (这部分感觉问的比较少，也没啥印象了，也都是基础了) Lua： 1.lua的index和newindex是什么？ 2.lua的垃圾回收机制？是否存在互相引用现象？ 3.lua的元表怎么重载运算符？ 4.lua怎么实现面向对象的机制？ 5.lua的table底层是怎么存储的？ 6.lua对栈的操作比较麻烦，有优化方法吗？ 7.lua和C++怎么绑定，有什么库？ 8.lua的pairs和ipairs有什么区别? 图形学&amp;&amp;管线: 1.渲染管线说一下，前向渲染&amp;&amp;延迟渲染 2.延迟渲染的缺点，分块延迟渲染知道吗？为什么延迟渲染带宽会那么大? 3.SSAO原理，除了SSAO还有哪些AO？ 4.阴影贴图原理 PCF是什么 PCF的卷积核有什么？ CSM？ 5.PBR说一下，几何函数的意义,IBL主要是针对高光还是漫反射光？ 6.Lod是什么？除了通过摄像机和物体距离判断Lod等级，还有什么方法？ 7.DrawCall的开销体现在哪里，就是你调用DrawCall,具体干了什么？ 8.Bloom效果怎么实现？ 9.描边算法说一下？怎么不用后处理的卷积算子做描边？卡通化渲染呢？ 10.DX12大概是怎么减少开销的，说一下 11.mipmap说一下？它对带宽有什么影响？ 12.压缩纹理有什么格式？ 13.Unity外部调试工具有哪些？ 14.UE4渲染过程大概说一下，随便说几个Pass？ 15.为什么延迟渲染不能开MSAA？ 16.有什么方法能降低一个场景中的渲染开销吗？说的越多越好 17.纹理数组知道吗？ 18.实例化是怎么做的？说一下流程和好处 19.说一下常见的遮挡剔除算法？ 20.纹理在移动设备上存储在哪里？ 21.全局光照能说一下吗？SH也说一下? 22.如果把近处平面去掉了会怎么样 23.OpenGL的VAO和VBO 24.GBuffer一般里面有什么，GBuffer要不要存储position信息，如果不存储，怎么用深度信息进行推导 25.卷积知道吗？说一下，模糊呢，为什么需要模糊？ 26.次表面反射知道吗？ 27.透明度测试和深度测试的关系？ 28.法线贴图说一下，切线空间呢？ 29.移动设备怎么减少DrawCall Overload? 30.各向异性在光照模型中如何实现？ 31.opengl中顶点数据被送入顶点缓冲区时api做了什么？ 32.phong和billn-phong区别是什么？ 33.ray marching 知道吗？ 34.opengl和dx有什么数学上的差别？ 35.Alpha Blend和Alpha Test在性能上有什么不同？ 36.光源剔除怎么做？ 37.遮挡剔除怎么做？知道Mesh Shader吗？ 38.CS知道吗？为什么有些pass放到cs而不是ps做？ 游戏数学&amp;&amp;算法： 1.点沿任意轴旋转的矩阵怎么推导 2.怎么判断一个物体是不是在你面前还是身后？ 3.A*算法说一下，它的最大缺点是什么？ 4.八叉树算法说一下，它用在哪里居多，物体运动了咋办？ 5.kd-tree和bsp说一下 6.推导View矩阵 7.如何判断射线和三角形相交 8.如何判断两个立方体是否相交(AABB包围盒相交问题) 9.如何判断点是在多边形里面还是外面？ 10.如何判断三角形和三角形相交? 11.说一下点积和乘积的几何意义？ 12.矩阵左乘和右乘区别？ 游戏开发： 1.帧同步中的帧是什么意思？ 2.常见的设计模式说一下 3.Unity的awake,enable,start 4.UE4的垃圾回收怎么实现？不会？那说说反射吧 5.UE4蓝图和C++代码通信的几个方法？ 6.ECS框架有什么好处？ 手撕算法： 游戏引擎岗对手撕算法，很多公司不怎么要求，很多根本不手撕，因为挖项目会占用很久时。但也有一些公司要，但即使有的话也不难，力扣的变形题或者 一些常见的算法题，比如考察回溯法，随便刷点就行了，难度easy到middle之间。我刷了300道力扣两遍，朋友没咋刷，没啥太大问题。 其它问题: 1.为什么不读研了?(成绩不太理想，自己早点工作也不是坏事) 2.家住在哪里，来这边会不习惯吗？ 3.咋会对游戏感兴趣，玩过什么手游端游吗？（对前后端都不熟，接触过图形，游戏也是第九艺术嘛，玩过点3A,吃鸡,MMORPG） 4.学校里面教图形吗？（不教，自学了点），本科同学里面有多少人研究图形游戏？（两百人大概两三个人） 5.有女朋友吗？（没），家里支持你来这个城市吗？（支持） 6.必问问题：你有什么想问我的？(问一两个即可) 总结 图形学相关的问题又多又杂，除了最基本的理论，还会和项目，游戏引擎，优化等结合。没有项目经验只能通过做题来勉强弥补一下。计算机基础知识除了算法和数据结构之外都不需要花太多功夫，c++的特性需要有较深入的理解。","categories":[{"name":"monolog","slug":"monolog","permalink":"http://ssssshinji.github.io/categories/monolog/"}],"tags":[{"name":"不想却又不得不工作","slug":"不想却又不得不工作","permalink":"http://ssssshinji.github.io/tags/%E4%B8%8D%E6%83%B3%E5%8D%B4%E5%8F%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%B7%A5%E4%BD%9C/"}]},{"title":"问题1：节点间通路","slug":"问题1：节点间通路","date":"2020-06-27T07:39:32.000Z","updated":"2020-07-08T10:51:08.785Z","comments":false,"path":"2020/06/27/问题1：节点间通路/","link":"2020/06/27/问题1：节点间通路","permalink":"http://ssssshinji.github.io/2020/06/27/%E9%97%AE%E9%A2%981%EF%BC%9A%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/","excerpt":"","text":"题目描述 给定有向图，设计一个算法，找出两个节点之间是否存在一条路径（提示在页尾） 个人思路 题目含义很明确，就是让手写DFS和BFS。而对于寻找路径来说，BFS是更好的选择。 个人解答 1太久没写我居然写不出来BFS，很难受。 题目解析 -无解析 标准解答（BFS） 12345678910111213141516171819202122232425static bool Search(Graph g, Vertex start, Vertex end)&#123; if(start &#x3D;&#x3D; end)return true; foreach(Vertex v in g.GetVertexs())&#123; v.state &#x3D; State.Unvisited; &#125; Queue&lt;Vertex&gt; q &#x3D; new Queue&lt;Vertex&gt;(); start.State &#x3D; State.Visiting; q.Enqueue(start); while(q.Count !&#x3D; 0)&#123; Node u &#x3D; q.Dequeue(); if(u !&#x3D; null)&#123; foreach(Vertex v in u.GetAdjacent())&#123; if(v.state &#x3D;&#x3D; State.Unvisited)&#123; if(v &#x3D;&#x3D; end)return true; else&#123; v.state &#x3D; State.Visiting; q.Enqueue(v); &#125; &#125; &#125; u.state &#x3D; State.Visted; &#125; &#125; return false; &#125; 复杂度分析 如果是单链表实现的队列，其入队时间复杂度为O(n),出队为O(1)。这段代码的时间复杂度为O(n)。双链表则为O(1)。 反思 基础知识不扎实，越是耳熟能详的算法越要自己亲手实现过才算是真正掌握了。 提示 -有两个众所周知的算法可以做到这一点，其利弊是什么？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"求职岗位调研（渲染相关）","slug":"求职岗位调研（渲染相关）","date":"2020-06-26T14:47:36.000Z","updated":"2020-06-26T16:59:18.975Z","comments":false,"path":"2020/06/26/求职岗位调研（渲染相关）/","link":"2020/06/26/求职岗位调研（渲染相关）","permalink":"http://ssssshinji.github.io/2020/06/26/%E6%B1%82%E8%81%8C%E5%B2%97%E4%BD%8D%E8%B0%83%E7%A0%94%EF%BC%88%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3%EF%BC%89/","excerpt":"","text":"字节跳动相关职位 渲染引擎研发工程师-抖音/抖音火山版/直播 职位描述 1.参与开发面向移动端的特效引擎项目； 2.参与特效引擎的核心模块开发； 3.支持特效业务的实现和落地； 4.支持特效工具链的建设。 职业要求 1.图像处理或图形学相关专业或主修过相关课程，2021届获得本科及以上学历； 2.熟练掌握C++，熟悉C11标准相关特性； 3.熟悉图形开发相关技术（OPENGL，DirectX，METAL，VULCAN）和GPU架构优先； 4.有商业引擎的实践经验优先，如：Unity，UE，CryEngine, GamePlay3D等； 5.对技术有极大的热情，学习能力强，责任心强，工作认真细致，具备良好的服务意识，具有良好的团队沟通与协作能力。 游戏引擎开发工程师 职位描述 1.参与引擎和游戏基础组件和工具的研发； 2.帮助项目组解决引擎，组件和工具问题； 3.帮助项目组研究解决方案，优化性能问题。 职业要求 1.大学本科及以上学历，计算机软件专业或数学专业优先，2021年毕业； 2.至少熟练掌握一⻔计算机语言； 3.计算机基础素养优秀，熟悉语言，数据结构，操作系统，计算机网络等； 4.熟悉Unity或Unreal引擎，熟悉计算机图形学，熟悉Shader开发； 5.有较强的学习能力，能够熟练阅读英文技术文档，具有较强的分析与解决问题能力； 6.熟悉OpenGL、DirectX、Metal或Vulkan等技术的优先； 7.熟悉移动端开发经验者优先； 游戏技术美术-游戏业务 职位描述 1.成为国内一流游戏研发团队的一员，和国内顶级的研发团队一起工作，完成挑战； 2.研究业界领先的渲染,物理，动画等技术，与美术大牛一起推动各种新技术在项目中应用落地； 3.探索游戏行业先进的技术和工具，完善项目的内容制作流程与内容生产管线，不断完善游戏的开发效率和品质体验； 4.针对各个软硬件平台进行游戏性能和表现的极致优化； 5.提取项目中的最佳实践，推动优秀技术方案的普及和广泛应用。 职业要求 1.大学本科及以上学历，2021年毕业； 2.熟悉shader，能制作符合美术需求的shader，有shader性能优化经验； 3.有良好的审美和逻辑思维能力，具备独立解决美术向技术问题的能力； 4.积极主动，能承受一定的工作压力，对游戏开发充满热情。 以下是加分项 5.热爱：热爱游戏，体验过大量且多种类型游戏，对游戏制作拥有极大热情； 6.技术：熟悉一款主流美术软件3dMax、Maya、Zbrush、Substance Painter等，熟悉Unity、Unreal等主流商业引擎； 7.奖项：在GameJam比赛中斩获过奖项； 8.积累：有自己的技术博客、开源项目者，有过海外留学经历者，或有游戏公司实习经验。 完美世界相关职位 游戏技术美术工程师 职位描述 1.负责引擎相关工具的开发与维护； 2.根据美术需求编写相关shader； 3.对美术工作中遇到的问题提供技术支持； 4.制定美术资源制作规范； 5.优化效率，了解相关性能分析工具。 岗位要求 1.热爱生活、热爱游戏，对玩游戏和做游戏充满激情，并渴望做出成功的游戏； 2.熟练掌握C#语言，了解或者熟悉MaxScript、JavaScript、Python； 3.熟悉计算机图形渲染管线和基础知识；能根据需求独立编写shader； 4.了解3D美术相关工具，包括：3DMax、Substance Painter、Photoshop等； 5.熟悉Unity3D相关知识，有实际开发经验者优先考虑。 引擎开发程师 职位描述 1.负责3D游戏引擎和工具的开发； 2.对渲染关技术进行前瞻性研究； 3.负责引擎的改进和维护工作。 岗位要求 1.熟练掌握C++知识与多线程技术 ； 2.熟练掌握3D数学、渲染相关算法与数据结构 ； 3.掌握D3D或OpenGL渲染管线流程 ； 4.掌握图形API和Shader语言（D3D hlsl 或 OpenGL glsl）； 5.有性能优先的开发思路，懂得基本的代码优化技巧； 6.独立思考和分析能力，面对复杂问题能够快速找到答案 ； 7. 熟练的沟通与表达能力，有团队合作精神 。 巨人网络 游戏引擎开发工程师 职位描述 1.负责3D引擎的相关开发，如场景管理，人物动画，特效，SHADER，动作融合，粒子等; 2.负责游戏美术相关插件编写； 3.负责引擎相关工具开发，优化3D引擎的性能。 岗位要求 1.计算机基础知识扎实，有一定的编程经验； 2.熟悉C++、STL及各种设计模式,熟悉各种数据结构和算法； 3.熟悉3D图形学原理,熟悉3d图形的常用技术,有较强的数学功底； 4.熟悉HLSL,Shader编写； 5.具备良好的逻辑思维、综合分析能力，以及团队协作能力。有主动学习的能力和意愿，对技术研究有热情; 6.硕士及以上学历，计算机或相关专业。 IGG 高级技术美术 职位描述 1.和美术人员、引擎程序员一起设计渲染方案，负责Shader编写，实现优秀的美术效果 2.充分全面了解美术流程各环节的需求和问题，及时高质量地提供开发工具，技术指导和解决方案； 3.制定美术资源规范，监督项目人员规范执行； 4.对游戏性能进行Profiling，设计优化方案； 岗位要求 1.熟悉计算机图形学，包括图形管线及图形API，着色器语言，有渲染器设计经验者加分； 2.熟练精通Unity游戏引擎，有Unreal或其他商业游戏引擎经验者加分； 3.熟悉编程和脚本语言：Maxscript, Mel, Python至少一项，C#/C++至少一项，有美术软件工具集或引擎开发经验者加分； 4.熟悉常用美术工具，如Max/Maya，Photoshop，Substance，ZBrush等，并具备较好的审美能力和美术功底； 5.熟悉常用的PC及移动端Profiling工具，GPA，Renderdoc，Nsight，SnapdragonProfiler等； 6.良好的沟通交流能力，工作积极主动，能承受一定的工作压力，有英文交流能力者加分； 7.8+年游戏开发经验，5+年技术美术相关经验，具备次世代游戏项目开发经验者加分。 分析及总结 渲染相关的工作大致分为两种，第一个方向是研发引擎类，该类除了图形学的技术，还重视个人的编程能力和计算机基础知识（尤其是数据结构）的扎实程度。作为应对，刷题是一个很好的选择。另一个方向是技美，该类稍微放宽了计算机基础知识及编程能力的门槛，但相对的，需要对shader有更好的掌握，并且至少熟悉一种商业3D软件，同时对美术素养也有一定要求。平时自己制作shader和捏人对这方面是个不错的锻炼。 可以选择的有各个游戏公司（技美），视频处理相关的公司（渲染引擎研发），想研发自己渲染/游戏引擎的公司。总的来说，就职范围不广，市场需求较少，且要求较高。感觉基本是凉了 1. 2. 3. 4.对游戏性能进行Profiling，设计优化方案； 5. 6. 7.","categories":[{"name":"monolog","slug":"monolog","permalink":"http://ssssshinji.github.io/categories/monolog/"}],"tags":[{"name":"不想却又不得不工作","slug":"不想却又不得不工作","permalink":"http://ssssshinji.github.io/tags/%E4%B8%8D%E6%83%B3%E5%8D%B4%E5%8F%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%B7%A5%E4%BD%9C/"}]},{"title":"问题1：移除重复节点","slug":"问题1：移除重复节点","date":"2020-06-26T13:27:58.000Z","updated":"2020-07-05T16:38:33.654Z","comments":false,"path":"2020/06/26/问题1：移除重复节点/","link":"2020/06/26/问题1：移除重复节点","permalink":"http://ssssshinji.github.io/2020/06/26/%E9%97%AE%E9%A2%981%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目描述 编写代码，移除未排序链表中的重复节点。进阶：如果不得使用临时缓冲区，该怎么解决？（提示在页尾） 个人思路 新建一个字典(dictionary)，依次把每个节点的value当作键添加到字典中，字典的值随便取。每次碰到新节点时先调用CintainsKey(key)方法，因为字典中键的唯一性，返回true时说明该节点重复。不使用缓冲区不会做。 个人解答 123456789101112void deleteDups(LinkedListNode node)&#123; Dictionary&lt;key,value&gt; dic &#x3D; new Dictionary&lt;key,value&gt;(); LinkedListNode previous &#x3D; null; while(node !&#x3D; null)&#123; if(dic.ContainsKey(node.value))&#123; previous.Next &#x3D; node.next; &#125; else &#123; dic.Add(node.value); previous &#x3D; node; &#125; node.next; &#125; 题目解析 -要想移除链表中的重复节点，需要设法记录有哪些是重复的。这里只要用到一个简单的散列表。 标准解答 12345678910111213void deleteDups(LinkedListNode node)&#123; HashSet&lt;item&gt; set &#x3D; new HashSet&lt;item&gt;(); LinkedListNode previous &#x3D; null; while(node !&#x3D; null)&#123; if(set.Contains(node.value))&#123; previous.Next &#x3D; node.next; &#125; else &#123; set.Add(node.value); previous &#x3D; node; &#125; node.next; &#125; &#125; 复杂度分析 这段代码的时间复杂度为O(n),n为链表节点数目。 不使用临时缓冲区的情况 如果不使用额外的缓冲区，可以使用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的节点时候重复。 标准解答（不使用临时缓冲区） 1234567891011121314void deleteDups(LinkedListNode head)&#123; LinkedListNode current &#x3D; head; while(current !&#x3D; null)&#123; LinkedListNode runner &#x3D; current; while(runner.next !&#x3D; null)&#123; if(current.value &#x3D;&#x3D; runner.next.value)&#123; runner.next &#x3D; runner.next.next; &#125; else&#123; runner &#x3D; runner.next; &#125; &#125; current &#x3D; current.next; &#125; 复杂度分析 这段代码的空间复杂度为O(1)，但时间复杂度为O(N^2)。 反思 第一问基本思路相同，刚好复习一下dictionary和hashSet的区别。对于不使用缓冲区的情况，老想着怎么样轻易解决，却忘了大部分算法都是先用最简单的方式得出结果再慢慢优化的，忽略了双指针循环。 提示 -你有没有试过一个散列表？你应该可以通过一次链表遍历做到这一点。 -没有额外的空间，你需要O(N^2)的时间。尝试使用两个指针，其中第二个指针在第一个指针之前搜索。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"问题1：判定字符是否唯一","slug":"问题1：判定字符是否唯一","date":"2020-06-25T07:36:02.000Z","updated":"2020-06-30T18:05:34.910Z","comments":false,"path":"2020/06/25/问题1：判定字符是否唯一/","link":"2020/06/25/问题1：判定字符是否唯一","permalink":"http://ssssshinji.github.io/2020/06/25/%E9%97%AE%E9%A2%981%EF%BC%9A%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/","excerpt":"","text":"题目描述 实现一个算法，确定一个字符串的所有字符是否不全都不同。假使不允许使用额外的数据结构，又该如何处理？（提示在页尾） 个人思路 如果可用其他的数据结构，创建一个list，逐个将字符加入到list中。在加入前调用List.Contains()查询是否已经有该字符，有则报错。如果不可用别的数据结构，按照ASCII码排序，再看是否有相邻字符相等，或者拿每一个和剩下的字符比较。 个人解答（使用数据结构） 1234567891011121314151617Boolean isUnique(string str)&#123; ArrayList list &#x3D; new ArrayList(); for (int i &#x3D; 0; i &lt; str.Length; i++) &#123; if (!list.Contains(str[i])) &#123; list.Add(str[i]); &#125; else &#123; return false; &#125; &#125; return true;&#125; 题目解析 -要关注字符串是ASCII串还是Unicode串，这关系到你需要使用的数组大小（在标准解答中，按照ASCII处理） -如果字符串长度超过了字母表中不同字符的个数(ASCII:128)，直接返回false 标准解答（使用数据结构） 1234567891011121314Boolean isUnique(string str)&#123; if(str.Length &gt; 128)return false; bool[] char_set &#x3D; new bool[128]; for(int i &#x3D; 0; i &lt; str.Length; i++)&#123; int val &#x3D; str[i]; &#x2F;&#x2F;在字符串中已找到过 if(char_set[val])&#123; return false; &#125; char_set[val] &#x3D; true; &#125; return true;&#125; 复杂度分析 这段代码的时间复杂度为O(n)，其中n为字符串长度。空间复杂度为O(1)。你也可以认为时间复杂度是O(1)，因为for循环的迭代永远不会超过128次。如果不想假设字符集是恒定的，也可以认为空间复杂度是O(c )，时间复杂度是O(min(c,n))或者O(c )，其中c是字符集的大小。 不使用数据结构的情况 思路和自己的思路相同，无代码解析。 反思 没有注意到字符数量是有限的，从而利用数组解决问题。类似的使用数组的方式还有很多，需要注意。 提示 -用散列表试试 -位向量有用吗 -你能用O(NlogN)的时间复杂度解决它吗","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"算法常见面试题1-5","slug":"算法常见面试题1-5","date":"2020-06-24T13:14:39.000Z","updated":"2020-06-25T07:42:03.548Z","comments":false,"path":"2020/06/24/算法常见面试题1-5/","link":"2020/06/24/算法常见面试题1-5","permalink":"http://ssssshinji.github.io/2020/06/24/%E7%AE%97%E6%B3%95%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%981-5/","excerpt":"","text":"1.算法的几个特征是什么？ 1.有穷性 (Finiteness) 指算法必须在执行有限个步骤之后终止。 2.确切性 (Definiteness) 算法的每一步骤必须有确切的定义。 3.输入项 (Input) 一个算法有0个或者多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。 4.输出项 (Output) 一个算法有一个或者多个输出，以反映对输入数据加工后的结果。没有输出的算法毫无意义。 5.可行性 (Effectiveness) 算法中执行的任何计算步骤都可以被分解为基本的可执行操作，即每个计算步骤都可以在有限时间内完成，也称之为有效性。 2.算法复杂性的定义。大O、θ、Ω、小o分别表示的含义是什么？ 算法复杂度分为空间复杂度S(n)和时间复杂度T(n)。 空间复杂度指在运行过程中为局部变量分配的存储空间的大小，它包括参数列表中的形参变量和函数体中定义的局部变量两个部分，记作S(n) = O(f(n))。时间复杂度定性描述了该算法的运行时间，记作T(n) = O(f(n))。 如果算法A需要的时间与f(n)成正比，则称算法A为f(n)阶，记为O(f(n))。函数f(n)称为算法的增率函数(growth-rate function)。该表示法使用大学字母O(Order)来表示，故称为大O表示法。若规模为n的问题需要的时间与n成正比，则问题表示为O(n),即n阶。若需要的时间与\\(n^2\\)成正比，则问题表示为O(\\(n^2\\)),以此类推。**O并不是一个函数。**他的属性有： 1.可忽略算法增率函数的低阶项 2.可忽略算法增率函数中高阶项的倍输常量 3.O(f(n)) + O(g(n))=O(f(n)+g(n))可组合增率函数 形式化定义： 给定2个正值函数f和g，定义：f(n) = O(g(n)),条件为：存在正实数c和N，使得对于所有的n\\(\\ge\\)N,有|f(n)|\\(\\le\\)|cg(n)|。上述的定义表明，当n足够大，大过一个特定的N时，且存在一个正数c，使得|f(n)|不大于|cg(n)|,则f是g的O表示。关系可以解释为g(n)是f(n)的一个上界，也可以理解为f增长的速度最多和g一样快，而不会超过g。 名称 表示法 定义 Tilde f(n)~g(n) $$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 1$$ Big Oh f(n) is O(g(n)) $$\\exists c \\gt 0, n_0 \\ge 0$$such that \\( 0 \\le f(n) \\le c \\cdot g(n)\\) for all \\(n \\ge n_0\\) Big Omega f(n) is \\(\\Omega\\)(g(n)) g(n) is O(f(n)) Big Theta f(n) is \\(\\Theta\\)(g(n)) f(n) is both O(g(n)) and \\(\\Omega\\)(g(n)) Little oh f(n) is o(g(n)) $$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0$$ Little omega f(n) is \\(\\omega\\)(g(n)) g(n) is o(f(n)) 3.递归算法的定义，及其两要素。 递归就是循环定义，对于一个方法来说，就是自己调用自己。 两要素： -终止条件 -递推公式 经典汉诺塔问题(c#实现) 1234567891011121314151617181920212223using System;namespace Hanoi_Tower&#123; class Program &#123; static void Main(string[] args) &#123; int n &#x3D; Int32.Parse(Console.ReadLine()); Hanoi(n,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#125; private static void Hanoi(int n, string a,string b, string c)&#123; if(n &#x3D;&#x3D; 1)Move(a,c); else &#123; Hanoi(n-1, a, c, b); Move(a,c); Hanoi(n-1, b, a, c); &#125; &#125; private static void Move(string origin, string des)&#123; Console.WriteLine(origin+ &quot;---&gt;&quot; + des); &#125; &#125;&#125; 4.分治算法的思想，经典的分治算法(全排列、二分搜索、归并排序、快速排序、线性时间选择、最接近点对问题)。","categories":[],"tags":[]},{"title":"求职之前","slug":"求职之前","date":"2020-06-24T10:31:25.000Z","updated":"2020-06-25T09:20:26.342Z","comments":true,"path":"2020/06/24/求职之前/","link":"","permalink":"http://ssssshinji.github.io/2020/06/24/%E6%B1%82%E8%81%8C%E4%B9%8B%E5%89%8D/","excerpt":"","text":"一些思考 找工作真的是件非常困难的事啊，动不动就会和人生目标啦理想啦联合在一起。虽然很赞同“世界是荒谬的”这一观点，不过人不给自己找个目标就难以生活下去啊。真是麻烦死了。 话说回来我也没想过实现什么伟业，自己能有个感兴趣的小目标，实现了之后能有小小的自我满足，就够了。那么来检讨一下目前可选择的方案。 读博士教书 说到底外人说的博士起点高，层次高之类的老生常谈对我而言都是虚的。我只是构思了一个工作轻松，闲暇时间可以打打游戏，搞搞创作之类的轻松生活而已。搞科研，传道授业解惑之类的，有兴趣，但是不大，也没那个倔强劲。 工作 读博的话还能从目前的人生中稍微取取经，思考工作真是让人无从下手。做都没做过的事情，要怎么来评判啊。按着兴趣排序的话，第一应该是渲染工程师吧。面试看重的是扎实的计算机基础，shader的编写能力，最好再对一两个软件得心应手。说实话应该是最接近我目前现状的职位要求了，而且感觉能从中得到自我满足，还不错。接着是引擎开发工程师吗？兴趣还可以，困难应该会比较多，比前一个职位更加看重编程能力。主要在于架构的设计，代码的调试，以及你脑中的代码量够不够你想到解决问题的方法。我不知道我目前的兴趣能不能撑很久。3D模型师？总是看网上太太们的作品看得津津有味，跃跃欲试，如果当成工作的话会怎么样呢。个人感觉和之前的职业对比区别较大，需要培养的是设计的思维和美感，经过大量的练习来提高自己的软件熟练度。在我心里已经把她归到属于设计类的行业了。那么，果然还是当作自己的业余爱好比较好吧，不然读计算机干嘛呢。。换句话说，凭什么竞争的过专业的3D设计师呢。 有时候列举出来才懂排除法的妙。基本就只有第一条路可以走了，那么要做的准备就很明确了。提高专业素养保证自己的基础知识储备和计算机图形学相关的知识储备，了解渲染前沿的技术以及成熟程度，最好多手写shader的代码，3D软件的使用是个加分项，可以适当的看一看，不过还是别太花时间比较好。科研什么的，还是往后放一放吧（虽然本来也拖得够久了。。。）","categories":[{"name":"自白","slug":"自白","permalink":"http://ssssshinji.github.io/categories/%E8%87%AA%E7%99%BD/"}],"tags":[{"name":"对工作的牢骚","slug":"对工作的牢骚","permalink":"http://ssssshinji.github.io/tags/%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%89%A2%E9%AA%9A/"}]},{"title":"图片测试","slug":"image","date":"2020-06-20T11:53:43.000Z","updated":"2020-06-24T10:50:10.571Z","comments":false,"path":"2020/06/20/image/","link":"2020/06/20/image","permalink":"http://ssssshinji.github.io/2020/06/20/image/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"幸运星 第一话（外链视频测试）","slug":"video","date":"2020-06-20T09:32:57.000Z","updated":"2020-06-24T12:33:37.079Z","comments":false,"path":"2020/06/20/video/","link":"2020/06/20/video","permalink":"http://ssssshinji.github.io/2020/06/20/video/","excerpt":"","text":"","categories":[{"name":"动漫","slug":"动漫","permalink":"http://ssssshinji.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"幸运星","slug":"幸运星","permalink":"http://ssssshinji.github.io/tags/%E5%B9%B8%E8%BF%90%E6%98%9F/"}]}],"categories":[{"name":"问题精析","slug":"问题精析","permalink":"http://ssssshinji.github.io/categories/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90/"},{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"name":"monolog","slug":"monolog","permalink":"http://ssssshinji.github.io/categories/monolog/"},{"name":"自白","slug":"自白","permalink":"http://ssssshinji.github.io/categories/%E8%87%AA%E7%99%BD/"},{"name":"动漫","slug":"动漫","permalink":"http://ssssshinji.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"},{"name":"c#","slug":"c","permalink":"http://ssssshinji.github.io/tags/c/"},{"name":"排序和查找","slug":"排序和查找","permalink":"http://ssssshinji.github.io/tags/%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E6%89%BE/"},{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"c和c++","slug":"c和c","permalink":"http://ssssshinji.github.io/tags/c%E5%92%8Cc/"},{"name":"栈与队列","slug":"栈与队列","permalink":"http://ssssshinji.github.io/tags/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"递归与动态规划","slug":"递归与动态规划","permalink":"http://ssssshinji.github.io/tags/%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://ssssshinji.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"数学与逻辑题","slug":"数学与逻辑题","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E5%AD%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E9%A2%98/"},{"name":"不想却又不得不工作","slug":"不想却又不得不工作","permalink":"http://ssssshinji.github.io/tags/%E4%B8%8D%E6%83%B3%E5%8D%B4%E5%8F%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%B7%A5%E4%BD%9C/"},{"name":"对工作的牢骚","slug":"对工作的牢骚","permalink":"http://ssssshinji.github.io/tags/%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%89%A2%E9%AA%9A/"},{"name":"幸运星","slug":"幸运星","permalink":"http://ssssshinji.github.io/tags/%E5%B9%B8%E8%BF%90%E6%98%9F/"}]}