{"meta":{"title":"inside","subtitle":"","description":"","author":"zyt","url":"http://Ssssshinji.github.io","root":"/"},"pages":[],"posts":[{"title":"问题1：节点间通路","slug":"问题1：节点间通路","date":"2020-06-27T07:39:32.000Z","updated":"2020-06-27T09:01:47.972Z","comments":false,"path":"2020/06/27/问题1：节点间通路/","link":"2020/06/27/问题1：节点间通路","permalink":"http://ssssshinji.github.io/2020/06/27/%E9%97%AE%E9%A2%981%EF%BC%9A%E8%8A%82%E7%82%B9%E9%97%B4%E9%80%9A%E8%B7%AF/","excerpt":"","text":"题目描述 给定有向图，设计一个算法，找出两个节点之间是否存在一条路径（提示在页尾） 个人思路 题目含义很明确，就是让手写DFS和BFS。而对于寻找路径来说，BFS是更好的选择。 个人解答 1太久没写我居然写不出来BFS，很难受。 题目解析 -无解析 标准解答（BFS） 12345678910111213141516171819202122232425static bool Search(Graph g,Vertex start, Vertex end)&#123; if(start &#x3D;&#x3D; end)return true; foreach(Vertex v in g.GetVertexs())&#123; v.state &#x3D; State.Unvisited; &#125; Queue&lt;Vertex&gt; q &#x3D; new Queue&lt;Vertex&gt;(); start.State &#x3D; State.Visiting; q.Enqueue(start); while(q.Count !&#x3D; 0)&#123; Node u &#x3D; q.Dequeue(); if(u !&#x3D; null)&#123; foreach(Vertex v in u.GetAdjacent())&#123; if(v.state &#x3D;&#x3D; State.Unvisited)&#123; if(v &#x3D;&#x3D; end)return true; else&#123; v.state &#x3D; State.Visiting; q.Enqueue(v); &#125; &#125; &#125; u.state &#x3D; State.Visted; &#125; &#125; return false; &#125; 复杂度分析 如果是单链表实现的队列，其入队时间复杂度为O(n),出队为O(1)。这段代码的时间复杂度为O(n)。双链表则为O(1)。 反思 基础知识不扎实，越是耳熟能详的算法越要自己亲手实现过才算是真正掌握了。 提示 -有两个众所周知的算法可以做到这一点，其利弊是什么？","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"}]},{"title":"求职岗位调研（渲染相关）","slug":"求职岗位调研（渲染相关）","date":"2020-06-26T14:47:36.000Z","updated":"2020-06-26T16:59:18.975Z","comments":false,"path":"2020/06/26/求职岗位调研（渲染相关）/","link":"2020/06/26/求职岗位调研（渲染相关）","permalink":"http://ssssshinji.github.io/2020/06/26/%E6%B1%82%E8%81%8C%E5%B2%97%E4%BD%8D%E8%B0%83%E7%A0%94%EF%BC%88%E6%B8%B2%E6%9F%93%E7%9B%B8%E5%85%B3%EF%BC%89/","excerpt":"","text":"字节跳动相关职位 渲染引擎研发工程师-抖音/抖音火山版/直播 职位描述 1.参与开发面向移动端的特效引擎项目； 2.参与特效引擎的核心模块开发； 3.支持特效业务的实现和落地； 4.支持特效工具链的建设。 职业要求 1.图像处理或图形学相关专业或主修过相关课程，2021届获得本科及以上学历； 2.熟练掌握C++，熟悉C11标准相关特性； 3.熟悉图形开发相关技术（OPENGL，DirectX，METAL，VULCAN）和GPU架构优先； 4.有商业引擎的实践经验优先，如：Unity，UE，CryEngine, GamePlay3D等； 5.对技术有极大的热情，学习能力强，责任心强，工作认真细致，具备良好的服务意识，具有良好的团队沟通与协作能力。 游戏引擎开发工程师 职位描述 1.参与引擎和游戏基础组件和工具的研发； 2.帮助项目组解决引擎，组件和工具问题； 3.帮助项目组研究解决方案，优化性能问题。 职业要求 1.大学本科及以上学历，计算机软件专业或数学专业优先，2021年毕业； 2.至少熟练掌握一⻔计算机语言； 3.计算机基础素养优秀，熟悉语言，数据结构，操作系统，计算机网络等； 4.熟悉Unity或Unreal引擎，熟悉计算机图形学，熟悉Shader开发； 5.有较强的学习能力，能够熟练阅读英文技术文档，具有较强的分析与解决问题能力； 6.熟悉OpenGL、DirectX、Metal或Vulkan等技术的优先； 7.熟悉移动端开发经验者优先； 游戏技术美术-游戏业务 职位描述 1.成为国内一流游戏研发团队的一员，和国内顶级的研发团队一起工作，完成挑战； 2.研究业界领先的渲染,物理，动画等技术，与美术大牛一起推动各种新技术在项目中应用落地； 3.探索游戏行业先进的技术和工具，完善项目的内容制作流程与内容生产管线，不断完善游戏的开发效率和品质体验； 4.针对各个软硬件平台进行游戏性能和表现的极致优化； 5.提取项目中的最佳实践，推动优秀技术方案的普及和广泛应用。 职业要求 1.大学本科及以上学历，2021年毕业； 2.熟悉shader，能制作符合美术需求的shader，有shader性能优化经验； 3.有良好的审美和逻辑思维能力，具备独立解决美术向技术问题的能力； 4.积极主动，能承受一定的工作压力，对游戏开发充满热情。 以下是加分项 5.热爱：热爱游戏，体验过大量且多种类型游戏，对游戏制作拥有极大热情； 6.技术：熟悉一款主流美术软件3dMax、Maya、Zbrush、Substance Painter等，熟悉Unity、Unreal等主流商业引擎； 7.奖项：在GameJam比赛中斩获过奖项； 8.积累：有自己的技术博客、开源项目者，有过海外留学经历者，或有游戏公司实习经验。 完美世界相关职位 游戏技术美术工程师 职位描述 1.负责引擎相关工具的开发与维护； 2.根据美术需求编写相关shader； 3.对美术工作中遇到的问题提供技术支持； 4.制定美术资源制作规范； 5.优化效率，了解相关性能分析工具。 岗位要求 1.热爱生活、热爱游戏，对玩游戏和做游戏充满激情，并渴望做出成功的游戏； 2.熟练掌握C#语言，了解或者熟悉MaxScript、JavaScript、Python； 3.熟悉计算机图形渲染管线和基础知识；能根据需求独立编写shader； 4.了解3D美术相关工具，包括：3DMax、Substance Painter、Photoshop等； 5.熟悉Unity3D相关知识，有实际开发经验者优先考虑。 引擎开发程师 职位描述 1.负责3D游戏引擎和工具的开发； 2.对渲染关技术进行前瞻性研究； 3.负责引擎的改进和维护工作。 岗位要求 1.熟练掌握C++知识与多线程技术 ； 2.熟练掌握3D数学、渲染相关算法与数据结构 ； 3.掌握D3D或OpenGL渲染管线流程 ； 4.掌握图形API和Shader语言（D3D hlsl 或 OpenGL glsl）； 5.有性能优先的开发思路，懂得基本的代码优化技巧； 6.独立思考和分析能力，面对复杂问题能够快速找到答案 ； 7. 熟练的沟通与表达能力，有团队合作精神 。 巨人网络 游戏引擎开发工程师 职位描述 1.负责3D引擎的相关开发，如场景管理，人物动画，特效，SHADER，动作融合，粒子等; 2.负责游戏美术相关插件编写； 3.负责引擎相关工具开发，优化3D引擎的性能。 岗位要求 1.计算机基础知识扎实，有一定的编程经验； 2.熟悉C++、STL及各种设计模式,熟悉各种数据结构和算法； 3.熟悉3D图形学原理,熟悉3d图形的常用技术,有较强的数学功底； 4.熟悉HLSL,Shader编写； 5.具备良好的逻辑思维、综合分析能力，以及团队协作能力。有主动学习的能力和意愿，对技术研究有热情; 6.硕士及以上学历，计算机或相关专业。 IGG 高级技术美术 职位描述 1.和美术人员、引擎程序员一起设计渲染方案，负责Shader编写，实现优秀的美术效果 2.充分全面了解美术流程各环节的需求和问题，及时高质量地提供开发工具，技术指导和解决方案； 3.制定美术资源规范，监督项目人员规范执行； 4.对游戏性能进行Profiling，设计优化方案； 岗位要求 1.熟悉计算机图形学，包括图形管线及图形API，着色器语言，有渲染器设计经验者加分； 2.熟练精通Unity游戏引擎，有Unreal或其他商业游戏引擎经验者加分； 3.熟悉编程和脚本语言：Maxscript, Mel, Python至少一项，C#/C++至少一项，有美术软件工具集或引擎开发经验者加分； 4.熟悉常用美术工具，如Max/Maya，Photoshop，Substance，ZBrush等，并具备较好的审美能力和美术功底； 5.熟悉常用的PC及移动端Profiling工具，GPA，Renderdoc，Nsight，SnapdragonProfiler等； 6.良好的沟通交流能力，工作积极主动，能承受一定的工作压力，有英文交流能力者加分； 7.8+年游戏开发经验，5+年技术美术相关经验，具备次世代游戏项目开发经验者加分。 分析及总结 渲染相关的工作大致分为两种，第一个方向是研发引擎类，该类除了图形学的技术，还重视个人的编程能力和计算机基础知识（尤其是数据结构）的扎实程度。作为应对，刷题是一个很好的选择。另一个方向是技美，该类稍微放宽了计算机基础知识及编程能力的门槛，但相对的，需要对shader有更好的掌握，并且至少熟悉一种商业3D软件，同时对美术素养也有一定要求。平时自己制作shader和捏人对这方面是个不错的锻炼。 可以选择的有各个游戏公司（技美），视频处理相关的公司（渲染引擎研发），想研发自己渲染/游戏引擎的公司。总的来说，就职范围不广，市场需求较少，且要求较高。感觉基本是凉了 1. 2. 3. 4.对游戏性能进行Profiling，设计优化方案； 5. 6. 7.","categories":[{"name":"monolog","slug":"monolog","permalink":"http://ssssshinji.github.io/categories/monolog/"}],"tags":[{"name":"不想却又不得不工作","slug":"不想却又不得不工作","permalink":"http://ssssshinji.github.io/tags/%E4%B8%8D%E6%83%B3%E5%8D%B4%E5%8F%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%B7%A5%E4%BD%9C/"}]},{"title":"问题1：移除重复节点","slug":"问题1：移除重复节点","date":"2020-06-26T13:27:58.000Z","updated":"2020-06-27T07:43:33.887Z","comments":false,"path":"2020/06/26/问题1：移除重复节点/","link":"2020/06/26/问题1：移除重复节点","permalink":"http://ssssshinji.github.io/2020/06/26/%E9%97%AE%E9%A2%981%EF%BC%9A%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/","excerpt":"","text":"题目描述 编写代码，移除未排序链表中的重复节点。进阶：如果不得使用临时缓冲区，该怎么解决？（提示在页尾） 个人思路 新建一个字典(dictionary)，依次把每个节点的value当作键添加到字典中，字典的值随便取。每次碰到新节点时先调用CintainsKey(key)方法，因为字典中键的唯一性，返回true时说明该节点重复。不使用缓冲区不会做。 个人解答 123456789101112void deleteDups(LinkedListNode node)&#123; Dictionary&lt;key,value&gt; dic &#x3D; new Dictionary&lt;key,value&gt;(); LinkedListNode previous &#x3D; null; while(node !&#x3D; null)&#123; if(dic.ContainsKey(node.value))&#123; previous.Next &#x3D; node.next; &#125; else &#123; dic.Add(node.value); previous &#x3D; node; &#125; node.next; &#125; 题目解析 -要想移除链表中的重复节点，需要设法记录有哪些是重复的。这里只要用到一个简单的散列表。 标准解答 12345678910111213void deleteDups(LinkedListNode node)&#123; HashSet&lt;item&gt; set &#x3D; new HashSet&lt;item&gt;(); LinkedListNode previous &#x3D; null; while(node !&#x3D; null)&#123; if(set.Contains(node.value))&#123; previous.Next &#x3D; node.next; &#125; else &#123; set.Add(node.value); previous &#x3D; node; &#125; node.next; &#125; &#125; 复杂度分析 这段代码的时间复杂度为O(n),n为链表节点数目。 不使用临时缓冲区的情况 如果不使用额外的缓冲区，可以使用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的节点时候重复。 标准解答（不使用临时缓冲区） 1234567891011121314void deleteDups(LinkedListNode head)&#123; LinkedListNode current &#x3D; head; while(current !&#x3D; null)&#123; LinkedListNode runner &#x3D; current; while(runner.next !&#x3D; null)&#123; if(current.value &#x3D;&#x3D; runner.next.value)&#123; runner.next &#x3D; runner.next.next; &#125; else&#123; runner &#x3D; runner.next; &#125; &#125; current &#x3D; current.next; &#125; 复杂度分析 这段代码的空间复杂度为O(1)，但时间复杂度为O(N^2)。 反思 第一问基本思路相同，刚好复习一下dictionary和hashSet的区别。对于不使用缓冲区的情况，老想着怎么样轻易解决，却忘了大部分算法都是先用最简单的方式得出结果再慢慢优化的，忽略了双指针循环。 提示 -你有没有试过一个散列表？你应该可以通过一次链表遍历做到这一点。 -没有额外的空间，你需要O(N^2)的时间。尝试使用两个指针，其中第二个指针在第一个指针之前搜索。","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"}]},{"title":"Questionon_1","slug":"Questionon-1","date":"2020-06-25T07:41:27.000Z","updated":"2020-06-25T07:41:27.570Z","comments":true,"path":"2020/06/25/Questionon-1/","link":"","permalink":"http://ssssshinji.github.io/2020/06/25/Questionon-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"问题1：判定字符是否唯一","slug":"问题1：判定字符是否唯一","date":"2020-06-25T07:36:02.000Z","updated":"2020-06-25T09:16:33.958Z","comments":false,"path":"2020/06/25/问题1：判定字符是否唯一/","link":"2020/06/25/问题1：判定字符是否唯一","permalink":"http://ssssshinji.github.io/2020/06/25/%E9%97%AE%E9%A2%981%EF%BC%9A%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/","excerpt":"","text":"题目描述 实现一个算法，确定一个字符串的所有字符是否不全都不同。假使不允许使用额外的数据结构，又该如何处理？（提示在页尾） 个人思路 如果可用其他的数据结构，创建一个list，逐个将字符加入到list中。在加入前调用List.Contains()查询是否已经有该字符，有则报错。如果不可用别的数据结构，按照ASCII码排序，再看是否有相邻字符相等，或者拿每一个和剩下的字符比较。 个人解答（使用数据结构） 1234567891011121314151617Boolean isUnique(string str)&#123; ArrayList list &#x3D; new ArrayList(); for (int i &#x3D; 0; i &lt; str.Length; i++) &#123; if (!list.Contains(str[i])) &#123; list.Add(str[i]); &#125; else &#123; return false; &#125; &#125; return true;&#125; 题目解析 -要关注字符串是ASCII串还是Unicode串，这关系到你需要使用的数组大小（在标准解答中，按照ASCII处理） -如果字符串长度超过了字母表中不同字符的个数(ASCII:128)，直接返回false 标准解答（使用数据结构） 1234567891011121314Boolean isUnique(string str)&#123; if(str.Length &gt; 128)return false; bool[] char_set &#x3D; new bool[128]; for(int i &#x3D; 0; i &lt; str.Length; i++)&#123; int val &#x3D; str[i]; &#x2F;&#x2F;在字符串中已找到过 if(char_set[val])&#123; return false; &#125; char_set[val] &#x3D; true; &#125; return true;&#125; 复杂度分析 这段代码的时间复杂度为O(n)，其中n为字符串长度。空间复杂度为O(1)。你也可以认为时间复杂度是O(1)，因为for循环的迭代永远不会超过128次。如果不想假设字符集是恒定的，也可以认为空间复杂度是O(c )，时间复杂度是O(min(c,n))或者O(c )，其中c是字符集的大小。 不使用数据结构的情况 思路和自己的思路相同，无代码解析。 反思 没有注意到字符数量是有限的，从而利用数组解决问题。类似的使用数组的方式还有很多，需要注意。 提示 -用散列表试试 -位向量有用吗 -你能用O(NlogN)的时间复杂度解决它吗","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"算法常见面试题1-5","slug":"算法常见面试题1-5","date":"2020-06-24T13:14:39.000Z","updated":"2020-06-25T07:42:03.548Z","comments":false,"path":"2020/06/24/算法常见面试题1-5/","link":"2020/06/24/算法常见面试题1-5","permalink":"http://ssssshinji.github.io/2020/06/24/%E7%AE%97%E6%B3%95%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%981-5/","excerpt":"","text":"1.算法的几个特征是什么？ 1.有穷性 (Finiteness) 指算法必须在执行有限个步骤之后终止。 2.确切性 (Definiteness) 算法的每一步骤必须有确切的定义。 3.输入项 (Input) 一个算法有0个或者多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。 4.输出项 (Output) 一个算法有一个或者多个输出，以反映对输入数据加工后的结果。没有输出的算法毫无意义。 5.可行性 (Effectiveness) 算法中执行的任何计算步骤都可以被分解为基本的可执行操作，即每个计算步骤都可以在有限时间内完成，也称之为有效性。 2.算法复杂性的定义。大O、θ、Ω、小o分别表示的含义是什么？ 算法复杂度分为空间复杂度S(n)和时间复杂度T(n)。 空间复杂度指在运行过程中为局部变量分配的存储空间的大小，它包括参数列表中的形参变量和函数体中定义的局部变量两个部分，记作S(n) = O(f(n))。时间复杂度定性描述了该算法的运行时间，记作T(n) = O(f(n))。 如果算法A需要的时间与f(n)成正比，则称算法A为f(n)阶，记为O(f(n))。函数f(n)称为算法的增率函数(growth-rate function)。该表示法使用大学字母O(Order)来表示，故称为大O表示法。若规模为n的问题需要的时间与n成正比，则问题表示为O(n),即n阶。若需要的时间与\\(n^2\\)成正比，则问题表示为O(\\(n^2\\)),以此类推。**O并不是一个函数。**他的属性有： 1.可忽略算法增率函数的低阶项 2.可忽略算法增率函数中高阶项的倍输常量 3.O(f(n)) + O(g(n))=O(f(n)+g(n))可组合增率函数 形式化定义： 给定2个正值函数f和g，定义：f(n) = O(g(n)),条件为：存在正实数c和N，使得对于所有的n\\(\\ge\\)N,有|f(n)|\\(\\le\\)|cg(n)|。上述的定义表明，当n足够大，大过一个特定的N时，且存在一个正数c，使得|f(n)|不大于|cg(n)|,则f是g的O表示。关系可以解释为g(n)是f(n)的一个上界，也可以理解为f增长的速度最多和g一样快，而不会超过g。 名称 表示法 定义 Tilde f(n)~g(n) $$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 1$$ Big Oh f(n) is O(g(n)) $$\\exists c \\gt 0, n_0 \\ge 0$$such that \\( 0 \\le f(n) \\le c \\cdot g(n)\\) for all \\(n \\ge n_0\\) Big Omega f(n) is \\(\\Omega\\)(g(n)) g(n) is O(f(n)) Big Theta f(n) is \\(\\Theta\\)(g(n)) f(n) is both O(g(n)) and \\(\\Omega\\)(g(n)) Little oh f(n) is o(g(n)) $$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0$$ Little omega f(n) is \\(\\omega\\)(g(n)) g(n) is o(f(n)) 3.递归算法的定义，及其两要素。 递归就是循环定义，对于一个方法来说，就是自己调用自己。 两要素： -终止条件 -递推公式 经典汉诺塔问题(c#实现) 1234567891011121314151617181920212223using System;namespace Hanoi_Tower&#123; class Program &#123; static void Main(string[] args) &#123; int n &#x3D; Int32.Parse(Console.ReadLine()); Hanoi(n,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#125; private static void Hanoi(int n, string a,string b, string c)&#123; if(n &#x3D;&#x3D; 1)Move(a,c); else &#123; Hanoi(n-1, a, c, b); Move(a,c); Hanoi(n-1, b, a, c); &#125; &#125; private static void Move(string origin, string des)&#123; Console.WriteLine(origin+ &quot;---&gt;&quot; + des); &#125; &#125;&#125; 4.分治算法的思想，经典的分治算法(全排列、二分搜索、归并排序、快速排序、线性时间选择、最接近点对问题)。","categories":[],"tags":[]},{"title":"求职之前","slug":"求职之前","date":"2020-06-24T10:31:25.000Z","updated":"2020-06-25T09:20:26.342Z","comments":true,"path":"2020/06/24/求职之前/","link":"","permalink":"http://ssssshinji.github.io/2020/06/24/%E6%B1%82%E8%81%8C%E4%B9%8B%E5%89%8D/","excerpt":"","text":"一些思考 找工作真的是件非常困难的事啊，动不动就会和人生目标啦理想啦联合在一起。虽然很赞同“世界是荒谬的”这一观点，不过人不给自己找个目标就难以生活下去啊。真是麻烦死了。 话说回来我也没想过实现什么伟业，自己能有个感兴趣的小目标，实现了之后能有小小的自我满足，就够了。那么来检讨一下目前可选择的方案。 读博士教书 说到底外人说的博士起点高，层次高之类的老生常谈对我而言都是虚的。我只是构思了一个工作轻松，闲暇时间可以打打游戏，搞搞创作之类的轻松生活而已。搞科研，传道授业解惑之类的，有兴趣，但是不大，也没那个倔强劲。 工作 读博的话还能从目前的人生中稍微取取经，思考工作真是让人无从下手。做都没做过的事情，要怎么来评判啊。按着兴趣排序的话，第一应该是渲染工程师吧。面试看重的是扎实的计算机基础，shader的编写能力，最好再对一两个软件得心应手。说实话应该是最接近我目前现状的职位要求了，而且感觉能从中得到自我满足，还不错。接着是引擎开发工程师吗？兴趣还可以，困难应该会比较多，比前一个职位更加看重编程能力。主要在于架构的设计，代码的调试，以及你脑中的代码量够不够你想到解决问题的方法。我不知道我目前的兴趣能不能撑很久。3D模型师？总是看网上太太们的作品看得津津有味，跃跃欲试，如果当成工作的话会怎么样呢。个人感觉和之前的职业对比区别较大，需要培养的是设计的思维和美感，经过大量的练习来提高自己的软件熟练度。在我心里已经把她归到属于设计类的行业了。那么，果然还是当作自己的业余爱好比较好吧，不然读计算机干嘛呢。。换句话说，凭什么竞争的过专业的3D设计师呢。 有时候列举出来才懂排除法的妙。基本就只有第一条路可以走了，那么要做的准备就很明确了。提高专业素养保证自己的基础知识储备和计算机图形学相关的知识储备，了解渲染前沿的技术以及成熟程度，最好多手写shader的代码，3D软件的使用是个加分项，可以适当的看一看，不过还是别太花时间比较好。科研什么的，还是往后放一放吧（虽然本来也拖得够久了。。。）","categories":[{"name":"自白","slug":"自白","permalink":"http://ssssshinji.github.io/categories/%E8%87%AA%E7%99%BD/"}],"tags":[{"name":"对工作的牢骚","slug":"对工作的牢骚","permalink":"http://ssssshinji.github.io/tags/%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%89%A2%E9%AA%9A/"}]},{"title":"图片测试","slug":"image","date":"2020-06-20T11:53:43.000Z","updated":"2020-06-24T10:50:10.571Z","comments":false,"path":"2020/06/20/image/","link":"2020/06/20/image","permalink":"http://ssssshinji.github.io/2020/06/20/image/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"幸运星 第一话（外链视频测试）","slug":"video","date":"2020-06-20T09:32:57.000Z","updated":"2020-06-24T12:33:37.079Z","comments":false,"path":"2020/06/20/video/","link":"2020/06/20/video","permalink":"http://ssssshinji.github.io/2020/06/20/video/","excerpt":"","text":"","categories":[{"name":"动漫","slug":"动漫","permalink":"http://ssssshinji.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"幸运星","slug":"幸运星","permalink":"http://ssssshinji.github.io/tags/%E5%B9%B8%E8%BF%90%E6%98%9F/"}]}],"categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"name":"monolog","slug":"monolog","permalink":"http://ssssshinji.github.io/categories/monolog/"},{"name":"自白","slug":"自白","permalink":"http://ssssshinji.github.io/categories/%E8%87%AA%E7%99%BD/"},{"name":"动漫","slug":"动漫","permalink":"http://ssssshinji.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"树与图","slug":"树与图","permalink":"http://ssssshinji.github.io/tags/%E6%A0%91%E4%B8%8E%E5%9B%BE/"},{"name":"不想却又不得不工作","slug":"不想却又不得不工作","permalink":"http://ssssshinji.github.io/tags/%E4%B8%8D%E6%83%B3%E5%8D%B4%E5%8F%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E5%B7%A5%E4%BD%9C/"},{"name":"链表","slug":"链表","permalink":"http://ssssshinji.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"对工作的牢骚","slug":"对工作的牢骚","permalink":"http://ssssshinji.github.io/tags/%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%89%A2%E9%AA%9A/"},{"name":"幸运星","slug":"幸运星","permalink":"http://ssssshinji.github.io/tags/%E5%B9%B8%E8%BF%90%E6%98%9F/"}]}