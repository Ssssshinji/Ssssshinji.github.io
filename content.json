{"meta":{"title":"inside","subtitle":"","description":"","author":"zyt","url":"http://Ssssshinji.github.io","root":"/"},"pages":[],"posts":[{"title":"Questionon_1","slug":"Questionon-1","date":"2020-06-25T07:41:27.000Z","updated":"2020-06-25T07:41:27.570Z","comments":true,"path":"2020/06/25/Questionon-1/","link":"","permalink":"http://ssssshinji.github.io/2020/06/25/Questionon-1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"问题1：判定字符是否唯一","slug":"问题1：判定字符是否唯一","date":"2020-06-25T07:36:02.000Z","updated":"2020-06-25T09:16:33.958Z","comments":false,"path":"2020/06/25/问题1：判定字符是否唯一/","link":"2020/06/25/问题1：判定字符是否唯一","permalink":"http://ssssshinji.github.io/2020/06/25/%E9%97%AE%E9%A2%981%EF%BC%9A%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/","excerpt":"","text":"题目描述 实现一个算法，确定一个字符串的所有字符是否不全都不同。假使不允许使用额外的数据结构，又该如何处理？（提示在页尾） 个人思路 如果可用其他的数据结构，创建一个list，逐个将字符加入到list中。在加入前调用List.Contains()查询是否已经有该字符，有则报错。如果不可用别的数据结构，按照ASCII码排序，再看是否有相邻字符相等，或者拿每一个和剩下的字符比较。 个人解答（使用数据结构） 1234567891011121314151617Boolean isUnique(string str)&#123; ArrayList list &#x3D; new ArrayList(); for (int i &#x3D; 0; i &lt; str.Length; i++) &#123; if (!list.Contains(str[i])) &#123; list.Add(str[i]); &#125; else &#123; return false; &#125; &#125; return true;&#125; 题目解析 -要关注字符串是ASCII串还是Unicode串，这关系到你需要使用的数组大小（在标准解答中，按照ASCII处理） -如果字符串长度超过了字母表中不同字符的个数(ASCII:128)，直接返回false 标准解答（使用数据结构） 1234567891011121314Boolean isUnique(string str)&#123; if(str.Length &gt; 128)return false; bool[] char_set &#x3D; new bool[128]; for(int i &#x3D; 0; i &lt; str.Length; i++)&#123; int val &#x3D; str[i]; &#x2F;&#x2F;在字符串中已找到过 if(char_set[val])&#123; return false; &#125; char_set[val] &#x3D; true; &#125; return true;&#125; 复杂度分析 这段代码的时间复杂度为O(n)，其中n为字符串长度。空间复杂度为O(1)。你也可以认为时间复杂度是O(1)，因为for循环的迭代永远不会超过128次。如果不想假设字符集是恒定的，也可以认为空间复杂度是O(c )，时间复杂度是O(min(c,n))或者O(c )，其中c是字符集的大小。 不使用数据结构的情况 思路和自己的思路相同，无代码解析。 反思 没有注意到字符数量是有限的，从而利用数组解决问题。类似的使用数组的方式还有很多，需要注意。 提示 -用散列表试试 -位向量有用吗 -你能用O(NlogN)的时间复杂度解决它吗","categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"算法常见面试题1-5","slug":"算法常见面试题1-5","date":"2020-06-24T13:14:39.000Z","updated":"2020-06-25T07:42:03.548Z","comments":false,"path":"2020/06/24/算法常见面试题1-5/","link":"2020/06/24/算法常见面试题1-5","permalink":"http://ssssshinji.github.io/2020/06/24/%E7%AE%97%E6%B3%95%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%981-5/","excerpt":"","text":"1.算法的几个特征是什么？ 1.有穷性 (Finiteness) 指算法必须在执行有限个步骤之后终止。 2.确切性 (Definiteness) 算法的每一步骤必须有确切的定义。 3.输入项 (Input) 一个算法有0个或者多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。 4.输出项 (Output) 一个算法有一个或者多个输出，以反映对输入数据加工后的结果。没有输出的算法毫无意义。 5.可行性 (Effectiveness) 算法中执行的任何计算步骤都可以被分解为基本的可执行操作，即每个计算步骤都可以在有限时间内完成，也称之为有效性。 2.算法复杂性的定义。大O、θ、Ω、小o分别表示的含义是什么？ 算法复杂度分为空间复杂度S(n)和时间复杂度T(n)。 空间复杂度指在运行过程中为局部变量分配的存储空间的大小，它包括参数列表中的形参变量和函数体中定义的局部变量两个部分，记作S(n) = O(f(n))。时间复杂度定性描述了该算法的运行时间，记作T(n) = O(f(n))。 如果算法A需要的时间与f(n)成正比，则称算法A为f(n)阶，记为O(f(n))。函数f(n)称为算法的增率函数(growth-rate function)。该表示法使用大学字母O(Order)来表示，故称为大O表示法。若规模为n的问题需要的时间与n成正比，则问题表示为O(n),即n阶。若需要的时间与\\(n^2\\)成正比，则问题表示为O(\\(n^2\\)),以此类推。**O并不是一个函数。**他的属性有： 1.可忽略算法增率函数的低阶项 2.可忽略算法增率函数中高阶项的倍输常量 3.O(f(n)) + O(g(n))=O(f(n)+g(n))可组合增率函数 形式化定义： 给定2个正值函数f和g，定义：f(n) = O(g(n)),条件为：存在正实数c和N，使得对于所有的n\\(\\ge\\)N,有|f(n)|\\(\\le\\)|cg(n)|。上述的定义表明，当n足够大，大过一个特定的N时，且存在一个正数c，使得|f(n)|不大于|cg(n)|,则f是g的O表示。关系可以解释为g(n)是f(n)的一个上界，也可以理解为f增长的速度最多和g一样快，而不会超过g。 名称 表示法 定义 Tilde f(n)~g(n) $$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 1$$ Big Oh f(n) is O(g(n)) $$\\exists c \\gt 0, n_0 \\ge 0$$such that \\( 0 \\le f(n) \\le c \\cdot g(n)\\) for all \\(n \\ge n_0\\) Big Omega f(n) is \\(\\Omega\\)(g(n)) g(n) is O(f(n)) Big Theta f(n) is \\(\\Theta\\)(g(n)) f(n) is both O(g(n)) and \\(\\Omega\\)(g(n)) Little oh f(n) is o(g(n)) $$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0$$ Little omega f(n) is \\(\\omega\\)(g(n)) g(n) is o(f(n)) 3.递归算法的定义，及其两要素。 递归就是循环定义，对于一个方法来说，就是自己调用自己。 两要素： -终止条件 -递推公式 经典汉诺塔问题(c#实现) 1234567891011121314151617181920212223using System;namespace Hanoi_Tower&#123; class Program &#123; static void Main(string[] args) &#123; int n &#x3D; Int32.Parse(Console.ReadLine()); Hanoi(n,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;); &#125; private static void Hanoi(int n, string a,string b, string c)&#123; if(n &#x3D;&#x3D; 1)Move(a,c); else &#123; Hanoi(n-1, a, c, b); Move(a,c); Hanoi(n-1, b, a, c); &#125; &#125; private static void Move(string origin, string des)&#123; Console.WriteLine(origin+ &quot;---&gt;&quot; + des); &#125; &#125;&#125; 4.分治算法的思想，经典的分治算法(全排列、二分搜索、归并排序、快速排序、线性时间选择、最接近点对问题)。","categories":[],"tags":[]},{"title":"求职之前","slug":"求职之前","date":"2020-06-24T10:31:25.000Z","updated":"2020-06-25T09:20:26.342Z","comments":true,"path":"2020/06/24/求职之前/","link":"","permalink":"http://ssssshinji.github.io/2020/06/24/%E6%B1%82%E8%81%8C%E4%B9%8B%E5%89%8D/","excerpt":"","text":"一些思考 找工作真的是件非常困难的事啊，动不动就会和人生目标啦理想啦联合在一起。虽然很赞同“世界是荒谬的”这一观点，不过人不给自己找个目标就难以生活下去啊。真是麻烦死了。 话说回来我也没想过实现什么伟业，自己能有个感兴趣的小目标，实现了之后能有小小的自我满足，就够了。那么来检讨一下目前可选择的方案。 读博士教书 说到底外人说的博士起点高，层次高之类的老生常谈对我而言都是虚的。我只是构思了一个工作轻松，闲暇时间可以打打游戏，搞搞创作之类的轻松生活而已。搞科研，传道授业解惑之类的，有兴趣，但是不大，也没那个倔强劲。 工作 读博的话还能从目前的人生中稍微取取经，思考工作真是让人无从下手。做都没做过的事情，要怎么来评判啊。按着兴趣排序的话，第一应该是渲染工程师吧。面试看重的是扎实的计算机基础，shader的编写能力，最好再对一两个软件得心应手。说实话应该是最接近我目前现状的职位要求了，而且感觉能从中得到自我满足，还不错。接着是引擎开发工程师吗？兴趣还可以，困难应该会比较多，比前一个职位更加看重编程能力。主要在于架构的设计，代码的调试，以及你脑中的代码量够不够你想到解决问题的方法。我不知道我目前的兴趣能不能撑很久。3D模型师？总是看网上太太们的作品看得津津有味，跃跃欲试，如果当成工作的话会怎么样呢。个人感觉和之前的职业对比区别较大，需要培养的是设计的思维和美感，经过大量的练习来提高自己的软件熟练度。在我心里已经把她归到属于设计类的行业了。那么，果然还是当作自己的业余爱好比较好吧，不然读计算机干嘛呢。。换句话说，凭什么竞争的过专业的3D设计师呢。 有时候列举出来才懂排除法的妙。基本就只有第一条路可以走了，那么要做的准备就很明确了。提高专业素养保证自己的基础知识储备和计算机图形学相关的知识储备，了解渲染前沿的技术以及成熟程度，最好多手写shader的代码，3D软件的使用是个加分项，可以适当的看一看，不过还是别太花时间比较好。科研什么的，还是往后放一放吧（虽然本来也拖得够久了。。。）","categories":[{"name":"自白","slug":"自白","permalink":"http://ssssshinji.github.io/categories/%E8%87%AA%E7%99%BD/"}],"tags":[{"name":"对工作的牢骚","slug":"对工作的牢骚","permalink":"http://ssssshinji.github.io/tags/%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%89%A2%E9%AA%9A/"}]},{"title":"图片测试","slug":"image","date":"2020-06-20T11:53:43.000Z","updated":"2020-06-24T10:50:10.571Z","comments":false,"path":"2020/06/20/image/","link":"2020/06/20/image","permalink":"http://ssssshinji.github.io/2020/06/20/image/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"幸运星 第一话（外链视频测试）","slug":"video","date":"2020-06-20T09:32:57.000Z","updated":"2020-06-24T12:33:37.079Z","comments":false,"path":"2020/06/20/video/","link":"2020/06/20/video","permalink":"http://ssssshinji.github.io/2020/06/20/video/","excerpt":"","text":"","categories":[{"name":"动漫","slug":"动漫","permalink":"http://ssssshinji.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"幸运星","slug":"幸运星","permalink":"http://ssssshinji.github.io/tags/%E5%B9%B8%E8%BF%90%E6%98%9F/"}]}],"categories":[{"name":"算法练习","slug":"算法练习","permalink":"http://ssssshinji.github.io/categories/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/"},{"name":"自白","slug":"自白","permalink":"http://ssssshinji.github.io/categories/%E8%87%AA%E7%99%BD/"},{"name":"动漫","slug":"动漫","permalink":"http://ssssshinji.github.io/categories/%E5%8A%A8%E6%BC%AB/"}],"tags":[{"name":"数组与字符串","slug":"数组与字符串","permalink":"http://ssssshinji.github.io/tags/%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"对工作的牢骚","slug":"对工作的牢骚","permalink":"http://ssssshinji.github.io/tags/%E5%AF%B9%E5%B7%A5%E4%BD%9C%E7%9A%84%E7%89%A2%E9%AA%9A/"},{"name":"幸运星","slug":"幸运星","permalink":"http://ssssshinji.github.io/tags/%E5%B9%B8%E8%BF%90%E6%98%9F/"}]}