{"title":"问题7：旋转矩阵","date":"2020-07-21T06:30:43.000Z","date_formatted":{"ll":"Jul 21, 2020","L":"07/21/2020","MM-DD":"07-21"},"link":"2020/07/21/问题7：旋转矩阵","tags":["数组与字符串"],"categories":["算法练习"],"updated":"2020-08-04T16:26:51.762Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  给定一幅由N×N矩阵表示的图像，其中每个像素的大小为4字节，编写一种方法，将图像旋转90度。不占用额外内存空间能否做到？</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  将矩阵中的所有元素ai,j和相应的aj,i对调即可，这样子要使用至少一个临时变量做额外空间。要做到不使用额外空间的话，可以尝试矩阵读入的顺序，先读列再读行。可以做到不适用额外空间。**不对！**转置矩阵等于是翻转之后旋转了90度，不是直接旋转了90度。旋转90度需要的是环状旋转。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void RotateMatrix(int[][] matrix)&#123;</span><br><span class=\"line\">    int rowStart &#x3D; 0;</span><br><span class=\"line\">    int colStart &#x3D; matrix.Length - 1;</span><br><span class=\"line\">    int width &#x3D; colStart - rowStart;</span><br><span class=\"line\">    &#x2F;&#x2F; int ColStart &#x3D; 0;</span><br><span class=\"line\">    &#x2F;&#x2F; int colEnd &#x3D; matrix.Length - 1;</span><br><span class=\"line\">    while(width &gt; 0)&#123;</span><br><span class=\"line\">        for(int i &#x3D; 0; i &lt; width; i++)&#123;</span><br><span class=\"line\">            int temp &#x3D; matrix[rowStart + i][colStart];</span><br><span class=\"line\">            &#x2F;&#x2F;上移右</span><br><span class=\"line\">            matrix[rowStart + i][colStart] &#x3D; matrix[rowStart][rowStart + i];</span><br><span class=\"line\">            &#x2F;&#x2F;左移上</span><br><span class=\"line\">            matrix[rowStart][rowStart + i] &#x3D; matrix[colStart-i][rowStart];</span><br><span class=\"line\">            &#x2F;&#x2F;下移左</span><br><span class=\"line\">            matrix[colStart-i][rowStart] &#x3D; matrix[colStart][colStart - i];</span><br><span class=\"line\">            &#x2F;&#x2F;左移上</span><br><span class=\"line\">            matrix[colStart][colStart - i] &#x3D; temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        rowStart +&#x3D; 1;</span><br><span class=\"line\">        colStart -&#x3D; 1;</span><br><span class=\"line\">        width -&#x3D; 2;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  O(n^2)。因为需要访问n^2个元素。</p>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  要将矩阵旋转90度，最简单的做法就是一层一层进行旋转。对每一层执行环状旋转（circular rotation）：将上边移到右边，右边移到下边，下边移到左边，左边移到上边。<br>\n  那么，该如何交换这4条边？一种做法是把上面复制到一个数组中，然后将左边移到上边，下边移到左边，等等。这需要占用O(N)的内存空间，实际上没有必要。<br>\n  更好的做法是按索引一个一个进行交换，具体做法如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for i &#x3D; 0 to n</span><br><span class=\"line\">    temp &#x3D; top[i];</span><br><span class=\"line\">    top[i] &#x3D; left[i]</span><br><span class=\"line\">    left[i] &#x3D; bottom[i]</span><br><span class=\"line\">    bottom[i] &#x3D; temp;</span><br><span class=\"line\">    right[i] &#x3D; temp;</span><br></pre></td></tr></table></figure>\n<p>  从最外面一层开始逐渐向里，在每一层上执行上述交换。另外，也可以从内层开始，逐层向外。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;和我的解答基本相同，写的更漂亮</span><br><span class=\"line\">static bool RotateMatrix(int[][] matrix)&#123;</span><br><span class=\"line\">    if(matrix.Length &#x3D;&#x3D; 0 || matrix.Length !&#x3D; matrix[0].Length)return false;</span><br><span class=\"line\">    int n &#x3D; matrix.Length;</span><br><span class=\"line\">    for(int layer &#x3D; 0; layer &lt; n&#x2F;2; layer++)&#123;</span><br><span class=\"line\">        int first &#x3D; layer;</span><br><span class=\"line\">        int last &#x3D; n - 1 - layer;</span><br><span class=\"line\">        for(int i  &#x3D; first; i&lt;last; i++)&#123;</span><br><span class=\"line\">            int offset &#x3D; i - first;</span><br><span class=\"line\">            int top &#x3D; matrix[first][i];&#x2F;&#x2F;存储上边</span><br><span class=\"line\">            &#x2F;&#x2F;左边移到上边</span><br><span class=\"line\">            matrix[first][i] &#x3D; matrix[last - offset][first];</span><br><span class=\"line\">            &#x2F;&#x2F;下边移到左边</span><br><span class=\"line\">            matrix[last-offset][first] &#x3D; matrix[last][last - offset];</span><br><span class=\"line\">            &#x2F;&#x2F;右边移到下边</span><br><span class=\"line\">            matrix[last][last - offset] &#x3D; matrix[i][last];</span><br><span class=\"line\">            &#x2F;&#x2F;上边移到右边</span><br><span class=\"line\">            matrix[i][last] &#x3D; top;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  花了一个多小时考虑细节写出来的代码，感觉稳的一批。不过标准答案还是更加漂亮。而且又忘了边界检查。</p>\n<h2 id=\"提示：#51，#100\">提示：#51，#100<a title=\"#提示：#51，#100\" href=\"#提示：#51，#100\"></a></h2>\n<p>  -尝试逐层思考。你能旋转某个特定图层吗？<br>\n  -旋转一个特定的层只意味着在4个数组中交换值。如果要求你在2个数组中交换值，你能做到吗？你能把它扩展到4个数组吗？</p>\n","prev":{"title":"问题精析：光线追踪发展史","link":"2020/07/21/问题精析：光线追踪发展史"},"next":{"title":"问题精析：Blooming","link":"2020/07/19/问题精析：Blooming"},"plink":"http://Ssssshinji.github.io/2020/07/21/问题7：旋转矩阵/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"复杂度分析","title":"复杂度分析","index":"4"},{"id":"题目解析","title":"题目解析","index":"5"},{"id":"标准解答","title":"标准解答","index":"6"},{"id":"反思","title":"反思","index":"7"},{"id":"提示：#51，#100","title":"提示：#51，#100","index":"8"}]}