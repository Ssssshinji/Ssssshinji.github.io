{"title":"问题2：返回倒数第k个节点","date":"2020-07-05T15:51:27.000Z","date_formatted":{"ll":"Jul 5, 2020","L":"07/05/2020","MM-DD":"07-05"},"link":"2020/07/05/问题2：返回倒数第k个节点","tags":["链表"],"categories":["算法练习"],"updated":"2020-07-05T17:00:59.821Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  返回倒数第k个节点。实现一种算法，找出单向链表中倒数第k个节点。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  经典双指针问题。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node FindLast_Kth(List list,int k)&#123;</span><br><span class=\"line\">    if(list.Length &lt; k)&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node first &#x3D; list.head;</span><br><span class=\"line\">    Node second &#x3D; list.head;</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; k; i++)&#123;</span><br><span class=\"line\">        first &#x3D; first.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(first.next !&#x3D; null)&#123;</span><br><span class=\"line\">        first &#x3D; first.next;</span><br><span class=\"line\">        second &#x3D; second.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return second;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  下面会以递归和非递归的方式解决这个问题。一般来说，递归解法更简洁，但效率低下。例如，就这个问题来说，递归解法的代码量大概只有迭代解法的一半，但要占用O(n)的空间，其中n为链表中节点个数。<br>\n  注意，在下面的解法中，k定义如下：传入k=1将返回最后一个节点，k=2返回倒数第二个节点，以此类推。当然，也可以将k定义为k=0返回最后一个节点。<br>\n<strong>解法1</strong>：链表长度已知<br>\n  若链表长度已知，那么，倒数第k个节点就是第(length - k)个节点。直接迭代访问链表就能找到这个节点。不过，这个解法太过简单了，不大可能是面试官想要的答案。<br>\n<strong>解法2</strong>：递归<br>\n  这个算法会递归访问整个链表，当抵达链表末端时，该方法会回传一个设置为0的计数器。之后的每次调用都会将这个计数器加1。当计数器等于k时，表示我们访问的是链表倒数第k个元素。<br>\n  实现代码简洁明了，前提是我们要有办法通过栈“回传”一个整数值。可惜，无法用一般的返回语句回传一个节点和一个计数器，那该怎么办？</p>\n<h3 id=\"方法a:不返回该元素\">方法A:不返回该元素<a title=\"#方法a:不返回该元素\" href=\"#方法a:不返回该元素\"></a></h3>\n<p>  一种方法是对这个问题略作调整，只打印倒数第k个节点的值。然后，直接通过返回值传回计数器值。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int printKthToLast(Node head, int k)&#123;</span><br><span class=\"line\">    if(head &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int index &#x3D; printKthToLast(head.next, k)+1;</span><br><span class=\"line\">    if(index &#x3D;&#x3D; k)&#123;</span><br><span class=\"line\">        System.Console.WriteLine(k+&quot;th to last node is&quot; + head.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return index;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  当然，只有得到面试官的首肯，这个解法才算有效。</p>\n<h3 id=\"方法b:使用c++\">方法B:使用C++<a title=\"#方法b:使用c++\" href=\"#方法b:使用c++\"></a></h3>\n<p>  另一种方法是使用C++，并通过引用传值。这样一来，就可以返回节点值，而且也能通过传递指针更新计数器。</p>\n<h3 id=\"方法c:使用包裹类\">方法C:使用包裹类<a title=\"#方法c:使用包裹类\" href=\"#方法c:使用包裹类\"></a></h3>\n<p>  前面提到，这里的难点在于无法同时返回计数器和索引值。如果用一个简单的类（或一个单元素数组）包裹计数器值，就可以模仿如何通过引用传递。</p>\n<h2 id=\"标准解答-1\">标准解答<a title=\"#标准解答-1\" href=\"#标准解答-1\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Index&#123;</span><br><span class=\"line\">    public int value &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Node kthTolast(Node head, int k)&#123;</span><br><span class=\"line\">    Index idx &#x3D; new Index();</span><br><span class=\"line\">    return kthTolast(head,k,idx);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Node kthTolast(Node head, int k, Index idx)&#123;</span><br><span class=\"line\">    if(head &#x3D;&#x3D; null) return null;</span><br><span class=\"line\">    Node node &#x3D; kthTolast(head.next,k,idx);</span><br><span class=\"line\">    idx.value &#x3D; idx.value + 1;</span><br><span class=\"line\">    if(idx.value &#x3D;&#x3D; k)&#123;</span><br><span class=\"line\">        return head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  因为有递归调用，这些递归解法都需要占用O(n)的空间。<br>\n<strong>解法3</strong>：迭代<br>\n  同个人思路。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  这次有记得处理边界情况。不过因为遇到过类似的题，没有去思考有没有别的做法。递归的解法又给了我一些启发。</p>\n<h2 id=\"提示：#8，#25，#41，#67，#126\">提示：#8，#25，#41，#67，#126<a title=\"#提示：#8，#25，#41，#67，#126\" href=\"#提示：#8，#25，#41，#67，#126\"></a></h2>\n<p>  -如果你知道链表大小，会怎么样？找到最后第k个元素和找到第x个元素有何区别？<br>\n  -如果你不知道链表的大小，你能计算它吗？这将如何影响运行时间？<br>\n  -尝试用递归法实现。如果你能找到(k-1)到最后一个元素，可以找到第k个元素吗？<br>\n  -你可能会发现返回多个值大有用处。有些语言不直接支持这一点，但基本上使用任何语言都有解决方法。这些解决方法有哪些？<br>\n  -你能通过递归做到吗？想象一下，如果有两个指针指向相邻节点，它们通过链表以相同的速度移动。当一个到达链表的结尾时，另一个在哪里？</p>\n","prev":{"title":"问题精析：URL编码规则与规范","link":"2020/07/06/问题精析：URL编码规则与规范"},"next":{"title":"问题3：URL化","link":"2020/07/05/问题3：URL化"},"plink":"http://Ssssshinji.github.io/2020/07/05/问题2：返回倒数第k个节点/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4","children":[{"id":"方法a:不返回该元素","title":"方法A:不返回该元素","index":"4.1"}]},{"id":"标准解答","title":"标准解答","index":"5","children":[{"id":"方法b:使用c++","title":"方法B:使用C++","index":"5.1"},{"id":"方法c:使用包裹类","title":"方法C:使用包裹类","index":"5.2"}]},{"id":"标准解答-1","title":"标准解答","index":"6"},{"id":"反思","title":"反思","index":"7"},{"id":"提示：#8，#25，#41，#67，#126","title":"提示：#8，#25，#41，#67，#126","index":"8"}]}