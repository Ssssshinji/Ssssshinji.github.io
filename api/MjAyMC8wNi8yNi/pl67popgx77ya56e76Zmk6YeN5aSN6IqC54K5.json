{"title":"问题1：移除重复节点","date":"2020-06-26T13:27:58.000Z","date_formatted":{"ll":"Jun 26, 2020","L":"06/26/2020","MM-DD":"06-26"},"link":"2020/06/26/问题1：移除重复节点","tags":["链表"],"updated":"2020-06-26T14:39:34.532Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  编写代码，移除未排序链表中的重复节点。进阶：如果不得使用临时缓冲区，该怎么解决？（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  新建一个字典(dictionary)，依次把每个节点的value当作键添加到字典中，字典的值随便取。每次碰到新节点时先调用CintainsKey(key)方法，因为字典中键的唯一性，返回true时说明该节点重复。不使用缓冲区不会做。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void deleteDups(LinkedListNode node)&#123;</span><br><span class=\"line\">    Dictionary&lt;key,value&gt; dic &#x3D; new Dictionary&lt;key,value&gt;();</span><br><span class=\"line\">    LinkedListNode previous &#x3D; null;</span><br><span class=\"line\">    while(node !&#x3D; null)&#123;</span><br><span class=\"line\">        if(dic.ContainsKey(node.value))&#123;</span><br><span class=\"line\">            previous.Next &#x3D; node.next;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            dic.Add(node.value);</span><br><span class=\"line\">            previous &#x3D; node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    node.next;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  -要想移除链表中的重复节点，需要设法记录有哪些是重复的。这里只要用到一个简单的散列表。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void deleteDups(LinkedListNode node)&#123;</span><br><span class=\"line\">    HashSet&lt;item&gt; set &#x3D; new HashSet&lt;item&gt;();</span><br><span class=\"line\">    LinkedListNode previous &#x3D; null;</span><br><span class=\"line\">    while(node !&#x3D; null)&#123;</span><br><span class=\"line\">        if(set.Contains(node.value))&#123;</span><br><span class=\"line\">            previous.Next &#x3D; node.next;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            set.Add(node.value);</span><br><span class=\"line\">            previous &#x3D; node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    node.next;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  这段代码的时间复杂度为O(n),n为链表节点数目。</p>\n<h2 id=\"不使用临时缓冲区的情况\">不使用临时缓冲区的情况<a title=\"#不使用临时缓冲区的情况\" href=\"#不使用临时缓冲区的情况\"></a></h2>\n<p>  如果不使用额外的缓冲区，可以使用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的节点时候重复。</p>\n<h2 id=\"标准解答（不使用临时缓冲区）\">标准解答（不使用临时缓冲区）<a title=\"#标准解答（不使用临时缓冲区）\" href=\"#标准解答（不使用临时缓冲区）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void deleteDups(LinkedListNode head)&#123;</span><br><span class=\"line\">    LinkedListNode current &#x3D; head;</span><br><span class=\"line\">    while(current !&#x3D; null)&#123;</span><br><span class=\"line\">        LinkedListNode runner &#x3D; current;</span><br><span class=\"line\">        while(runner.next !&#x3D; null)&#123;</span><br><span class=\"line\">            if(current.value &#x3D;&#x3D; runner.next.value)&#123;</span><br><span class=\"line\">                runner.next &#x3D; runner.next.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                runner &#x3D; runner.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        current &#x3D; current.next;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析-1\">复杂度分析<a title=\"#复杂度分析-1\" href=\"#复杂度分析-1\"></a></h2>\n<p>  这段代码的空间复杂度为O(1)，但时间复杂度为O(N^2)。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  第一问基本思路相同，刚好复习一下dictionary和hashSet的区别。对于不使用缓冲区的情况，老想着怎么样轻易解决，却忘了大部分算法都是先用最简单的方式得出结果再慢慢优化的，忽略了双指针循环。</p>\n<h2 id=\"提示\">提示<a title=\"#提示\" href=\"#提示\"></a></h2>\n<p>  -你有没有试过一个散列表？你应该可以通过一次链表遍历做到这一点。<br>\n  -没有额外的空间，你需要O(N^2)的时间。尝试使用两个指针，其中第二个指针在第一个指针之前搜索。</p>\n","next":{"title":"问题1：判定字符是否唯一","link":"2020/06/25/问题1：判定字符是否唯一"},"plink":"http://Ssssshinji.github.io/2020/06/26/问题1：移除重复节点/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"复杂度分析","title":"复杂度分析","index":"6"},{"id":"不使用临时缓冲区的情况","title":"不使用临时缓冲区的情况","index":"7"},{"id":"标准解答（不使用临时缓冲区）","title":"标准解答（不使用临时缓冲区）","index":"8"},{"id":"复杂度分析-1","title":"复杂度分析","index":"9"},{"id":"反思","title":"反思","index":"10"},{"id":"提示","title":"提示","index":"11"}]}