{"title":"问题4：检查平衡性","date":"2020-07-11T08:45:58.000Z","date_formatted":{"ll":"Jul 11, 2020","L":"07/11/2020","MM-DD":"07-11"},"link":"2020/07/11/问题4：检查平衡性","tags":["树与图"],"categories":["算法练习"],"updated":"2020-07-16T04:49:20.843Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  实现一个函数，检查二叉树是否平衡。在这个问题中，平衡树的定义如下：任意一个节点，其两棵子树的高度差不超过1。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  两个函数，一个求高度，一个判断是否平衡。但是效率很低下。看了提示之后想试着写成一个函数。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;自己写的有问题，等于只检查了最大的那颗树！！！！！！</span><br><span class=\"line\">    static int TreeDepth(TreeNode root)&#123;</span><br><span class=\"line\">        if(root &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">            return 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return TreeDepth(root.left) &gt; TreeDepth(root.right) ? TreeDepth(root.left)+1 : TreeDepth(root.right)+1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static bool IsBalance(TreeNode root)&#123;</span><br><span class=\"line\">        if(root.left !&#x3D; null||root.right !&#x3D; null)&#123;</span><br><span class=\"line\">            IsBalance(root.left);</span><br><span class=\"line\">            IsBalance(root.right);</span><br><span class=\"line\">            </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(Math.Abs(TreeDepth(root.left) - TreeDepth(root.right)) &gt; 1)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  任意一个节点，其两棵子树的高度差不超过1。根据该定义可以得到一种解法，即直接递归访问整棵树，计算每个节点两棵子树的高度。此法虽然可行，但不太高效，这段代码会递归访问每个节点的整棵子树，也就是说，getHeight会被反复调用计算同一个节点的高度。因此，由于每个节点被其上方的节点访问一次，这个算法的时间复杂度为O(NlogN)。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int TreeDepth(TreeNode root)&#123;</span><br><span class=\"line\">    if(root &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return TreeDepth(root.left) &gt; TreeDepth(root.right) ? TreeDepth(root.left)+1 : TreeDepth(root.right)+1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static bool IsBalance(TreeNode root)&#123;</span><br><span class=\"line\">    if(root &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(Math.Abs(TreeDepth(root.left) - TreeDepth(root.right)) &gt; 1)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        return IsBalance(root.left) &amp;&amp; IsBalance(root.right);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  仔细查看上面的方法，你或许会发现，getHeight不仅可以检查高度，还能检查这棵树是否平衡。那么，我们发现子树不平衡时又该怎么做呢？直接返回一个错误代码即可<br>\n  改进过的算法会从根节点递归向下检查每棵子树的高度。我们会通过checkHeight方法，以递归方式获取每个节点左右子树的高度。若子树是平衡的，则checkHeight返回该子树的实际高度。若子树不平衡，则checkHeight返回一个错误代码。checkHeight会立即中断执行，并返回一个错误代码。<br>\n  我们应该拿什么作为错误代码呢？空树的高度一般被记作-1，所以将-1作为错误代码并不是上乘之选。其实，我们可以将Integer.MIN_VALUE作为错误代码。</p>\n<h2 id=\"标准解答（改进）\">标准解答（改进）<a title=\"#标准解答（改进）\" href=\"#标准解答（改进）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int checkHeight(Treenode root)&#123;</span><br><span class=\"line\">    if(root &#x3D;&#x3D; null) return -1;</span><br><span class=\"line\">    int leftHeight &#x3D; checkHeight(root.left);</span><br><span class=\"line\">    if(leftHeight &#x3D;&#x3D; Int32.MinValue)return Int32.MinValue;&#x2F;&#x2F;向上传递错误</span><br><span class=\"line\">    int rightHeight &#x3D; checkHeight(root.right);</span><br><span class=\"line\">    if(rightHeight &#x3D;&#x3D; Int32.MinValue)return Int32.MinValue;&#x2F;&#x2F;向上传递错误</span><br><span class=\"line\">    int heightDiff &#x3D; leftHeight - rightHeight;</span><br><span class=\"line\">    if(Math.Abs(heightDiff) &gt; 1)&#123;</span><br><span class=\"line\">        return Int32.MinValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        return Math.Max(leftHeight, rightHeight) + 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bool isBalanced(Treenode root)&#123;</span><br><span class=\"line\">    return checkHeight(root) !&#x3D; Int32.MinValue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  这段代码需要O(N)的时间和O(H)的空间，其中H为树的高度。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  思考时感觉需要同时返回两个式子，忘记了&amp;&amp;运算符，导致最后写出来的算法其实只能判断最大树是否平衡。</p>\n<h2 id=\"提示：#21，#33，#49，#105，#124\">提示：#21，#33，#49，#105，#124<a title=\"#提示：#21，#33，#49，#105，#124\" href=\"#提示：#21，#33，#49，#105，#124\"></a></h2>\n<p>  -考虑平衡树的定义。你可以检查单个节点的条件吗？你可以检查每个节点吗？<br>\n  -如果你开发了一个蛮力解法，请注意它的运行时间。如果你是用于计算每个节点的子树的高度，那么该算法会很低效。<br>\n  -如果你可以修改二叉树节点类，允许节点存储子树的高度，会如何？<br>\n  -你不需要修改二叉树类来存储子树的高度。递归函数是否可以计算每个子树的高度，同时检查节点是否平衡？尝试让函数返回多个值。<br>\n  -其实，你只需要一个checkHeight函数即可，它既可以计算高度，也可以平衡检查。可以使用整数返回值表示两者。</p>\n","prev":{"title":"问题精析：PBR:基本原理及推导","link":"2020/07/12/问题精析：PBR-基本原理及推导"},"next":{"title":"问题精析：PBR:BRDF","link":"2020/07/10/问题精析：PBR-BRDF"},"plink":"http://Ssssshinji.github.io/2020/07/11/问题4：检查平衡性/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"标准解答（改进）","title":"标准解答（改进）","index":"6"},{"id":"复杂度分析","title":"复杂度分析","index":"7"},{"id":"反思","title":"反思","index":"8"},{"id":"提示：#21，#33，#49，#105，#124","title":"提示：#21，#33，#49，#105，#124","index":"9"}]}