{"title":"问题精析：URL编码规则与规范","date":"2020-07-05T17:02:43.000Z","date_formatted":{"ll":"Jul 6, 2020","L":"07/06/2020","MM-DD":"07-06"},"link":"2020/07/06/问题精析：URL编码规则与规范","tags":["计算机网络"],"categories":["问题精析"],"updated":"2020-07-05T17:59:47.185Z","content":"<h2 id=\"为什么要编码？\">为什么要编码？<a title=\"#为什么要编码？\" href=\"#为什么要编码？\"></a></h2>\n<p>  **通常如果一样的东西需要编码，就说明这样的东西并不适合传输。**URL只能使用 ASCII 字符集来通过因特网进行发送。也就是说URL只能使用英文字母、阿拉伯数字和某些标点符号，不能使用其他文字和符号。<br>\nRFC 1738 规定</p>\n<blockquote>\n<p>&quot;…Only alphanumerics [0-9a-zA-Z], the special characters &quot;$-<em>.+!*'(),&quot; [not including the quotes - ed], and reserved characters used for their reserved purposes may be used unencoded within a URL.&quot;<br>\n“只有字母和数字[0-9a-zA-Z]、一些特殊符号“$-</em>.+!*'(),”[不包括双引号]、以及某些保留字，才可以不经过编码直接用于 URL。”<br>\n  (RFC3986文档规定，URL中只允许包含英文字母（a-zA-Z）、数字（0-9）、- _ . ~4个特殊字符以及所有的保留字符。)</p>\n</blockquote>\n<p>  这意味着如果URL存在汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致“URL编码”成为了一个混乱的领域。(之后详述)<br>\n  另一方面，如果我的参数值中就包含=或者&amp;这样的特殊子字符的时候，该怎么办。比如说“name1=value1”,其中value1的值是“va&amp;lu=e1”，那么在传输过程中就会变成“name1=va&amp;lu=e1”。用户传输的本意是只有一个键值对，但是服务器端会解析成两个键值对，这样就自然的产生了歧义。<br>\n  为了解决上述问题，我们就需要对URL进行编码。</p>\n<h2 id=\"url-是如何编码的？\">URL 是如何编码的？<a title=\"#url-是如何编码的？\" href=\"#url-是如何编码的？\"></a></h2>\n<p>  URL 编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符。<br>\n  URL编码只是简单的在特殊字符的各个字节（16进制）前加上”%”即可。例如，我们对上述会产生歧义的字符进行编码后的结果：name1=va%26lu%3D，这样服务器会把紧跟在”%”后的字节当成普通的字节，不会把它当成各个参数或键值对的分隔符。<br>\n  首先需要把该字符的 ASCII 的值表示为两个16进制的数字，然后在其前面放置转义字符(“%”)，置入 URL 中的相应位置。(对于非 ASCII 字符, 需要转换为 UTF-8(或其他编码方式) 字节序, 然后每个字节按照上述方式表示。)<br>\n<strong>另外一个问题是，为什么要用ASCII码传输，可不可以用别的编码？</strong><br>\n  当然可以用别的编码，你可以自己开发一套编码然后自己进行解析。就像大部分国家都有自己的语言一样。但是国家之间要怎么进行交流呢，用英语吧，英语的使用范围最广。<br>\n  <strong>URL编码的原则就是使用安全的字符（没有特殊用途或者特殊意义的可打印字符）去表示那些不安全的字符</strong></p>\n<h2 id=\"哪些字符需要编码？\">哪些字符需要编码？<a title=\"#哪些字符需要编码？\" href=\"#哪些字符需要编码？\"></a></h2>\n<p><strong>US-ASCII字符集中没有对应的可打印字符</strong><br>\n  URL中只允许使用可打印的字符。US-ASCII码中的10-7F字节全都表示控制字符，这些字符不能直接出现在URL中。同时对于80-FF字节，由于已经超出了ASCII码定义字符的范围，因此也不能放在URL中。<br>\n<strong>保留字符</strong>:RFC3986中指定了以下字符为保留字符： ！ * ’ ( ) ; : @ &amp; = + $ , / ? # [ ]<br>\n  URL可以划分为干了组件，协议、主机、路径等。有一些字符（： / ? # [ ] @）是用作分隔不同组件的。例如：冒号用于分隔协议和主机组件，斜杠用于分隔主机和路径，问号用于分隔路径和查询参数，等等。还有一些字符（! $ &amp; * + , ; =）用于在每个组件中起到分隔作用，如等号用于表示查询参数中的键值对，&amp;符号用于分隔查询多个键值对。当组件中的普通数据包含这些特殊字符时，需要对其进行编码。<br>\n<strong>不安全字符</strong><br>\n  还有一些字符，当他们直接放在URL中的时候，可能会引起解析程序的歧义。这些字符被视为不安全的字符，原因有很多。<br>\n  <strong>空格</strong>：URL在传输的过程，或者用户在排版的过程中，或者文本处理程序在处理URL的过程，都有可能引入无关紧要的空格，或者将那些有意义的空格给去掉。<br>\n  <strong>引号 以及 &lt;&gt;</strong>：引号和尖括号通常用于在普通文本中起到分隔URL的作用。<br>\n  <strong>#</strong>：通常用于表示书签或者锚点。<br>\n  <strong>%</strong>：百分号本身用作对不安全的字符进行编码是使用的特殊字符，因此本身需要编码。<br>\n  <strong>{ } | \\ ^ [ ] ’ ~</strong>：某一些网关或者传输代理会篡改这些字符</p>\n<h2 id=\"空格编码问题\">空格编码问题<a title=\"#空格编码问题\" href=\"#空格编码问题\"></a></h2>\n<p>  一个URL的基本组成部分包括协议(scheme),域名，端口号，路径和查询字符串（路径参数和锚点标记就暂不考虑了）。路径和查询字符串之间用问号?分离。例如http://www.example.com/index?param=1，路径为index，查询字符串(Query String)为param=1。URL中关于空格的编码正是与空格所在位置相关：空格被编码成加号+的情况只会在查询字符串部分出现，而被编码成%20则可以出现在路径和查询字符串中。</p>\n<p>  造成这种混乱局面的原因在于：W3C标准规定，当Content-Type为application/x-www-form-urlencoded时，URL中查询参数名和参数值中空格要用加号+替代，所以几乎所有使用该规范的浏览器在表单提交后，URL查询参数中空格都会被编成加号+。而在另一份规范(RFC 2396，定义URI)里, URI里的保留字符都需转义成%HH格式(Section 3.4 Query Component)，因此空格会被编码成%20，加号+本身也作为保留字而被编成%2B，对于某些遵循RFC 2396标准的应用来说，它可能不接受查询字符串中出现加号+，认为它是非法字符。所以一个安全的举措是URL中统一使用%20来编码空格字符。<br>\n  Java中的URLEncoder本意是用来把字符串编码成application/x-www-form-urlencoded MIME格式字符串，也就是说仅仅适用于URL中的查询字符串部分，但是URLEncoder经常被用来对URL的其他部分编码，它的encode方法会把空格编成加号+，与之对应的是，URLDecoder的decode方法会把加号+和%20都解码为空格，这种违反直觉的做法造成了当初我对空格URL编码问题的困扰。因此后来我的做法都是，在调用URLEncoder.encode对URL进行编码后(所有加号+已被编码成%2B)，再调用replaceAll(“\\+”, “%20″)，将所有加号+替换为%20。</p>\n<h2 id=\"中文编码问题\">中文编码问题<a title=\"#中文编码问题\" href=\"#中文编码问题\"></a></h2>\n<p>  如果URL中有汉字，就必须编码后使用。但是麻烦的是，RFC 1738没有规定具体的编码方法，而是交给应用程序（浏览器）自己决定。这导致“URL编码”成为了一个混乱的领域。<br>\n  下面就让我们看看，“URL编码”到底有多混乱。我会依次分析四种不同的情况，在每一种情况中，浏览器的URL编码方法都不一样。把它们的差异解释清楚之后，我再说如何用Javascript找到一个统一的编码方法。</p>\n<h3 id=\"情况1：网址路径中包含汉字\">情况1：网址路径中包含汉字<a title=\"#情况1：网址路径中包含汉字\" href=\"#情况1：网址路径中包含汉字\"></a></h3>\n<p>  打开IE（我用的是8.0版），输入网址“<a href=\"http://zh.wikipedia.org/wiki/%E6%98%A5%E8%8A%82\" target=\"_blank\" rel=\"noopener\">http://zh.wikipedia.org/wiki/春节</a> ”。注意，“春节”这两个字此时是网址路径的一部分。查看HTTP请求的头信息，会发现IE实际查询的网址是“<a href=\"http://zh.wikipedia.org/wiki/%E6%98%A5%E8%8A%82\" target=\"_blank\" rel=\"noopener\">http://zh.wikipedia.org/wiki/春节</a> ”。也就是说，IE自动将“春节”编码成了“%E6%98%A5%E8%8A%82”。<br>\n  我们知道，“春”和“节”的utf-8编码分别是“E6 98 A5”和“E8 8A 82”，因此，“%E6%98%A5%E8%8A%82”就是按照顺序，在每个字节前加上%而得到的。<br>\n  <strong>结论1就是，网址路径的编码，用的是utf-8编码。</strong></p>\n<h3 id=\"情况2：查询字符串包含汉字\">情况2：查询字符串包含汉字<a title=\"#情况2：查询字符串包含汉字\" href=\"#情况2：查询字符串包含汉字\"></a></h3>\n<p>  在IE中输入网址“<a href=\"http://www.baidu.com/s?wd=%E6%98%A5%E8%8A%82\" target=\"_blank\" rel=\"noopener\">http://www.baidu.com/s?wd=春节</a> ”。注意，“春节”这两个字此时属于查询字符串，不属于网址路径，不要与情况1混淆。查看HTTP请求的头信息，会发现IE将“春节”转化成了一个乱码。切换到十六进制方式，才能清楚地看到，“春节”被转成了“B4 BA BD DA”。<br>\n  我们知道，“春”和“节”的GB2312编码（我的操作系统“Windows XP”中文版的默认编码）分别是“B4 BA”和“BD DA”。因此，IE实际上就是将查询字符串，以GB2312编码的格式发送出去。“%E6%98%A5%E8%8A%82”就是按照顺序，在每个字节前加上%而得到的。Firefox的处理方法，略有不同。它发送的HTTP Head是“wd=%B4%BA%BD%DA”。也就是说，同样采用GB2312编码，但是在每个字节前加上了%。<br>\n  <strong>结论2就是，查询字符串的编码，用的是操作系统的默认编码。</strong></p>\n<h3 id=\"情况3：get方法生成的url包含汉字\">情况3：Get方法生成的URL包含汉字<a title=\"#情况3：get方法生成的url包含汉字\" href=\"#情况3：get方法生成的url包含汉字\"></a></h3>\n<p>  前面说的是直接输入网址的情况，但是更常见的情况是，在已打开的网页上，直接用Get或Post方法发出HTTP请求。<br>\n  根据台湾中兴大学吕瑞麟老师的试验 ，这时的编码方法由网页的编码决定，也就是由HTML源码中字符集的设定决定。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">http-equiv</span>=<span class=\"string\">\"Content-Type\"</span> <span class=\"attr\">content</span>=<span class=\"string\">\"text/html;charset=xxxx\"</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>  如果上面这一行最后的charset是UTF-8，则URL就以UTF-8编码；如果是GB2312，URL就以GB2312编码。举例来说，百度是GB2312编码，Google是UTF-8编码。因此，从它们的搜索框中搜索同一个词“春节”，生成的查询字符串是不一样的。<br>\n  <strong>结论3就是，GET和POST方法的编码，用的是网页的编码。</strong></p>\n<h3 id=\"情况4：ajax调用的url包含汉字\">情况4：Ajax调用的URL包含汉字<a title=\"#情况4：ajax调用的url包含汉字\" href=\"#情况4：ajax调用的url包含汉字\"></a></h3>\n<p>  前面三种情况都是由浏览器发出HTTP请求，最后一种情况则是由Javascript生成HTTP请求，也就是Ajax调用。还是根据吕瑞麟老师的文章，在这种情况下，IE和Firefox的处理方式完全不一样。</p>\n<p>举例来说，有这样两行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url &#x3D; url + &quot;?q&#x3D;&quot; +document.myform.elements[0].value; &#x2F;&#x2F; 假定用户在表单中提交的值是“春节”这两个字</span><br><span class=\"line\">http_request.open(&#39;GET&#39;, url, true);</span><br></pre></td></tr></table></figure>\n<p>  那么，无论网页使用什么字符集，IE传送给服务器的总是“q=%B4%BA%BD%DA”，而Firefox传送给服务器的总是“q=%E6%98 %A5%E8%8A%82”。也就是说，<strong>在Ajax调用中，IE总是采用GB2312编码（操作系统的默认编码），而Firefox总是采用utf-8编码。这就是我们的结论4。</strong></p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://www.jianshu.com/p/cfd3c8abb2c4\" target=\"_blank\">URL 如何编码解码？为什么要编码？</a><br>\n   2. <a href=\"https://blog.csdn.net/Lxd_0111/article/details/78028889\" target=\"_blank\">为什么要进行URL编码</a><br>\n   3. <a href=\"https://blog.csdn.net/xuebing1995/article/details/80664450\" target=\"_blank\">关于URL编码 对空格的处理问题</a><br>\n   4. <a href=\"https://www.cnblogs.com/xiaojiulin/p/10598658.html\" target=\"_blank\">URL中文编码问题</a></p>\n","prev":{"title":"问题精析：Mipmap","link":"2020/07/06/问题精析：Mipmap"},"next":{"title":"问题2：返回倒数第k个节点","link":"2020/07/05/问题2：返回倒数第k个节点"},"plink":"http://Ssssshinji.github.io/2020/07/06/问题精析：URL编码规则与规范/","toc":[{"id":"为什么要编码？","title":"为什么要编码？","index":"1"},{"id":"url-是如何编码的？","title":"URL 是如何编码的？","index":"2"},{"id":"哪些字符需要编码？","title":"哪些字符需要编码？","index":"3"},{"id":"空格编码问题","title":"空格编码问题","index":"4"},{"id":"中文编码问题","title":"中文编码问题","index":"5","children":[{"id":"情况1：网址路径中包含汉字","title":"情况1：网址路径中包含汉字","index":"5.1"},{"id":"情况2：查询字符串包含汉字","title":"情况2：查询字符串包含汉字","index":"5.2"},{"id":"情况3：get方法生成的url包含汉字","title":"情况3：Get方法生成的URL包含汉字","index":"5.3"},{"id":"情况4：ajax调用的url包含汉字","title":"情况4：Ajax调用的URL包含汉字","index":"5.4"}]},{"id":"参考资料","title":"参考资料","index":"6"}]}