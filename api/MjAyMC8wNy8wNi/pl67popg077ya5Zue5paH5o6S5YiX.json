{"title":"问题4：回文排列","date":"2020-07-06T15:33:45.000Z","date_formatted":{"ll":"Jul 6, 2020","L":"07/06/2020","MM-DD":"07-06"},"link":"2020/07/06/问题4：回文排列","tags":["数组与字符串"],"categories":["算法练习"],"updated":"2020-07-06T16:48:09.065Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  给定一个字符串，编写一个函数判定其是否为某个回文串的排列之一。回文串是指正反两个方向都一样的单词或短语。排列是指字母的重新排列。回文串不一定是字典当中的单词。</font><br>\n示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入:Tact Coa</span><br><span class=\"line\">输出:True(排列有&quot;taco cat&quot;,&quot;atco cta&quot;,等等)</span><br></pre></td></tr></table></figure>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  和判断是否为回文字符串的题目有所区别，这道题的范围更广，要分辨其是否能重新排列成回文字符串。也可以利用数组，记录每个字符的出现次数，应该都是偶数次或者有一个为奇数次。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool IsPermutationOfPalindrome(string str)&#123;</span><br><span class=\"line\">    char [] charSet &#x3D; new char[128];</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; str.Length; i++)&#123;</span><br><span class=\"line\">        charSet[str[i]] ++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int count &#x3D; 0;</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; charSet.Length;i++)&#123;</span><br><span class=\"line\">        if(charSet[i]%2 &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">            count ++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(count &gt; 1)return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  怎样才能给出一个正、反两个方向都一致的字符序列呢？对于大多数的字符，都必须出现偶数次，这样才能使得其中一半构成字符串的前半部分，另一半构成字符串的后半部分。至多只能有一个字符（即中间的字符）可以出现奇数次。例如，我们知道tactcoapapa是一个回文排列，因为该字符串有2个t、4个a、2个c、2个p以及1个o，其中o将会成为潜在的回文串的中间字符。<br>\n  更准确地说，所有偶数长度的字符串（不包括非字母字符）所有的字符必须出现偶数次。奇数长度的字符串必须刚好有一个字符出现奇数次。当然，偶数长度的字符串不可能只包括一个出现奇数次的字符，否则其不会为偶数长度（一个出现奇数次的字符+若干个出现偶数次的字符=奇数个字符）。以此类推，奇数长度的字符串不可能所有的字符都出现偶数次（偶数的和仍然是偶数）。因此我们可以得知，一个回文串的排列不可能包含超过一个“出现奇数次的字符”。该推论同时涵盖了奇数长度和偶数长度字符串的例子。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;和我的解答基本相同，多了对大小写的不敏感</span><br><span class=\"line\">&#x2F;&#x2F;检查奇数个数的方法写的更简洁</span><br><span class=\"line\">bool checkMaxOneOdd(int[] charSet)&#123;</span><br><span class=\"line\">    bool foundOdd &#x3D; false;</span><br><span class=\"line\">    foreach(int count in charSet)&#123;</span><br><span class=\"line\">        if(count % 2 &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">            if(foundOdd)&#123;</span><br><span class=\"line\">                return false;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            foundOdd &#x3D; true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  O(n)。<br>\n  <strong>解法2</strong>：任何算法都要遍历整个字符串，因此，无法对时间复杂度再进行优化，但可稍作优化。因为该题目相对简单，所以有必要对其稍作优化或调整。可以在遍历的同时检查是否有字符只出现了奇数次，而不需要在遍历结束时再进行检查。因此，在一次遍历结束时，我们即有了答案。</p>\n<h2 id=\"标准解答-1\">标准解答<a title=\"#标准解答-1\" href=\"#标准解答-1\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bool IsPermutationOfPalindrome(string str)&#123;</span><br><span class=\"line\">    int countOdd &#x3D; 0;</span><br><span class=\"line\">    int[] table &#x3D; new int[(int)(Char.GetNumericValue(&#39;z&#39;) - Char.GetNumericValue(&#39;a&#39;)+1)];</span><br><span class=\"line\">    foreach(char c in str.ToCharArray())&#123;</span><br><span class=\"line\">        int x &#x3D; getCharNumber(c);&#x2F;&#x2F;使大小写不敏感的函数</span><br><span class=\"line\">        if(x !&#x3D; -1)&#123;</span><br><span class=\"line\">            table[x]++;</span><br><span class=\"line\">            if(table[x] % 2 &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">                countOdd++;</span><br><span class=\"line\">            &#125;else&#123;countOdd--;&#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return countOdd &lt;&#x3D; 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  需要清楚说明的是，该算法并不一定更优。该算法有着相同的时间复杂度，而且可能还会稍慢一些。我们最终没有遍历散列表，但是对于单个字符加入了几行额外的代码。你应该将该算法作为备选项而非最优解与面试官进行讨论。<br>\n  <strong>解法3</strong>:如果你能更深入地思考该问题，或许会注意到字符出现的个数无关紧要。重要的是，字符出现是偶数次还是奇数次。你可以将其想象为开灯与关灯的操作（初始状态下灯是关着的）。如果灯最后是关闭状态，并不需要知道对其进行了多少次的开关操作，只需知道操作的次数是偶数次的。<br>\n  因此，可以在本题中使用一个整数数值（或者位向量）。每当看到一个字符，就将其映射到0与26之间的一个数值（假设所有字符都是英语字母），然后切换该数值对应的比特位。在遍历结束后，需要检查是否最多只有一个比特位被置为1。<br>\n  判断整数数值中没有比特位为1易如反掌，只需将整数数值与0进行比较。判断整数数值中是否刚好有一个比特位为1，则有一个很巧妙的办法。<br>\n  例如有一个整数数值00010000。我们当然可以通过重复的移位操作判断是否只有一个比特位为1。另一种方法是，如果将该数字减1，则会得到00001111。可以发现，这两个数字之间比特位没有重叠（而对于00101000，将其减1会得到00100111，比特位发生了重叠）。因此，判断一个数是否刚好有一个比特位为1，可以通过将其减1的结果与该数本身进行与操作，如果其结果为0，则比特位中1刚好出现一次。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  对算法的优化以及位运算还不是很熟悉。</p>\n<h2 id=\"提示：#106，#121，#134，#136\">提示：#106，#121，#134，#136<a title=\"#提示：#106，#121，#134，#136\" href=\"#提示：#106，#121，#134，#136\"></a></h2>\n<p>  -不必且也不应该生成所有的排列。这将极为低效。<br>\n  -作为回文排列的字符串有什么特征？<br>\n  -你试过散列表吗？你应该能把它降到O(N)的时间。<br>\n  -使用位向量可以减少空间使用吗？</p>\n","prev":{"title":"问题精析：View矩阵的推导","link":"2020/07/07/问题精析：View矩阵的推导"},"next":{"title":"问题精析：Mipmap","link":"2020/07/06/问题精析：Mipmap"},"plink":"http://Ssssshinji.github.io/2020/07/06/问题4：回文排列/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"复杂度分析","title":"复杂度分析","index":"6"},{"id":"标准解答-1","title":"标准解答","index":"7"},{"id":"反思","title":"反思","index":"8"},{"id":"提示：#106，#121，#134，#136","title":"提示：#106，#121，#134，#136","index":"9"}]}