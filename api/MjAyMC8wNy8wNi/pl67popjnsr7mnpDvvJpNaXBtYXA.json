{"title":"问题精析：Mipmap","date":"2020-07-05T18:08:36.000Z","date_formatted":{"ll":"Jul 6, 2020","L":"07/06/2020","MM-DD":"07-06"},"link":"2020/07/06/问题精析：Mipmap","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-05T18:17:48.009Z","content":"<h2 id=\"概念\">概念<a title=\"#概念\" href=\"#概念\"></a></h2>\n<p>  想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。<br>\n  OpenGL使用一种叫做**多级渐远纹理(Mipmap)**的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：<br>\n<img src=\"https://learnopengl-cn.github.io/img/01/06/mipmaps.png\" alt=\"\"><br>\n  手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。后面的教程中你会看到该如何使用它。<br>\n  在渲染中切换多级渐远纹理级别(Level)时，OpenGL在两个不同级别的多级渐远纹理层之间会产生不真实的生硬边界。就像普通的纹理过滤一样，切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>过滤方式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>GL_NEAREST_MIPMAP_NEAREST</td>\n<td>使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>\n</tr>\n<tr>\n<td>GL_LINEAR_MIPMAP_NEAREST</td>\n<td>使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>\n</tr>\n<tr>\n<td>GL_NEAREST_MIPMAP_LINEAR</td>\n<td>在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>\n</tr>\n<tr>\n<td>GL_LINEAR_MIPMAP_LINEAR</td>\n<td>在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>\n</tr>\n</tbody>\n</table></div></div><p>  就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);</span><br><span class=\"line\">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br></pre></td></tr></table></figure>\n<p>  一个常见的<strong>错误</strong>是，将放大过滤的选项设置为多级渐远纹理过滤选项之一。这样没有任何效果，因为<strong>多级渐远纹理主要是使用在纹理被缩小的情况</strong>下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。<br>\n  GL_TEXTURE_MIN_FILTER方式下，param有6种:不过上述4种都必须定义了Mipmap才能使用</p>\n<h2 id=\"如何选择合适的mipmap层？\">如何选择合适的mipmap层？<a title=\"#如何选择合适的mipmap层？\" href=\"#如何选择合适的mipmap层？\"></a></h2>\n<p>  计算一个像素与其所覆盖的纹理区域的面积比例（取x,y方向上的最大缩放值），由此选定mipmap层。</p>\n<h2 id=\"如何生成mipmap纹理？\">如何生成Mipmap纹理？<a title=\"#如何生成mipmap纹理？\" href=\"#如何生成mipmap纹理？\"></a></h2>\n<p>  可以自己程序来生成，或者:<br>\n  1.自己调用gluScaleImage()来逐级生成；<br>\n  2.然后通过glTexImage2D(GLenum target,GLint level,…);进行加载<br>\n  OpenGL3.0及以后，可使用glGenerateMipmap(GLenum target)来生成当前纹理的mipmap。也就是将mipmap从glu库中提到了核心库中！（现在常用此方法）</p>\n<h2 id=\"mipmap存在的问题\">Mipmap存在的问题<a title=\"#mipmap存在的问题\" href=\"#mipmap存在的问题\"></a></h2>\n<p>  如果覆盖区域非常狭长，与正方形相差较大，效果不好。<br>\n  克服方法：各向异性滤波<br>\n  非均向性（anisotropy),或作各向异性，与各向同性相反，指问题的全部或部分物理、化学等性质方向的不同而有所变化的特性，例如石墨单晶的电导率在不同方向的差异可达到数千倍，又如天文学上，宇宙微波背景辐射亦拥有些微的非均向性。许多的物理量都具有非均向性，如弹性模量、点导率、在酸中的溶解速度等。<br>\n  各向异性扩散滤波主要是用来平滑图像的，克服了高斯模糊的缺陷，各向异性扩散在平滑图像时是保留图像边缘的，和双边滤波很像。</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/\" target=\"_blank\">纹理</a><br>\n   2. <a href=\"https://zhuanlan.zhihu.com/p/91737007\" target=\"_blank\">《图形编程技术学习》（五十一）Mipmap</a></p>\n","prev":{"title":"问题4：回文排列","link":"2020/07/06/问题4：回文排列"},"next":{"title":"问题精析：URL编码规则与规范","link":"2020/07/06/问题精析：URL编码规则与规范"},"plink":"http://Ssssshinji.github.io/2020/07/06/问题精析：Mipmap/","toc":[{"id":"概念","title":"概念","index":"1"},{"id":"如何选择合适的mipmap层？","title":"如何选择合适的mipmap层？","index":"2"},{"id":"如何生成mipmap纹理？","title":"如何生成Mipmap纹理？","index":"3"},{"id":"mipmap存在的问题","title":"Mipmap存在的问题","index":"4"},{"id":"参考资料","title":"参考资料","index":"5"}]}