{"title":"问题精析：View矩阵的推导","date":"2020-07-06T16:48:32.000Z","date_formatted":{"ll":"Jul 7, 2020","L":"07/07/2020","MM-DD":"07-07"},"link":"2020/07/07/问题精析：View矩阵的推导","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-06T17:48:05.359Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"概念\">概念<a title=\"#概念\" href=\"#概念\"></a></h2>\n<p>  <strong>观察空间</strong>(view space)也被称为摄像机空间，在观察空间中，摄像机位于原点，它决定了我们渲染游戏所使用的视角。前面说过，观察空间采用的是右手坐标系，所以+z轴指的是摄像机后方。（摄像机看着-z。unity和OpenGL都采用这种右手坐标系。顺带一提，unity里除了观察空间，都是左手坐标系。OpenGL则是除了NDC，都是右手坐标系。）顶点变化的第二步，就是将顶点坐标从世界空间变换到观察空间中。这个变换叫观察变换(view transform)。</p>\n<p>为了得到顶点在观察空间的位置，我们可以有<strong>两种方法</strong>。</p>\n<p><strong>一种方法</strong>是计算观察空间的三个坐标轴在世界空间的表示，然后按照“坐标空间的变换”的方法算出观察空间到世界空间的变换矩阵，再求逆得住世界空间到观察空间的变换矩阵。</p>\n<p><strong>第二种方法</strong>是平移整个观察空间，让摄像机原点位于世界空间原点，坐标轴与世界空间坐标轴重合。两种方法得到的变换矩阵是一样的。(一般采取第二种，比较直观)</p>\n<h2 id=\"第一种方法\">第一种方法<a title=\"#第一种方法\" href=\"#第一种方法\"></a></h2>\n<p>  <strong>UVN系统</strong>：本身是一个基。如下图所示，三个基向量U，V，N分别指向相机的右方、上方和后方从而构成右手坐标系，相机则处于坐标原点。<br>\n  在参考系下（这里是世界坐标系），我们给定相机的位置——eye，被观察的小人的位置——lookat，以及一个辅助向量——参考系中表示“上方”的向量up，这个向量会影响U和V的生成，因为以后求出的V向量会在up和N向量所决定的平面上，所以可以通过这个向量让相机产生不同的偏转。<br>\n  首先我们求出向量\\vec {N}：<br>\n$$<br>\n\\vec {N} = lookat - eye<br>\n$$<br>\n  然后，我们求出向量\\vec {U}。这一步需要使用辅助向量up，如果不希望相机产生偏转，一般取(0, 1, 0)：<br>\n$$<br>\n\\vec {U} = \\vec {up} \\times \\vec {N};<br>\n$$<br>\n  U使用向量的叉乘实现。最后，使用N和U计算出向量\\vec {V}：<br>\n$$<br>\n\\vec {V} = \\vec {N} \\times \\vec {U};<br>\n$$<br>\n  按照“坐标空间的变换”的方法进行坐标系转换，并配合平移矩阵，便得到了观察矩阵。</p>\n<h2 id=\"第二种方法\">第二种方法<a title=\"#第二种方法\" href=\"#第二种方法\"></a></h2>\n<p>  要理解这个方法，重要的一点是，想象摄像机和场景中的每个物体都有一根棍子连接在一起，所谓的平移整个观察空间，是指摄像机带动场景内的物体一起移动，直到摄像机移动到坐标原点（屏幕中央），这时我们看到的屏幕就是摄像机的视角了。<br>\n  举例：摄像机在世界空间中的变换是按(30,0,0)进行旋转，然后按(0,10,-10)进行了平移。那么，为了把摄像机重新移动回初始状态。（指原点位于世界坐标的原点，坐标轴和世界空间的坐标轴重合）我们需要进行逆向变换，即先按(0，-10，10)平移，以便摄像机回到原点，再按(-30,0,0)进行旋转，以便让坐标轴重合。因此，变换矩阵就是：<br>\n$$<br>\n\\begin{pmatrix}<br>\n1 &amp; 0 &amp; 0 &amp; 0 \\\\<br>\n0 &amp; cos\\theta &amp; -sin\\theta &amp; 0 \\\\<br>\n0 &amp; sin\\theta &amp; cos\\theta &amp; 0 \\\\<br>\n0 &amp; 0 &amp; 0 &amp; 0 \\\\<br>\n\\end{pmatrix}<br>\n\\begin{pmatrix}<br>\n1 &amp; 0 &amp; 0 &amp; t_x \\\\<br>\n0 &amp; 1 &amp; 0 &amp; t_y \\\\<br>\n0 &amp; 0 &amp; 1 &amp; t_z \\\\<br>\n0 &amp; 0 &amp; 0 &amp; 1 \\\\<br>\n\\end{pmatrix}<br>\n$$<br>\n  如果在unity中，因为左右手坐标系的变化，还需要对z轴取负。<br>\n$$<br>\n\\begin{pmatrix}<br>\n1 &amp; 0 &amp; 0 &amp; t_x \\\\<br>\n0 &amp; 1 &amp; 0 &amp; t_y \\\\<br>\n0 &amp; 0 &amp; -1 &amp; t_z \\\\<br>\n0 &amp; 0 &amp; 0 &amp; 1 \\\\<br>\n\\end{pmatrix}<br>\n$$</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. Unity Shader 入门精要 冯乐乐著<br>\n   2. JungHyun Han - 3D Graphics for Game Programming-CRC Press (2011)<br>\n   2. <a href=\"http://eclipseflower.github.io/2017/01/11/View-Matrix/\" target=\"_blank\">观察矩阵推导</a></p>\n","prev":{"title":"问题3：删除中间节点","link":"2020/07/08/问题3：删除中间节点"},"next":{"title":"问题4：回文排列","link":"2020/07/06/问题4：回文排列"},"plink":"http://Ssssshinji.github.io/2020/07/07/问题精析：View矩阵的推导/","toc":[{"id":"概念","title":"概念","index":"1"},{"id":"第一种方法","title":"第一种方法","index":"2"},{"id":"第二种方法","title":"第二种方法","index":"3"},{"id":"参考资料","title":"参考资料","index":"4"}]}