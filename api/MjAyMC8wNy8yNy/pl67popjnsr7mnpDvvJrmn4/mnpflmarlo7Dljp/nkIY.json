{"title":"问题精析：柏林噪声原理","date":"2020-07-26T17:24:13.000Z","date_formatted":{"ll":"Jul 27, 2020","L":"07/27/2020","MM-DD":"07-27"},"link":"2020/07/27/问题精析：柏林噪声原理","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-26T17:32:26.776Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"应用\">应用<a title=\"#应用\" href=\"#应用\"></a></h2>\n<p>  柏林噪声是一个非常强大算法，经常用于程序生成随机内容，在游戏和其他像电影等多媒体领域广泛应用。算法发明者Ken Perlin也因此算法获得奥斯卡科技成果奖（靠算法拿奥斯卡也是没谁了666）。本文将剖析他于2002年发表的改进版柏林噪声算法。在游戏开发领域，柏林噪声可以用于生成波形，起伏不平的材质或者纹理。例如，它能用于程序生成地形（例如使用柏林噪声来生成我的世界（Minecraft）里的地形），火焰燃烧特效，水和云等等。柏林噪声绝大部分应用在2维，3维层面上，但某种意义上也能拓展到4维。柏林噪声在1维层面上可用于卷轴地形、模拟手绘线条等。<br>\n  如果将柏林噪声拓展到4维层面，以第4维，即w轴代表时间，就能利用柏林噪声做动画。例如，2D柏林噪声可以通过插值生成地形，而3D柏林噪声则可以模拟海平面上起伏的波浪。下面是柏林噪声在不同维度的图像以及在游戏中的应用场景。<br>\n<img src=\"https://images2015.cnblogs.com/blog/608996/201707/608996-20170721155322355-1352334868.png\" alt=\"\"></p>\n<h2 id=\"基本原理\">基本原理<a title=\"#基本原理\" href=\"#基本原理\"></a></h2>\n<blockquote>\n<p>注意：事先声明，本节内容大多源于this wonderful article by Matt Zucker，不过该篇文章内容也是建立在1980年所发明的柏林噪声算法基础上的。本文我将使用2002年发明的改进版柏林噪声算法。因此，我的算法版本跟Zucker的版本会有些不同。</p>\n</blockquote>\n<p>  让我们从最基本的柏林噪声函数看起：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public double perlin(double x, double y, double z);</span><br></pre></td></tr></table></figure>\n<p>  函数接收x,y,z三个坐标分量作为输入，并返回0.0~1.0的double值作为输出。那我们应该怎么处理输入值？首先，我们取3个输入值x,y,z的小数点部分，就可以表示为单元空间里的一个点了。为了方便讲解，我们将问题降维到2维空间来讨论（原理是一样的），下图是该点在2维空间上的表示：<br>\n<img src=\"https://upload-images.jianshu.io/upload_images/1797904-bfbbc85ed4afee99.png?imageMogr2/auto-orient/strip\" alt=\"\"><br>\n图1：小蓝点代表输入值在单元正方形里的空间坐标，其他4个点则是单元正方形的各顶点</p>\n<p>  接着，我们给4个顶点（在3维空间则是8个顶点）各自生成一个伪随机的梯度向量。梯度向量代表该顶点相对单元正方形内某点的影响是正向还是反向的（向量指向方向为正向，相反方向为反向）。而伪随机是指，对于任意组相同的输入，必定得到相同的输出。因此，虽然每个顶点生成的梯度向量看似随机，实际上并不是。这也保证了在梯度向量在生成函数不变的情况下，每个坐标的梯度向量都是确定不变的。<br>\n<img src=\"https://upload-images.jianshu.io/upload_images/1797904-ad4b0120e857b5d3.png?imageMogr2/auto-orient/strip\" alt=\"\"><br>\n图2：各顶点上的梯度向量随机选取结果</p>\n<blockquote>\n<p>请注意，上图所示的梯度向量并不是完全准确的。在本文所介绍的改进版柏林噪声中，这些梯度向量并不是完全随机的，而是由12条单位正方体（3维）的中心点到各条边中点的向量组成：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(1,1,0),(-1,1,0),(1,-1,0),(-1,-1,0), (1,0,1),(-1,0,1),(1,0,-1),(-1,0,-1), (0,1,1),(0,-1,1),(0,1,-1),(0,-1,-1)</span><br></pre></td></tr></table></figure>\n<p>  采用这些特殊梯度向量的原因在Ken Perlin’s SIGGRAPH 2002 paper: Improving Noise这篇文章里有具体讲解。</p>\n<blockquote>\n<p>举个例子来理解伪随机，比如我们从圆周率π（3.14159…）的小数部分中随机抽取某一位数字，结果看似随机，但如果抽取小数点后1位，结果必定为1；抽取小数点后2位，结果必定为4。<br>\n  接着，我们需要求出另外4个向量（在3维空间则是8个），它们分别从各顶点指向输入点（蓝色点）。下面有个2维空间下的例子：<br>\n<img src=\"https://upload-images.jianshu.io/upload_images/1797904-6dde06b2b941253d.png?imageMogr2/auto-orient/strip\" alt=\"\"><br>\n图3:各个距离向量</p>\n</blockquote>\n<p>  接着，对每个顶点的梯度向量和距离向量做点积运算，我们就可以得出每个顶点的影响值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">grad.x * dist.x + grad.y * dist.y + grad.z * dist.z</span><br></pre></td></tr></table></figure>\n<p>  这正是算法所需要的值，点积运算为两向量长度之积，再乘以两向量夹角余弦。</p>\n<p>  点积也可以理解为向量a在向量b上的投影，当距离向量在梯度向量上的投影为同方向，点积结果为正数；当距离向量在梯度向量上的投影为反方向，点积结果为负数。因此，通过两向量点积，我们就知道该顶点的影响值是正还是负的。不难看出，顶点的梯度向量直接决定了这一点。<br>\n  下一步，我们需要对4个顶点的影响值做插值，求得加权平均值（在3维空间则是8个）。算法非常简单（2维空间下的解法）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Below are 4 influence values in the arrangement:</span><br><span class=\"line\">&#x2F;&#x2F; [g1] | [g2]</span><br><span class=\"line\">&#x2F;&#x2F; -----------</span><br><span class=\"line\">&#x2F;&#x2F; [g3] | [g4]</span><br><span class=\"line\">int g1, g2, g3, g4;</span><br><span class=\"line\">int u, v;   &#x2F;&#x2F; These coordinates are the location of the input coordinate in its unit square.  </span><br><span class=\"line\">            &#x2F;&#x2F; For example a value of (0.5,0.5) is in the exact center of its unit square.</span><br><span class=\"line\"></span><br><span class=\"line\">int x1 &#x3D; lerp(g1,g2,u);</span><br><span class=\"line\">int x2 &#x3D; lerp(g3,h4,u);</span><br><span class=\"line\"></span><br><span class=\"line\">int average &#x3D; lerp(x1,x2,v);</span><br></pre></td></tr></table></figure>\n<p>  至此，整个柏林噪声算法还剩下最后一块拼图了：如果直接使用上述代码，由于是采用lerp线性插值计算得出的值，虽然运行效率高，但噪声效果不好，看起来会不自然。我们需要采用一种更为平滑，非线性的插值函数：fade函数，通常也被称为ease curve(也作为缓动函数在游戏中广泛使用)：<br>\n<img src=\"https://upload-images.jianshu.io/upload_images/1797904-27f5e6997742a89a.png?imageMogr2/auto-orient/strip\" alt=\"\"><br>\n  ease curve的值会用来计算前面代码里的u和v，这样插值变化不再是单调的线性变化，而是这样一个过程：初始变化慢，中间变化快，结尾变化又慢下来（也就是在当数值趋近于整数时，变化变慢）。这个用于改善柏林噪声算法的fade函数可以表示为以下数学形式：<br>\n$$<br>\n6t^5 - 15t^4 + 10t^3<br>\n$$<br>\n  基本上，这就是整个柏林噪声算法的原理了！搞清了算法的各个实现关键步骤后，现在让我们着手把代码实现出来。</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://www.cnblogs.com/leoin2012/p/7218033.html\" target=\"_blank\">一篇文章搞懂柏林噪声算法，附代码讲解</a></p>\n","prev":{"title":"问题2：变位词组","link":"2020/07/27/问题2：变位词组"},"next":{"title":"问题5：链表求和","link":"2020/07/26/问题5：链表求和"},"plink":"http://Ssssshinji.github.io/2020/07/27/问题精析：柏林噪声原理/","toc":[{"id":"应用","title":"应用","index":"1"},{"id":"基本原理","title":"基本原理","index":"2"},{"id":"参考资料","title":"参考资料","index":"3"}]}