{"title":"问题2：变位词组","date":"2020-07-27T13:21:49.000Z","date_formatted":{"ll":"Jul 27, 2020","L":"07/27/2020","MM-DD":"07-27"},"link":"2020/07/27/问题2：变位词组","tags":["排序和查找"],"categories":["算法练习"],"updated":"2020-07-27T15:14:00.187Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  编写一种方法，对字符串数组进行排序，将所有变位词排在相邻的位置。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  没思路，直接看提示。可以将数组中的每个元素排序，排序后相等的便是字符重组，放在一起即可。但哪怕这样，还需要O(n^2)的时间复杂度。后两个提示根本看不懂啥意思。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  我们需要一种快速简单的方法来确定两个字符串是否互为变位串。究竟是什么界定了两个单词是否互为变位词呢？变位词是指具有相同字符但顺序不同的单词。因此，如果可以把字符放在同一个顺序中，就能很容易地检查出新单词是否相同。<br>\n  做法之一就是套用一种标准排序算法，比如归并排序或快速排序，并修改比较器（comparator）。这个比较器用来指示两个互为变位词的字符串是一样的。<br>\n  检查两个词是否互为变位词，最简单的方法是什么呢？我们可以数一数每个字符串中各个字符出现的次数，两者相同则返回true，或者直接对字符串进行排序，若两个字符串互为变位词，排序后就相同。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class AnagramComparator : IComparer&lt;string&gt;&#123;</span><br><span class=\"line\">    public string sortChars(string s)&#123;</span><br><span class=\"line\">        char[] content &#x3D; s.ToCharArray();</span><br><span class=\"line\">        Array.Sort(content);</span><br><span class=\"line\">        return new string(content);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int Compare(string s1,string s2)&#123;</span><br><span class=\"line\">        return sortChars(s1).CompareTo(sortChars(s2));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static void Main(string[] args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    string[] array&#x3D; new string[] &#123;&quot;asdfg&quot;,&quot;qwerty&quot;,&quot;ytrewq&quot;,&quot;gfdsa&quot;&#125;;</span><br><span class=\"line\">    Array.Sort(array, new AnagramComparator());</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; array.Length; i++)&#123;</span><br><span class=\"line\">        System.Console.WriteLine(array[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  这个算法的时间复杂度为O(nlog(n))。这可能是使用通用排序算法所能取得的最佳情况了，但实际上，并不需要对整个数组进行排序，只需将变位词分组放在一起即可。</p>\n<h2 id=\"进阶\">进阶<a title=\"#进阶\" href=\"#进阶\"></a></h2>\n<p>  可以使用散列表做到这一点，这个散列表会将排序后的单词映射到它的一个变位词列表。举例来说，acre会映射到列表{acre, race, care}。一旦将所有同为变位词的单词分在同一组，就可以将它们放回到数组中。</p>\n<h2 id=\"标准解答-1\">标准解答<a title=\"#标准解答-1\" href=\"#标准解答-1\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void Sort(string[] array)&#123;</span><br><span class=\"line\">    HashMapList&lt;string,string&gt; mL &#x3D; new HashMapList();</span><br><span class=\"line\">    &#x2F;&#x2F;将同为变位词的单词分在同一组</span><br><span class=\"line\">    foreach(string s in array)&#123;</span><br><span class=\"line\">        string key &#x3D; sortChars(s);</span><br><span class=\"line\">        mL.Add(key,s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;将散列表转换为数组</span><br><span class=\"line\">    int index &#x3D; 0;</span><br><span class=\"line\">    foreach(string key in mL.Keys)&#123;</span><br><span class=\"line\">        ArrayList aL &#x3D; new ArrayList(mL[key]);</span><br><span class=\"line\">        foreach(string t in aL)&#123;</span><br><span class=\"line\">            array[index] &#x3D; t;</span><br><span class=\"line\">            index++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;这里的HashMapList是一个散列表，是自定义的类，在原书附录A中有实现，特点是可以一个key</span><br><span class=\"line\">    &#x2F;&#x2F;对应多个value</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  你或许看出来了，上面的算法是从桶排序法修改而来的。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  排序问题可以利用手动实现比较接口和比较器。</p>\n<h2 id=\"提示：#177，#182，#263，#342\">提示：#177，#182，#263，#342<a title=\"#提示：#177，#182，#263，#342\" href=\"#提示：#177，#182，#263，#342\"></a></h2>\n<p>  -你如何检查两个单词是否互为变位词？想一想如何定义“变位词”。用你自己的话来解释一下。<br>\n  -两个单词互为变位词是指含有相同的字符，但顺序不同。怎么才能把字符排好序呢？<br>\n  -你能利用标准排序算法吗？<br>\n  -你真的需要真正的排序吗？或者仅需重新组织列表就够了？</p>\n","prev":{"title":"问题精析：c#：IComparable和IComparer","link":"2020/07/28/问题精析：c-：IComparable和IComparer"},"next":{"title":"问题精析：柏林噪声原理","link":"2020/07/27/问题精析：柏林噪声原理"},"plink":"http://Ssssshinji.github.io/2020/07/27/问题2：变位词组/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"复杂度分析","title":"复杂度分析","index":"6"},{"id":"进阶","title":"进阶","index":"7"},{"id":"标准解答-1","title":"标准解答","index":"8"},{"id":"反思","title":"反思","index":"9"},{"id":"提示：#177，#182，#263，#342","title":"提示：#177，#182，#263，#342","index":"10"}]}