{"title":"问题2：栈的最小值","date":"2020-07-22T09:10:25.000Z","date_formatted":{"ll":"Jul 22, 2020","L":"07/22/2020","MM-DD":"07-22"},"link":"2020/07/22/问题2：栈的最小值","tags":["栈与队列"],"categories":["算法练习"],"updated":"2020-07-22T10:10:53.678Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  请设计一个栈，除了pop与push函数，还支持min函数，其可返回栈元素中的最小值。执行push、pop和min操作的时间复杂度必须为O(1)。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  min要时间复杂度为O(1),就一定不能用到遍历操作。个人思路是利用一个变量保存最小值，在每次入栈和出栈时都更新这个变量。问题是出栈的时候，如果最小的元素出栈了，如何更新min变量？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无解答</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  既然是最小值，就不会经常变动，只有在更小的元素加入时，才会改变。一种解法是在Stack类里添加一个int型的minValue。当minValue出栈时，我们会搜索整个栈，找出新的最小值。可惜，这不符合入栈和出栈操作时间为O(1)的要求。<br>\n  这就导出了我们的第二种解法。只要记下每种状态的最小值，获取最小值就是小菜一碟。实现方式很简单，每个节点记录当前最小值即可。这么一来，要找到min，直接查看栈顶元素就能得到最小值。<br>\n  当一个元素入栈时，该元素会记下当前最小值，将min记录在自身数据结构的min成员中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Node &#123;</span><br><span class=\"line\">    public Node next;</span><br><span class=\"line\">    public int value;</span><br><span class=\"line\">    public int subMin;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">public class MyStack&#123;</span><br><span class=\"line\">    public Node head;</span><br><span class=\"line\">    public int size;</span><br><span class=\"line\">    public int min;</span><br><span class=\"line\">    public int Size()&#123;</span><br><span class=\"line\">        return this.size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void Push(Node node)&#123;</span><br><span class=\"line\">        if(this.Size() &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">            head &#x3D; node;</span><br><span class=\"line\">            node.subMin &#x3D; node.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            if(node.value &lt; head.subMin)&#123;</span><br><span class=\"line\">                node.subMin &#x3D; node.value;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                node.subMin &#x3D; head.subMin;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            node.next &#x3D; head;</span><br><span class=\"line\">            head &#x3D; node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int Pop()&#123;</span><br><span class=\"line\">        if(this.Size() &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">            throw new Exception();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            int temp &#x3D; head.value;</span><br><span class=\"line\">            head &#x3D; head.next;</span><br><span class=\"line\">            return temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public int Min()&#123;</span><br><span class=\"line\">        return head.subMin;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> &amp;emsp但是，这种做法有个缺点：当栈很大时，每个元素都要记录min，就会浪费大量空间。还有没有更好的做法？利用其他的栈来记录这些min，我们也许可以比之前做得更好一些。<br>\n 为什么这么做可以节省空间？假设有个很大的栈，而第一个元素刚好是最小值。对于第一种解法，我们需要记录n个整数，其中n为栈的大小。不过，对于第二种解法，我们只需存储几项数据：第二个栈（只有一个元素）以及栈本身数据结构的若干成员。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class StackWithMin : Stack &#123;</span><br><span class=\"line\">    Stack s2;</span><br><span class=\"line\">    public StackWithMin()&#123;</span><br><span class=\"line\">        s2 &#x3D; new Stack();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void push(int value)&#123;</span><br><span class=\"line\">        if(value &lt;&#x3D; Min())&#123;</span><br><span class=\"line\">            s2.Push(value);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        base.Push(value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public new int Pop()&#123;</span><br><span class=\"line\">        int value &#x3D; base.Pop();</span><br><span class=\"line\">        if(value &#x3D;&#x3D; Min())&#123;</span><br><span class=\"line\">            s2.Pop();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public new int Min()&#123;</span><br><span class=\"line\">        if(s2.isEmpty())&#123;</span><br><span class=\"line\">            return Int32.MaxValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return s2.head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  利用额外的空间存储数据保证时间复杂度较小，要更深入理解空间换时间的策略。</p>\n<h2 id=\"提示：#27，#59，#78\">提示：#27，#59，#78<a title=\"#提示：#27，#59，#78\" href=\"#提示：#27，#59，#78\"></a></h2>\n<p>  -注意最小的元素不会经常变化。它只在添加更小的元素或最小的元素被弹出时才发生变化。<br>\n  -如果保持追踪每个栈节点的额外数据会怎么样？什么样的数据可能更容易解决这个问题呢？<br>\n  -考虑让每个节点知道它“子栈”的最小值（包括它下面的所有元素，以及它本身）。</p>\n","prev":{"title":"问题1：合并排序的数组","link":"2020/07/23/问题1：合并排序的数组"},"next":{"title":"问题精析：光线追踪发展史2","link":"2020/07/21/问题精析：光线追踪发展史2"},"plink":"http://Ssssshinji.github.io/2020/07/22/问题2：栈的最小值/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"题目解析","title":"题目解析","index":"3"},{"id":"反思","title":"反思","index":"4"},{"id":"提示：#27，#59，#78","title":"提示：#27，#59，#78","index":"5"}]}