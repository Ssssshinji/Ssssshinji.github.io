{"title":"问题4：化栈为列","date":"2020-08-02T17:30:15.000Z","date_formatted":{"ll":"Aug 3, 2020","L":"08/03/2020","MM-DD":"08-03"},"link":"2020/08/03/问题4：化栈为列","tags":["栈与队列"],"categories":["算法练习"],"updated":"2020-08-03T18:02:04.759Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  实现一个MyQueue类，该类用两个栈来实现一个队列。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  一个栈称为入队栈，一个栈称为出队栈。在入队时先pop出队栈中的元素，push到入队栈中，最后再push所要入队的元素；在出队时，先pop入队栈中的元素，push到出队栈中，最后再对出队栈使用pop，得到要出队的元素。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyQueue&lt;T&gt; &#123;</span><br><span class=\"line\">    private Stack&lt;T&gt; inStack &#x3D; new Stack&lt;T&gt;();</span><br><span class=\"line\">    private Stack&lt;T&gt; outStack &#x3D; new Stack&lt;T&gt;();</span><br><span class=\"line\">    public void Enqueue(T data)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;进队其实不需要转移，在标准解答中有体现</span><br><span class=\"line\">        while(outStack.Count !&#x3D; 0)&#123;</span><br><span class=\"line\">            inStack.Push(outStack.Pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        inStack.Push(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T Dequeue()&#123;</span><br><span class=\"line\">        while(inStack.Count !&#x3D; 0)&#123;</span><br><span class=\"line\">            outStack.Push(inStack.Pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return outStack.Pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public bool IsEmpty()&#123;</span><br><span class=\"line\">        if(inStack.Count &#x3D;&#x3D; 0 &amp;&amp; outStack.Count &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T Peek()&#123;</span><br><span class=\"line\">        while(inStack.Count !&#x3D; 0)&#123;</span><br><span class=\"line\">            outStack.Push(outStack.Pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return outStack.Peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  队列和栈的主要区别在于元素进出顺序（先进先出和后进先出），因此，我们需要修改peek()和pop()，以相反顺序执行操作。可以利用第二个栈反转元素的次序（弹出s1的元素，压入s2）。在这种实现中，每当执行peek()和pop()操作时，就要将s1的所有元素弹出，压入s2中，然后执行peek/pop操作，再将所有元素压入s1。<br>\n  上述做法也是可行的，但若连续执行两次pop/peek操作，那么，所有元素都要移来移去，重复移动毫无必要。我们可以延迟元素的移动，即让元素一直留在s2中，只有必须反转元素次序时才移动元素。<br>\n  在这种做法中，stackNewest顶端为最新元素，而stackOldest顶端则为最旧元素。在将一个元素出列时，我们希望先移除最旧元素，因此先将元素从stackOldest中出列。若stackOldest为空，则将stackNewest中的所有元素以相反的顺序转移到stackOldest中。如要插入元素，就将其压入stackNewest，因为最新元素位于它的顶端。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyQueue&lt;T&gt; &#123;</span><br><span class=\"line\">    private Stack&lt;T&gt; inStack &#x3D; new Stack&lt;T&gt;();</span><br><span class=\"line\">    private Stack&lt;T&gt; outStack &#x3D; new Stack&lt;T&gt;();</span><br><span class=\"line\">    public void Enqueue(T data)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;保证inStack栈始终有最新的元素即可</span><br><span class=\"line\">        inStack.Push(data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T Dequeue()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;这步判断很关键！！！</span><br><span class=\"line\">        if(outStack.Count &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">            while(inStack.Count !&#x3D; 0)&#123;</span><br><span class=\"line\">                outStack.Push(outStack.Pop());</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return outStack.Pop();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public bool IsEmpty()&#123;</span><br><span class=\"line\">        if(inStack.Count &#x3D;&#x3D; 0 &amp;&amp; outStack.Count &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T Peek()&#123;</span><br><span class=\"line\">        if(outStack.Count &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">            while(inStack.Count !&#x3D; 0)&#123;</span><br><span class=\"line\">                outStack.Push(outStack.Pop());</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return outStack.Peek();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  在实际的面试中，你有可能记不清具体的API调用。真的碰到这种情况时，也不必太紧张。你可以问一些小细节，多数面试官都不会为难你。他们更关心你能否做到通盘地理解问题。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  思考如何用现有的API实现所需要的API。</p>\n<h2 id=\"提示：#98，#114\">提示：#98，#114<a title=\"#提示：#98，#114\" href=\"#提示：#98，#114\"></a></h2>\n<p>  -队列和栈的主要区别是元素的顺序。队列删除最旧的项，栈删除最新的项。如果你只访问最新的项，那么如何从栈中删除最旧的项？<br>\n  -我们可以通过不断地删除最新的项（将这些项插入临时栈中）来删除栈中最老的项，直到得到一个元素为止。然后，在检索到最新项后，将所有元素返回。与此有关的问题是，每次在一行中做几个弹出操作（pop）将需要O(n)的时间。我们可以优化在一行中连续弹出这一场景吗？</p>\n","prev":{"title":"问题精析：反向运动学1","link":"2020/08/03/问题精析：反向运动学1"},"next":{"title":"问题精析：前向运动学","link":"2020/08/02/问题精析：前向运动学"},"plink":"http://Ssssshinji.github.io/2020/08/03/问题4：化栈为列/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"反思","title":"反思","index":"5"},{"id":"提示：#98，#114","title":"提示：#98，#114","index":"6"}]}