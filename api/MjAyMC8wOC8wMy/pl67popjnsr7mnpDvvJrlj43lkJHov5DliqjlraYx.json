{"title":"问题精析：反向运动学1","date":"2020-08-02T18:01:19.000Z","date_formatted":{"ll":"Aug 3, 2020","L":"08/03/2020","MM-DD":"08-03"},"link":"2020/08/03/问题精析：反向运动学1","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-08-02T18:47:46.826Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"概念及其应用场景\">概念及其应用场景<a title=\"#概念及其应用场景\" href=\"#概念及其应用场景\"></a></h2>\n<p>  在机器人学中，末端效应器（End Effector）指位于臂末端的装置。一个很好的例子是颚式夹持器，设计用来抓取对象。前向运动学将末端效应器的姿势表示为骨骼关节角度的函数。相反的过程被称为逆向数学（IK）。给定末端效应器的期望姿势和骨骼的初始姿势，计算最终姿势的骨骼角度。<br>\n  尽管IK是为机器人学中的运动规划而开发的，但对于角色动画来说，也非常重要。例如，它被用来计算腿的关节角度，使脚牢牢地落在不规则的地面上。通过实时解算IK，角色能够对不可预测的环境自发做出反应。IK增强了预先编写好的动画，以避免很容易被看出来是计算机生成的。</p>\n<h2 id=\"计算方法\">计算方法<a title=\"#计算方法\" href=\"#计算方法\"></a></h2>\n<p>  一般有三种：<br>\n  1.分析法（Analytic Solution）：即通过三角函数等进行分析计算，对于骨骼数少的可以进行此种运算，但是对于链很长的情况，用此方法就行不通。有些文章对此进行了改进，可以对多个骨骼进行分析计算得出结果。<br>\n  2.CCD (cyclic coordinate descent)：即通过三角函数等进行分析计算，对于骨骼数少的可以进行此种运算，但是对于链很长的情况，用此方法就行不通。有些文章对此进行了改进，可以对多个骨骼进行分析计算得出结果。<br>\n  3.数值方法，通过不断迭代运算求出一个近似解，这类方法比较多，同时也是普遍被接受的一类方法。它涉及到形成偏导数矩阵并计算雅可比矩阵的（伪）逆，代价是昂贵的。</p>\n<h2 id=\"分析法（analytic-solution）\">分析法（Analytic Solution）<a title=\"#分析法（analytic-solution）\" href=\"#分析法（analytic-solution）\"></a></h2>\n<h3 id=\"自由度（degrees--of--freedom）\">自由度（degrees  of  freedom）<a title=\"#自由度（degrees--of--freedom）\" href=\"#自由度（degrees--of--freedom）\"></a></h3>\n<img src=\"/2020/08/03/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E5%8F%8D%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A61/1.png\" class=\"\">\n<p>  比如上臂和肩膀的连接处，可以看作是球形关节。可以向左向右或是向前向后，称为pitch和yaw，也可以想螺丝刀那样转动，称为roll。这是3-DOF。肘部关节一般被看作铰链，1-DOF。</p>\n<h2 id=\"运算步骤\">运算步骤<a title=\"#运算步骤\" href=\"#运算步骤\"></a></h2>\n<img src=\"/2020/08/03/%E9%97%AE%E9%A2%98%E7%B2%BE%E6%9E%90%EF%BC%9A%E5%8F%8D%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A61/2.png\" class=\"\">\n<p>  用两个关节的胳膊来模拟分析法，把G当作末端效应器。我们要从G位置和初始的骨骼姿势来计算出肩部和肘部的转动角度。<br>\n  用\\(\\theta\\)表示肘部的角度。G为目标点，\\(l_g\\)为肩膀和G的距离，\\(l_u\\)\\(l_f\\)分别为上臂和前臂的长度。则根据余弦定理：<br>\n$$<br>\nl_g^2 = l_u^2 + l_f^2 - 2l_u l_f cos\\theta<br>\n$$<br>\n  由此可得到\\(\\theta\\)。<br>\n  用\\(\\phi\\)表示肩膀转动的角度。根据这个角度，前臂可以跟随上臂从T到G。用向量v1连接肩膀和T，用向量v2连接肩膀和G。利用点乘即可得到\\(\\phi\\)。<br>\n  由此可得到\\(\\theta\\)。<br>\n  除了旋转角度，我们还需要旋转轴。它垂直于v1和v2跨过的平面，因此可以由它们的叉积确定。然后，上臂绕着旋转轴旋转φ，T到达G。</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"\">JungHyun Han - 3D Graphics for Game Programming-CRC Press (2011)</a></p>\n","prev":{"title":"问题5：栈排序","link":"2020/08/04/问题5：栈排序"},"next":{"title":"问题4：化栈为列","link":"2020/08/03/问题4：化栈为列"},"plink":"http://Ssssshinji.github.io/2020/08/03/问题精析：反向运动学1/","toc":[{"id":"概念及其应用场景","title":"概念及其应用场景","index":"1"},{"id":"计算方法","title":"计算方法","index":"2"},{"id":"分析法（analytic-solution）","title":"分析法（Analytic Solution）","index":"3","children":[{"id":"自由度（degrees--of--freedom）","title":"自由度（degrees  of  freedom）","index":"3.1"}]},{"id":"运算步骤","title":"运算步骤","index":"4"},{"id":"参考资料","title":"参考资料","index":"5"}]}