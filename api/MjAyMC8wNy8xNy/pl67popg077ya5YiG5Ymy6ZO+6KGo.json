{"title":"问题4：分割链表","date":"2020-07-17T05:53:51.000Z","date_formatted":{"ll":"Jul 17, 2020","L":"07/17/2020","MM-DD":"07-17"},"link":"2020/07/17/问题4：分割链表","tags":["链表"],"categories":["算法练习"],"updated":"2020-07-17T18:07:35.184Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  编写程序以x为基准分割链表，使得所有小于x的节点排在大于或等于x的节点之前。如果链表中包含x，分割元素x只需处于“右半部分”即可，其不需要被置于左右两部分之间。（提示在页尾）</font><br>\n示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：3-&gt;5-&gt;8-&gt;5-&gt;10-&gt;2-&gt;1 [分割节点为5]</span><br><span class=\"line\">结果：3-&gt;1-&gt;2-&gt;10-&gt;5-&gt;5-&gt;8</span><br></pre></td></tr></table></figure>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  利用四个Node，分别存放前后两个链表的首尾，最后连在一起。或者同时从头尾遍历，头遍历时遇到bix大的和尾遍历时遇到比x小的交换位置。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  假如本题描述的是一个数组，对于如何移动元素则要非常谨慎。数组元素的移动通常开销很大。<br>\n  但是，在链表当中，情况要简单得多。与数组中需要移动和交换元素不同的是，可以通过创建两个链表完成该操作，其中一个链表包含小于x的元素，而另一个链表包含大于或等于x的元素。<br>\n  遍历链表，不断地将元素插入到before链表和after链表当中。当到达链表尾部并完成了分离操作后，将得到的两个链表合并。<br>\n  对于保持其原有的顺序的元素，该方法大体称得上运行“稳定”，除了对分割链表进行了必要的移动。下面的代码实现了该方法。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static Node Partition(Node node,int x)&#123;</span><br><span class=\"line\">    Node beforeStart &#x3D; null;</span><br><span class=\"line\">    Node beforeEnd &#x3D; null;</span><br><span class=\"line\">    Node afterStart &#x3D; null;</span><br><span class=\"line\">    Node afterEnd &#x3D; null;</span><br><span class=\"line\">    while(node !&#x3D; null)&#123;</span><br><span class=\"line\">        Node next &#x3D; node.next;</span><br><span class=\"line\">        node.next &#x3D; null;</span><br><span class=\"line\">        if(node.data &lt; x)&#123;</span><br><span class=\"line\">            if(beforeStart &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">                beforeStart.next &#x3D; node;</span><br><span class=\"line\">                beforeEnd &#x3D; beforeStart;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                beforeEnd.next &#x3D; node;</span><br><span class=\"line\">                beforeEnd &#x3D; node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            if(afterStart &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">                afterStart.next &#x3D; node;</span><br><span class=\"line\">                afterEnd &#x3D; afterStart;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            else&#123;</span><br><span class=\"line\">                afterEnd.next &#x3D; node;</span><br><span class=\"line\">                afterEnd &#x3D; node;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node &#x3D; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(beforeStart &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">        return afterStart;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    beforeEnd.next &#x3D; afterStart;</span><br><span class=\"line\">    return beforeStart;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  O(n)。<br>\n  使用4个变量跟踪2个链表确实麻烦，不妨将这段代码写的简短一些。<br>\n  如果不介意链表中的元素是否保持“稳定”（因为面试官没有提到这个要求，你也不需要必须保证其“稳定性”），可以不断地在链表头部和尾部加入元素，以便于整理链表。<br>\n  在该方法中，我们创建了一个“新”链表（借助已有节点），将大于基准点的元素加入到链表尾部，将小于基准点的元素加入到链表头部。每当加入一个元素时，就会更新头节点或者尾节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static Node Partition(Node node,int x)&#123;</span><br><span class=\"line\">    Node head &#x3D; node;</span><br><span class=\"line\">    Node tail &#x3D; node;</span><br><span class=\"line\"></span><br><span class=\"line\">    while(node !&#x3D; null)&#123;</span><br><span class=\"line\">        Node next &#x3D; node.next;</span><br><span class=\"line\">        if(node.data &lt; x)&#123;</span><br><span class=\"line\">            node.next &#x3D; head;</span><br><span class=\"line\">            head &#x3D; node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            tail.next &#x3D; node;</span><br><span class=\"line\">            tail &#x3D; node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        node &#x3D; next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tail.next &#x3D; null;</span><br><span class=\"line\">    return head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  应该问清楚链表是否双向之类的细节。第二种解答方法也需要好好理解，重点是Node next = node.next;这步的位置。</p>\n<h2 id=\"提示：#3，#24\">提示：#3，#24<a title=\"#提示：#3，#24\" href=\"#提示：#3，#24\"></a></h2>\n<p>  -这个问题有很多解法，其中大部分都有最优的运行时间。有些代码比其他代码更短，更干净。你可以想出不同的解法吗？<br>\n  -考虑元素不必保持相同的相对顺序。我们只需要确保小于基准点的元素必须位于比基准点大的元素之前。这有助于你想出更多的解法吗？</p>\n","prev":{"title":"问题精析：PBR实现ByOpenGL（带纹理）","link":"2020/07/18/问题精析：PBR实现ByOpenGL（带纹理）"},"next":{"title":"问题精析：PBR实现ByOpenGL","link":"2020/07/17/问题精析：PBR实现ByOpenGL"},"plink":"http://Ssssshinji.github.io/2020/07/17/问题4：分割链表/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"复杂度分析","title":"复杂度分析","index":"6"},{"id":"反思","title":"反思","index":"7"},{"id":"提示：#3，#24","title":"提示：#3，#24","index":"8"}]}