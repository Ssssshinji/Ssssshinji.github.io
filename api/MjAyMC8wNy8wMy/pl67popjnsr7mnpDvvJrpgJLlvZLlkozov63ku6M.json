{"title":"问题精析：递归和迭代","date":"2020-07-03T10:12:32.000Z","date_formatted":{"ll":"Jul 3, 2020","L":"07/03/2020","MM-DD":"07-03"},"link":"2020/07/03/问题精析：递归和迭代","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-05T17:07:45.617Z","content":"<h2 id=\"递归(recursion)\">递归(recursion)<a title=\"#递归(recursion)\" href=\"#递归(recursion)\"></a></h2>\n<p>  简而言之就是一种函数调用函数自身来完成算法设计的方法。是把问题转化为规模缩小了的同类问题的子问题。然后递归调用函数（或过程）来表示问题的解。<br>\n  递归是一个树结构，从字面可以其理解为重复“递推”和“回归”的过程，当“递推”到达底部时就会开始“回归”，其过程相当于树的深度优先遍历。<br>\n<strong>递归的标准模式（有可对函数的入口进行测试的基本情况）</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (条件)</span><br><span class=\"line\">    return (不需要递归的简单答案);</span><br><span class=\"line\">else</span><br><span class=\"line\">    return (递归调用同一函数)；</span><br></pre></td></tr></table></figure>\n<p>  - 必须有递归终止的条件。<br>\n  - 函数决定终止的参数有规律地递增或递减。<br>\n  在数据结构中，链表和二叉树都具备鲜明的递归特性。</p>\n<h3 id=\"直接递归\">直接递归<a title=\"#直接递归\" href=\"#直接递归\"></a></h3>\n<p>  也即是普通递归，单向递归，线性递归函数的最后一步操作不是递归操作，而是其他的操作。当数据量很大的时候，会造成栈溢出，这是因为，在每次递归调用时，递归函数中的参数，局部变量等都要保存在栈中，如果数据量很大的话，便可能会溢出。</p>\n<h3 id=\"尾递归\">尾递归<a title=\"#尾递归\" href=\"#尾递归\"></a></h3>\n<p>  也即是线性迭代，尾递归函数的最后一步操作是递归，也即在进行递归之前，把全部的操作先执行完，这样的好处是，不用花费大量的栈空间来保存上次递归中的参数、局部变量等，这是因为上次递归操作结束后，已经将之前的数据计算出来，传递给当前的递归函数，这样上次递归中的局部变量和参数等就会被删除，释放空间，从而不会造成栈溢出。但是很多编译器并没有自动对尾递归优化的功能，也即当编译器判断出当前所执行的操作是递归操作时，不会理会它究竟是线性递归还是尾递归，这样也就不会删除掉之前的局部变量和参数等。另外，尾部递归一般都可转化为循环语句。<br>\n  尾递归的原理：当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。</p>\n<h3 id=\"直接递归与尾递归的对比\">直接递归与尾递归的对比<a title=\"#直接递归与尾递归的对比\" href=\"#直接递归与尾递归的对比\"></a></h3>\n<p>  一般来说，线性递归和尾递归的时间复杂度相差不大（当然也有例外情况，比如斐波拉契数列，这是因为其线性递归的实现，产生了大量冗余的计算，它的时间复杂度为指数级，而其尾递归的实现只需要线性级别的时间复杂度）。线性递归容易理解，尾部递归性能比较好。<br>\n  但尾递归的空间复杂度比较小（这是在假定尾递归被优化的前提下）。尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如sum(n) = f(n) = f(n-1) + value(n) ;会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">线性递归</span><br><span class=\"line\">int fact(int n) &#123;</span><br><span class=\"line\">    if (n &lt; 0)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    else if(n &#x3D;&#x3D; 0 || n &#x3D;&#x3D; 1)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return n * fact(n - 1);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">尾递归</span><br><span class=\"line\">int facttail(int n, int res)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    if (n &lt; 0)</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">    else if(n &#x3D;&#x3D; 0)</span><br><span class=\"line\">        return 1;</span><br><span class=\"line\">    else if(n &#x3D;&#x3D; 1)</span><br><span class=\"line\">        return res;</span><br><span class=\"line\">    else</span><br><span class=\"line\">        return facttail(n - 1, n *res);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  在每次函数调用计算n倍的(n－1)!的值，让n=n－1并持续这个过程直到n=1为止。这种定义不是尾递归的，因为每次函数调用的返回值都依赖于用n乘以下一次函数调用的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。<br>\n  函数比代码1多个参数res，除此之外并没有太大区别。res（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令res=n*res并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回res即可。</p>\n<h2 id=\"迭代(iteration)\">迭代(iteration)<a title=\"#迭代(iteration)\" href=\"#迭代(iteration)\"></a></h2>\n<p>  重复反馈过程的活动，每一次迭代的结果会作为下一次迭代的初始值。（A重复调用B）<br>\n  迭代是一个环结构，从初始状态开始，每次迭代都遍历这个环，并更新状态，多次迭代直到到达结束状态。<br>\n<strong>迭代的准备工作（同循环语句类似）：</strong><br>\n  - 确定迭代变量；<br>\n  - 建立迭代关系式；<br>\n  - 对迭代过程进行控制。</p>\n<h2 id=\"递归与迭代对比\">递归与迭代对比<a title=\"#递归与迭代对比\" href=\"#递归与迭代对比\"></a></h2>\n<p>  - 迭代程序复杂，但效率高。<br>\n  - 递归程序逻辑清晰，但往往效率较低(空间复杂度高)。<br>\n  迭代和递归均包括终止条件测试，迭代在循环继续条件失败时终止，递归在达到基本情况时终止。计数器控制的循环和迭代和递归都是逐步达到终止的。迭代修改计数器直到计数器的值使循环条件不满足；递归产生比原来的问题简单的版本直到达到基本情况。</p>\n<h2 id=\"递归与迭代相互转换\">递归与迭代相互转换<a title=\"#递归与迭代相互转换\" href=\"#递归与迭代相互转换\"></a></h2>\n<p>  理论上递归和迭代可以相互转换，但实际从算法结构来说，递归声明的结构并不总能转换为迭代结构（原因有待研究）。迭代可以转换为递归，但递归不一定能转换为迭代。<br>\n  将递归算法转换为非递归算法有两种方法，一种是直接求值（迭代/循环），不需要回溯；另一种是不能直接求值，需要回溯。前者使用一些变量保存中间结果，称为直接转换法；后者使用栈保存中间结果，称为间接转换法，下面分别讨论这两种方法。</p>\n<h3 id=\"直接转换法\">直接转换法<a title=\"#直接转换法\" href=\"#直接转换法\"></a></h3>\n<p>  直接转换法通常用来消除尾递归（tail recursion）和单向递归，将递归结构用迭代结构来替代。（单向递归 → 尾递归 → 迭代）<br>\n斐波那契数列的递归求解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　int Fib(int n) &#123;</span><br><span class=\"line\">　　 if(n &lt;&#x3D; 1) return n;</span><br><span class=\"line\">　　 else return Fib(n - 1) + Fib(n - 2);</span><br><span class=\"line\">　&#125;</span><br></pre></td></tr></table></figure>\n<p>转化为迭代求解：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int Fib(int n) &#123;</span><br><span class=\"line\">　　 if(n &lt;&#x3D; 1) return n;</span><br><span class=\"line\">　　int twoBack &#x3D; 0;</span><br><span class=\"line\">　　 int oneBack &#x3D; 1;</span><br><span class=\"line\">　　 int cur;</span><br><span class=\"line\">　　for(int i &#x3D; 2;i &lt; &#x3D; n; i++) &#123;</span><br><span class=\"line\">   　　　cur &#x3D; twoBack + oneBack;</span><br><span class=\"line\">　　　 twoBack &#x3D; oneBack;</span><br><span class=\"line\">   　　　oneBack &#x3D; cur;</span><br><span class=\"line\">　　 &#125;</span><br><span class=\"line\">　　 return cur;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"间接转换法\">间接转换法<a title=\"#间接转换法\" href=\"#间接转换法\"></a></h3>\n<p>  递归实际上利用了系统堆栈实现自身调用，我们通过使用栈保存中间结果模拟递归过程，将其转为非递归形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">将初始状态s0进栈</span><br><span class=\"line\">　　while (栈不为空)</span><br><span class=\"line\">　　&#123;</span><br><span class=\"line\">　　    退栈，将栈顶元素赋给s;</span><br><span class=\"line\">　　if (s是要找的结果) 返回;</span><br><span class=\"line\">　　else &#123;</span><br><span class=\"line\">　　    寻找到s的相关状态s1;</span><br><span class=\"line\">　　    将s1进栈</span><br><span class=\"line\">　　    &#125;</span><br><span class=\"line\">　　&#125;</span><br></pre></td></tr></table></figure>\n<p>  间接转换法在数据结构中有较多实例，如二叉树遍历算法的非递归实现、图的深度优先遍历算法的非递归实现等等。</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://blog.csdn.net/iteye_7527/article/details/82538932\" target=\"_blank\">浅析线性递归和尾递归</a></p>\n<p>   2. <a href=\"https://blog.csdn.net/zcyzsy/article/details/77151709\" target=\"_blank\">递归和尾递归的区别和原理</a><br>\n   3. <a href=\"https://www.oschina.net/question/3306142_2242985\" target=\"_blank\">经典算法｜递归和递归消除的迭代法</a><br>\n   4. <a href=\"https://blog.csdn.net/LucienDuan/article/details/17186769\" target=\"_blank\">递归算法转换为非递归算法</a><br>\n   5. <a href=\"https://www.jianshu.com/p/32bcc45efd32\" target=\"_blank\">递归与迭代的区别</a></p>\n","prev":{"title":"问题精析：OpenGL纹理采样模式","link":"2020/07/03/问题精析：OpenGL纹理采样模式"},"next":{"title":"问题1：三合一","link":"2020/07/03/问题1：三合一"},"plink":"http://Ssssshinji.github.io/2020/07/03/问题精析：递归和迭代/","toc":[{"id":"递归(recursion)","title":"递归(recursion)","index":"1","children":[{"id":"直接递归","title":"直接递归","index":"1.1"},{"id":"尾递归","title":"尾递归","index":"1.2"},{"id":"直接递归与尾递归的对比","title":"直接递归与尾递归的对比","index":"1.3"}]},{"id":"迭代(iteration)","title":"迭代(iteration)","index":"2"},{"id":"递归与迭代对比","title":"递归与迭代对比","index":"3"},{"id":"递归与迭代相互转换","title":"递归与迭代相互转换","index":"4","children":[{"id":"直接转换法","title":"直接转换法","index":"4.1"},{"id":"间接转换法","title":"间接转换法","index":"4.2"}]},{"id":"参考资料","title":"参考资料","index":"5"}]}