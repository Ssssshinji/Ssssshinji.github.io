{"title":"问题1：三合一","date":"2020-07-03T07:35:04.000Z","date_formatted":{"ll":"Jul 3, 2020","L":"07/03/2020","MM-DD":"07-03"},"link":"2020/07/03/问题1：三合一","tags":["栈与队列"],"categories":["算法练习"],"updated":"2020-07-03T10:10:25.183Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  描述如何只使用一个数组来实现三个栈（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  最简单的想法是把一个数组分成三个部分。一：将新元素放在a[0]，并将已有元素往后移动。二：将新元素放在a[n]，并将已有元素往前移动。三：放在中间位置并向左或向右移动？或者按kn,k(n+1),k(n+2)的分类方法将数组分成三个部分，每一个部分存储一个栈。</p>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  和许多问题一样，这个问题的解法基本上取决于你要对栈支持到什么程度。若每个栈分配的空间大小固定，就能满足需要，那么照做便是。不过，这么做的话，有可能其中一个栈的空间不够用了，其他的栈却几乎是空的。另一种做法是弹性处理栈的空间分配，但这么一来，这个问题的复杂度又会大大增加。<br>\n<strong>方法1：固定分割：</strong><br>\n  将整个数组划分为三等份，并将每个栈的增长限制在各自的空间里。注意：记号[表示包含端点，（表示不包含端点。<br>\n  栈1，使用[0, n/3)<br>\n  栈2，使用[n/3, 2n/3)<br>\n  栈3，使用[2n/3, n)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class FixedMultiStack&#123;</span><br><span class=\"line\">    private int numberOfStacks &#x3D; 3;</span><br><span class=\"line\">    private int stackCapacity;</span><br><span class=\"line\">    private int[] values;</span><br><span class=\"line\">    private int[] sizes;</span><br><span class=\"line\">    public FixedMultiStack(int stackSize)&#123;</span><br><span class=\"line\">        stackCapacity &#x3D; stackSize;</span><br><span class=\"line\">        values &#x3D; new int[stackSize * numberOfStacks];</span><br><span class=\"line\">        sizes &#x3D; new int[numberOfStacks];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;压栈</span><br><span class=\"line\">    public void push(int stackNum, int value)&#123;</span><br><span class=\"line\">        if(isFull(stackNum))&#123;</span><br><span class=\"line\">            throw new Exception(&quot;空间不足&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;对栈顶指针加1并更新顶部的值</span><br><span class=\"line\">        sizes[stackNum]++;</span><br><span class=\"line\">        values[indexOfTop(stackNum)] &#x3D; value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;出栈</span><br><span class=\"line\">    public int pop(int stackNum)&#123;</span><br><span class=\"line\">        if(isEmpty(stackNum))&#123;</span><br><span class=\"line\">            throw new Exception(&quot;栈为空&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        int topIndex &#x3D; indexOfTop(stackNum);</span><br><span class=\"line\">        int value &#x3D; values[topIndex];&#x2F;&#x2F;获取顶部元素</span><br><span class=\"line\">        values[topIndex] &#x3D; 0;&#x2F;&#x2F;清零</span><br><span class=\"line\">        sizes[stackNum]--;</span><br><span class=\"line\">        return value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;返回顶部元素</span><br><span class=\"line\">    public int peek(int stackNum)&#123;</span><br><span class=\"line\">        if(isEmpty(stackNum))&#123;</span><br><span class=\"line\">            throw new Exception(&quot;栈为空&quot;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return values[indexOfTop(stackNum)];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;检查是否栈空</span><br><span class=\"line\">    public Boolean isEmpty(int stackNum)&#123;</span><br><span class=\"line\">        return sizes[stackNum] &#x3D;&#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;检查栈是否为满</span><br><span class=\"line\">    public Boolean isFull(int stackNum)&#123;</span><br><span class=\"line\">        return sizes[stackNum] &#x3D;&#x3D; stackCapacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;返回栈顶元素的索引</span><br><span class=\"line\">    private int indexOfTop(int stackNum)&#123;</span><br><span class=\"line\">        int offset &#x3D; stackNum * stackCapacity;</span><br><span class=\"line\">        int size &#x3D; sizes[stackNum];</span><br><span class=\"line\">        return offset + size - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>方法2：弹性分割：</strong><br>\n  第二种做法是允许栈块的大小灵活可变。当一个栈的元素个数超出其初始容量时，就将这个栈扩容至许可的容量，必要时还要搬移元素。此外，我们会将数组设计成环状的，最后一个栈可能从数组末尾处开始，环绕到数组起始处。请注意，这种解法的代码远比面试中常见的要复杂得多。你可以试着提供伪码，或是其中某几部分的代码，但要完整实现的话，难度就有点大了。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  用一个数据结构实现另一个数据结构时，不光要想怎么完成空间上的划分和基本逻辑的实现，还要根据所求数据结构的API，尽量做到易维护，可读性强。</p>\n<h2 id=\"提示：#2，#12，#38，#58\">提示：#2，#12，#38，#58<a title=\"#提示：#2，#12，#38，#58\" href=\"#提示：#2，#12，#38，#58\"></a></h2>\n<p>  -栈只是一个数据结构，其中最近添加的元素首先被删除。你能用一个数组来模拟单个栈吗？请记住，有很多可能的解法且每个解法都有其利弊。<br>\n  -我们可以通过将数组的前三分之一分配到第一个栈、第二个三分之一分配到第二个栈、最后的第三个三分之一分配到第三个栈，来模拟数组中的三个栈。然而，实际上某个栈可能比其他的大得多。能更灵活地分配吗？<br>\n  -如果你想考虑灵活划分，可以移动栈。你能保证使用所有可用的容量吗？<br>\n  -试着把数组看作是循环的，这样数组的结尾就“环绕”到了数组的开始部分。</p>\n","prev":{"title":"问题精析：递归和迭代","link":"2020/07/03/问题精析：递归和迭代"},"next":{"title":"问题2：最小高度树","link":"2020/07/01/问题2：最小高度树"},"plink":"http://Ssssshinji.github.io/2020/07/03/问题1：三合一/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"题目解析","title":"题目解析","index":"3"},{"id":"反思","title":"反思","index":"4"},{"id":"提示：#2，#12，#38，#58","title":"提示：#2，#12，#38，#58","index":"5"}]}