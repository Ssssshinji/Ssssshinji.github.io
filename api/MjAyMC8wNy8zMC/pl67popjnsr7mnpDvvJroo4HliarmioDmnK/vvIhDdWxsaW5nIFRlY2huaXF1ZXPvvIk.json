{"title":"问题精析：裁剪技术（Culling Techniques）","date":"2020-07-30T04:38:01.000Z","date_formatted":{"ll":"Jul 30, 2020","L":"07/30/2020","MM-DD":"07-30"},"link":"2020/07/30/问题精析：裁剪技术（Culling Techniques）","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-30T10:26:22.728Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"概念\">概念<a title=\"#概念\" href=\"#概念\"></a></h2>\n<p>  裁剪（Culling）的字面意思是“从大量事物中进行删除”。在计算机图形学中，相对应的就是裁剪技术（Culling Techniques）所要做的工作——“从大量游戏事物中进行删除”。所谓的“大量事物”就是需要绘制的整个场景，<strong>删除的是对最终图像没有贡献的场景部分</strong>，然后将剩余场景发送到渲染管线。因此，在渲染方面通常使用“可见性裁剪（Visibility Culling）”这个术语。但其实，裁剪也可以用于程序的其他部分，如碰撞检测（对不可见物体进行不十分精确的计算）、物理学计算，以及人工智能（AI）领域。<br>\n  理论上，<strong>裁剪操作可以发生在渲染管线的任何一个阶段</strong>，而且对于一些遮挡裁剪算法来说，甚至可以预先计算出来。对于在硬件中实现的裁剪算法来说，有时只需启动/禁止或者设置一些裁剪函数即可。而为了进行完全控制，我们可以在应用程序阶段在（CPU上）实现一些裁剪算法。裁剪通常可以使用几何计算来实现，但也不局限于此。例如，某算法也可以使用帧缓冲中的内容。</p>\n<h2 id=\"背面裁剪（backface-culling）\">背面裁剪（Backface Culling）<a title=\"#背面裁剪（backface-culling）\" href=\"#背面裁剪（backface-culling）\"></a></h2>\n<p>  假设你正在观察一个场景中不透明的球体。大约有一半的球体是不可见的。那么，可以从中这个例子里得到一个众所周知的结论，那就是，对不可见的内容不需要进行渲染，因为它们对最终的渲染图像没有贡献。**不需要对球体的背面进行处理，这就是背面裁剪的基本思想。**对于一组物体来说，还可以一次性地进行背面裁剪，这也称为聚集背面裁剪（Clustered Backface Culling）。<br>\n<img src=\"https://img-blog.csdn.net/20171224134312255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n  确定多边形是否背向的两种不同测试。左图所示为屏幕空间的测试情形，三角形和四边形是正向，而七边形是背向。对背向的七边形，无需进行光栅化。右图为视点空间中背面测试情形，多边形A是背向的，而B和C是正向的。多背向的多边形A，无需进行光栅化。</p>\n<h2 id=\"层次视锥裁剪（hierarchical-view-frustum-culling）\">层次视锥裁剪（Hierarchical View Frustum Culling）<a title=\"#层次视锥裁剪（hierarchical-view-frustum-culling）\" href=\"#层次视锥裁剪（hierarchical-view-frustum-culling）\"></a></h2>\n<p>  如上文所示，只需对完全或者部分在视锥中的图元进行渲染。一种加快渲染速度的方法便是将每个物体的包围体与视锥进行比较，如果包围体位于视锥之外，那么便不需要渲染包围体中的几何体。由于这些计算在CPU上进行，因此包围体中的几何体不需要通过管线中的几何和光栅阶段。相反，如果包围体在视锥内或者与视锥相交，那么包围体中的内容就是可见的，所以必须发送到渲染管线中去。<br>\n  利用空间数据结构，可以分层地来应用这种裁剪。例如，对于层次包围体BVH来说，从根节点进行先序遍历（Preorder Transversal），就可以完成这一任务。<br>\n<img src=\"https://img-blog.csdn.net/20171224134333361?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n  左图所示为一组几何体和相应的包围体（球体），从视点位置使用视锥裁剪来渲染场景。右图所示为层次包围体，视节点的包围体与视锥相交，对子包围体进行遍历测试，左子树的包围体与视锥相交，而其中只有一个子节点与视锥相交，另外一个子包围体体外边，无需发送到管线。根节点中间子树的包围体完全位于视锥内部，可以立即进行渲染，右边的子树的包围体也完全位于视锥内部，所以不需要进一步测试就可以渲染整个子树。<br>\n  视锥裁剪操作位于应用程序阶段（CPU），这意味着几何阶段和光栅阶段都可以从中受益，对于大场景或者一定的相机视线来说，场景只有一小部分是可见的，只需要将这部分发送到渲染管线。可期望获得一定的加速效果，视锥裁剪技术利用了场景中的空间相关性，因为可以将彼此靠近的物体包围在一个包围体中，而且几乎所有包围体都是以层次形式聚集在一起。<br>\n  视锥裁剪操作位于应用程序阶段（CPU），这意味着几何阶段和光栅阶段都可以从中受益，对于大场景或者一定的相机视线来说，场景只有一小部分是可见的，只需要将这部分发送到渲染管线。可期望获得一定的加速效果，视锥裁剪技术利用了场景中的空间相关性，因为可以将彼此靠近的物体包围在一个包围体中，而且几乎所有包围体都是以层次形式聚集在一起。<br>\n  除了层次包围体，其他的空间数据结构同样也可以用于视锥裁剪，包括上文提到的八叉树和BSP树。但是当渲染动态场景时，这些方法便会显得不够灵活,不如层次包围体。</p>\n<h2 id=\"入口裁剪（portal-culling）\">入口裁剪（Portal Culling）<a title=\"#入口裁剪（portal-culling）\" href=\"#入口裁剪（portal-culling）\"></a></h2>\n<p>  对<strong>建筑物模型</strong>来说，很多裁剪方面的算法可以归结为入口裁剪（Protal Culling）。在这个方向，最早的算法由Airey提出，随后Teller和Sequin，以及Teller和Hanrahan构造出了更高效，更复杂的算法。<br>\n  入口裁剪算法的基本思想是，在室内场景中，建筑物墙面通常充当大的遮挡物，通过每个入口（如门或者窗户）进行视锥裁剪。当遍历入口的时候，就减小视锥。使得与入口尽可能紧密贴合。因此，可以将入口裁减算法看作是视锥裁剪算法的一种扩展，且需将位于视锥之外的入口丢弃。<br>\n  入口裁剪方法以某种方式对场景进行预处理，可以是自动形式，也可以是手动形式，可以将场景分割为一系列单元（Cells），其通常对应于建筑物中的房间或者走廊；链接进阶房间的门和窗口称为入口（Protals）。单元中的每个物体和单元的墙面可以存储在一个与单元关联的数据结构中，还可以将邻接单元和链接这些单元的入口信息保存在一个临接图中。<br>\n<img src=\"https://img-blog.csdn.net/20171224134345312?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n  入口裁剪 单元分别从A到H，入口是连接单元的通路，只对穿过入口能看到的几何体进行渲染。<br>\n<img src=\"https://img-blog.csdn.net/20171224134354306?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n  左图为房间顶视图，白线表示每一个入口的截锥体减少的方式。红线是在镜子上反射圆台来产生的。实际视图显示在右侧的图像中。</p>\n<h2 id=\"细节裁剪\">细节裁剪<a title=\"#细节裁剪\" href=\"#细节裁剪\"></a></h2>\n<p>  细节裁剪（Detail Culling）是一种通过牺牲质量换取速度的技术。其基本原理是，当视点处于运动的时候，场景中的微小细节对渲染出的图像贡献甚微。<strong>当视点停下来的时候，通常禁止细节裁剪。</strong><br>\n  考虑一个具有包围体的问题，将这个包围体投射到投影平面，然后以像素为单位来估算投影面积，如果像素的数量小于用户定义的阈值，那么不对这个物体进行进一步处理。基于这个原因，细节裁剪也往往被称为屏幕尺寸裁剪（Screen-Size Culling）。细节裁剪也可以在场景图上以层次形式来实现，几何阶段和光栅阶段都可以从这个算法中受益。<br>\n  另外，<strong>细节裁剪还可以作为一种简化的LOD技术来实现，其中一个LOD是整个模型，另外一个LOD是空物体。</strong></p>\n<h2 id=\"遮挡剔除（occlusion-culling）\">遮挡剔除（Occlusion Culling）<a title=\"#遮挡剔除（occlusion-culling）\" href=\"#遮挡剔除（occlusion-culling）\"></a></h2>\n<p>  遮挡裁剪（Occlusion Culling），也常被称作遮挡剔除。<br>\n  聊一聊遮挡剔除<strong>必要性</strong>。不难理解，可见性问题可以通过Z缓冲器的硬件构造来实现，即使可以使用Z缓冲器正确解决可见性问题，但其中Z缓冲并不是在所有方面都不是一个很“聪明”的机制。例如，假设视点正沿着一条直线观察，其中，在这条直线上有10个球体，虽然这10个球体进行了扫描转换，同时与Z缓冲器进行了比较并写入了颜色缓冲器和Z缓冲器，但是这个从这个视点渲染出的图像只会显示一个球体，即使所有10个球体都将被光栅化并与Z缓冲区进行比较，然后可能写入到颜色缓冲区与Z缓冲区。下图中间部分显示了在给定视点处场景的深度复杂度，深度复杂度指的是对每个像素重写的次数。对于有10个球体的情形，最中间的位置，深度复杂度为10，因为在这个地方渲染了10个球体（假设背面裁剪是关闭的），而且这意味着其中有9次像素写入是完全没有必要的。<br>\n<img src=\"https://img-blog.csdn.net/20171224134421110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"></p>\n<blockquote>\n<p>个人的理解是，裁剪是一个主动的选择，为了提高游戏的渲染速度。而z缓冲是为了解决画面中不存在可见性问题所必需的手段。所以我认为，z缓冲并不能算是裁剪技术，只是保证画面正确的一环。<br>\n  像上图这样无聊极端的场景，现实生活中很难找到，但其描述的这种密集性很高的模型的情形，在现实生活中却很常见，如热带雨林，发动机，城市，以及摩天大楼的内部。下图显示了曼哈顿式城市的示例。<br>\n<img src=\"https://img-blog.csdn.net/20171224134434318?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n  城市鸟瞰图，左图为视锥裁剪后的图示，中图为视锥裁剪后的图示，右图所示为遮挡剔除和视锥裁剪后的图示<br>\n  从上面给出的示例可以看出，这种用来避免低效率的算法可以带来速度上的补偿，具体可以将这些方法归类为遮挡裁剪算法（Occlusion Culling Algorithms），因为它们都试图裁剪掉被遮挡的部分，也就是被场景中其他物体遮挡的物体，最优的遮挡裁剪算法只选择其中可见得的部分。<br>\n  遮挡裁剪算法从形式上可以分成两类，分别是基于点的遮挡裁剪和基于单元的遮挡裁剪。如下图所示。<br>\n<img src=\"https://img-blog.csdn.net/20171224132911128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcG9lbV9xaWFubW8=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\"><br>\n  左图所示为基于点的可见性，右图所示为基于单元的可见性，其中单元是一个长方形，从中可以看出，从视点左边看上去，有些圆被遮挡了，但是从右边看上去，这些圆却是可见的，因为可以从单元的某个位置到这些圆画一些射线，这些射线没有和任何遮挡物相交。<br>\n  有多种不同种类的遮挡剔除算法：<br>\n  HardwareOcclusion Queries 硬件遮挡查询<br>\n  HierarchicalZ-Buffering 层次Z缓冲<br>\n  OcclusionHorizons 遮挡地平线<br>\n  OccluderShrinking 遮挡物收缩<br>\n  FrustumGrowing视锥扩张<br>\n  Virtualoccluder 虚拟遮挡物算法<br>\n  ShaftOcclusion Culling 轴遮挡裁剪<br>\n  TheHOM algorithm 层次遮挡映射算法<br>\n  RaySpace Occlusion Culling 射线空间遮挡剔除</p>\n</blockquote>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://blog.csdn.net/zhmxy555/article/details/78884513\" target=\"_blank\">【《Real-Time Rendering 3rd》 提炼总结】(十一) 第十四章 : 游戏开发中的渲染加速算法总结</a></p>\n","prev":{"title":"问题精析：骨骼层级及坐标空间变换","link":"2020/07/31/问题精析：骨骼层级及坐标空间变换"},"next":{"title":"问题1：交换数字","link":"2020/07/29/问题1：交换数字"},"plink":"http://Ssssshinji.github.io/2020/07/30/问题精析：裁剪技术（Culling Techniques）/","toc":[{"id":"概念","title":"概念","index":"1"},{"id":"背面裁剪（backface-culling）","title":"背面裁剪（Backface Culling）","index":"2"},{"id":"层次视锥裁剪（hierarchical-view-frustum-culling）","title":"层次视锥裁剪（Hierarchical View Frustum Culling）","index":"3"},{"id":"入口裁剪（portal-culling）","title":"入口裁剪（Portal Culling）","index":"4"},{"id":"细节裁剪","title":"细节裁剪","index":"5"},{"id":"遮挡剔除（occlusion-culling）","title":"遮挡剔除（Occlusion Culling）","index":"6"},{"id":"参考资料","title":"参考资料","index":"7"}]}