{"title":"问题精析：渲染管线","date":"2020-06-30T18:32:28.000Z","date_formatted":{"ll":"Jul 1, 2020","L":"07/01/2020","MM-DD":"07-01"},"link":"2020/07/01/问题精析：渲染管线","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-05T17:07:49.498Z","content":"<h2 id=\"概念\">概念<a title=\"#概念\" href=\"#概念\"></a></h2>\n<p>  渲染管线的主要功能是决定在给定虚拟相机、三维物体、光源、照明模式，以及纹理等诸多条件的情况下，生成或绘制一幅二维图像的过程。对于实时渲染来说，渲染管线就是基础。因此，我们可以说，渲染管线是实时渲染的底层工具。</p>\n<h2 id=\"步骤\">步骤<a title=\"#步骤\" href=\"#步骤\"></a></h2>\n<p>  应用程序阶段 Application<br>\n  几何阶段 Geometry Processing<br>\n    顶点着色器 Vertex Shader<br>\n      变换 MVP Transformation<br>\n      投影 Projection<br>\n    图元装配 Primitive Assembly <strong>（在顶点着色器之后进行，容易记不清楚）</strong><br>\n    可选阶段 Optional Stage<br>\n      表面细分 Tessellation<br>\n      几何着色器 Geometry Shader<br>\n      流输出 Stream Output<br>\n    裁剪与屏幕映射 Clipping &amp; Screen Mapping<br>\n  光栅化阶段 The Rasterizer Stage<br>\n    三角形设定 Triangle Setup<br>\n    三角形遍历 Triangle Traversal<br>\n    像素处理 Pixel Processing<br>\n    像素着色器 Pixel Shader<br>\n    合并 Merging</p>\n<h3 id=\"应用程序阶段\">应用程序阶段<a title=\"#应用程序阶段\" href=\"#应用程序阶段\"></a></h3>\n<p>  应用程序阶段一般是图形渲染管线概念上的第一个阶段。应用程序阶段是通过软件方式来实现的阶段，开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。其他阶段，他们全部或者部分建立在硬件基础上，因此要改变实现过程会非常困难。<br>\n  应用程序阶段通常实现的方法有碰撞检测、加速算法、输入检测，动画，力反馈以及纹理动画，变换仿真、几何变形，以及一些不在其他阶段执行的计算，如层次视锥裁剪等加速算法就可以在这里实现。</p>\n<h3 id=\"几何阶段\">几何阶段<a title=\"#几何阶段\" href=\"#几何阶段\"></a></h3>\n<p>  输入是顶点与图元的顶点索引，输出是屏幕空间的顶点。简单来说，几何阶段就是负责把顶点都转换到屏幕空间，以便光栅化阶段处理。<br>\n  顶点着色器的输入是顶点和顶点属性，顶点着色器负责将顶点的位置从局部空间转换到齐次剪切空间 (Homogeneous Clipping Space)，顶点着色器还可以操作顶点相关的属性，比如颜色，法线，纹理坐标等，一般会在顶点着色器会计算逐顶点的光照。<br>\n  还会在顶点着色器做其他一些操作，比如 Instancing (将同一个物体的顶点绘制在多个地方)，或者做关节动画，蒙皮，顶点动画。</p>\n<p><strong>可选阶段 Optional Stage</strong><br>\n  表面细分 Tessellation：主要用来做面的细分，可以将现有的面数拆分得更多，提供更多得细节。这个阶段常用来生成更精细的地形或其他表面。</p>\n<p>  几何着色器 Geometry Shader：几何着色器的输入是整个图元，还可以获得邻接图元的信息。几何着色器可以丢弃一些图元，还可以生成新的图元。这个阶段可以简化图元，例如用来做细节等级 (Level of detail，LOD)。也可以用来生成图形，例如用来做粒子生成。</p>\n<p>  与 Tessellation 相比，几何着色器可以丢弃图元，也可以将现有的图元转换成其他图元。而 Tessellation 只能增加面数。</p>\n<p>  流输出 Stream Output：在几何着色器中生成的顶点数据可以流输出到 GPU Memory 。这些数据可以再次放到流水线里，或者被 CPU 读取。这种方式可以迭代处理数据，常用来做水流模拟，或者粒子效果。</p>\n<h2 id=\"光栅化阶段-the-rasterizer-stage\">光栅化阶段 The Rasterizer Stage<a title=\"#光栅化阶段-the-rasterizer-stage\" href=\"#光栅化阶段-the-rasterizer-stage\"></a></h2>\n<p>  经过裁剪和挑选剩下的多边形必须被光栅化。光栅化是一个决定哪些像素被几何图元覆盖的过程。多边形、线段和点根据为每种图元指定的规则分别被光栅化。光栅化的结果是像素位置的集合和片段的集合。当光栅化后，一个图元拥有的顶点数目和产生的片段之间没有任何关系。例如，一个由三个顶点组成的三角形占据整个屏幕，因此需要生成上百万的片段。<br>\n  片段和像素之间的区别变得非常重要。术语像素（Pixel）是图像元素的简称。一个像素代表帧缓存中某个指定位置的内容，例如颜色，深度和其它与这个位置相关联的值。一个片段（Fragment）是更新一个特定像素潜在需要的一个状态。<br>\n  之所以术语片段是因为光栅化会把每个几何图元（例如三角形）所覆盖的像素分解成像素大小的片段（扫描转换）。一个片段有一个与之相关联的像素位置、深度值和经过插值的参数，例如颜色，第二（反射）颜色和一个或多个纹理坐标集。这些各种各样的经过插值的参数是来自变换过的顶点，这些顶点组成了某个用来生成片段的几何图元。你可以把片段看成是潜在的像素。如果一个片段通过了各种各样的光栅化测试（在光栅操作将做讨论），这个片段将被用于更新帧缓存中的像素。<br>\n<strong>三角形设定 Triangle Setup</strong>（有些不清楚）<br>\n  之前得到的都是三角形的顶点，而之后要计算屏幕上三角形会覆盖那些像素。三角形设定阶段会计算三角形边上 (及内部？)的像素坐标及相关的属性。<br>\n  (推测：应该是在这个阶段进行 反面剔除 (Backface Culling)，将反面朝向相机的三角形扔掉。)<br>\n  <strong>另一种说法</strong>是三角形设定阶段主要用来计算三角形表面的差异和三角形表面的其他相关数据。该数据主要用于扫描转换（scan conversion），以及由几何阶段处理的各种着色数据的插值操作所用。该过程在专门为其设计的硬件上执行。</p>\n<p><strong>三角形遍历 Triangle Traversal</strong>（有些不清楚）<br>\n  这个阶段会进行逐像素检查，检查每个像素 (或采样点)是否被三角形覆盖，如果覆盖则生成一个片元 (Fragment)。这一阶段也被称为扫描转换 (Scan Conversion)。<br>\n  <strong>另一种说法</strong>在三角形遍历阶段将进行逐像素检查操作，检查该像素处的像素中心是否由三角形覆盖，而对于有三角形部分重合的像素，将在其重合部分生成片段（fragment）。找到哪些采样点或像素在三角形中的过程通常叫三角形遍历（TriangleTraversal）或扫描转换（scan conversion）。每个三角形片段的属性均由三个三角形顶点的数据插值而生成（在第五章会有讲解）。这些属性包括片段的深度，以及来自几何阶段的着色数据。<br>\n<strong>像素处理 Pixel Processing</strong><br>\n  像素着色器 Pixel Shader：也被叫做片元着色器 (Fragment Shader)，用来逐像素的计算着色使用插值得来的着色数据作为输入，输出结果为一种或多种将被传送到下一阶段的颜色信息。纹理贴图和纹理过滤一般都是在这个阶段进行的。<br>\n  像素着色器的输入是逐像素的属性，这些属性是根据上个阶段中的顶点插值而得到的，插值一般使用透视纠正插值 (Perspective Correct Interpolation)由硬件完成，需要借助深度值才能正确地插值。<br>\n  像素着色器还可以获取邻近像素插值的变化量，可以进行梯度计算，这个特性主要用来做纹理过滤。<br>\n  像素着色器会输出一个该像素 (片元)的颜色，也可以选择不输出。像素着色器还可以修改深度缓冲 (Depth Buffer)，甚至是模板缓冲 (Stencil Buffer)的值。<br>\n  在现代 GPU 上，像素着色器 可以将进行不同类型的输出，并写入多重渲染目标 (Multiple Render Targets，MRT)，一个 RT 就是一个 buffer，可以将不同的信息写入不同的 RT，然后在下个阶段合成</p>\n<h2 id=\"合并-merging\">合并 Merging<a title=\"#合并-merging\" href=\"#合并-merging\"></a></h2>\n<p>  这个阶段主要是将目前这一帧计算出来的 Fragment 颜色和系统中所有的 buffer 合并（合成当前储存于缓冲器中的由之前的像素着色阶段产生的片段颜色），得到最终的颜色值。合并阶段不可编程，但是高度可配置。</p>\n<p>  通常会在这个阶段根据 Z-buffer 进行 可见性测试 (Depth test，深度测试)，只渲染能看见的片元。也会进行透明度测试 (Alpha Test)，混合半透明物体与透明物体的颜色。模板缓冲也会用来控制颜色合并。</p>\n<p>  经过合并阶段就可以得到最终屏幕显示的颜色了。</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. 《Real-Time Rendering 3rd》 提炼总结<br>\n   2. <a href=\"https://blog.csdn.net/shenzi/article/details/5417488\" target=\"_blank\">3D图形渲染管线</a><br>\n   3. <a href=\"https://blog.csdn.net/weixin_43072157/article/details/82563150\" target=\"_blank\">图形渲染管线简介</a></p>\n","prev":{"title":"问题2：最小高度树","link":"2020/07/01/问题2：最小高度树"},"next":{"title":"问题2：判定是否互为字符重排","link":"2020/07/01/问题2：判定是否互为字符重排"},"plink":"http://Ssssshinji.github.io/2020/07/01/问题精析：渲染管线/","toc":[{"id":"概念","title":"概念","index":"1"},{"id":"步骤","title":"步骤","index":"2","children":[{"id":"应用程序阶段","title":"应用程序阶段","index":"2.1"},{"id":"几何阶段","title":"几何阶段","index":"2.2"}]},{"id":"光栅化阶段-the-rasterizer-stage","title":"光栅化阶段 The Rasterizer Stage","index":"3"},{"id":"合并-merging","title":"合并 Merging","index":"4"},{"id":"参考资料","title":"参考资料","index":"5"}]}