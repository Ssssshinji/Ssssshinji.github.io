{"title":"问题2：最小高度树","date":"2020-07-01T04:29:57.000Z","date_formatted":{"ll":"Jul 1, 2020","L":"07/01/2020","MM-DD":"07-01"},"link":"2020/07/01/问题2：最小高度树","tags":["树与图"],"categories":["算法练习"],"updated":"2020-07-03T07:57:56.748Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  从叶子节点往上，依次让每个节点都尽量平衡。但是不知道要怎么写，看了提示也没有思路。试试连续用二分查找写一写吧。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static Node CreateNode(int[] a,int low, int high)&#123;</span><br><span class=\"line\">    int mid &#x3D; (low + high)&#x2F;2;</span><br><span class=\"line\">    Node root &#x3D; new Node(a[mid]);</span><br><span class=\"line\">    root.left &#x3D; CreateNode(a,low, mid-1);</span><br><span class=\"line\">    root.right &#x3D; CreateNode(a,mid+1, high);</span><br><span class=\"line\">    return root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  要创建一棵高度最小的树，就必须让左右子树的节点数量尽量接近，也就是说，我们要让数组中间的值成为根节点，这么一来，数组左边一半就成为左子树，右边一半成为右子树。<br>\n  然后，我们继续以类似方式构造整棵树。数组每一区段的中间元素成为子树的根节点，左半部分成为左子树，右半部分成为右子树。<br>\n  一种实现方式是使用简单的root.insertNode(int v)方法，从根节点开始，以递归方式将值v插入树中。这么做的确能构造最小高度的树，但不太高效。每次插入操作都要遍历整棵树，用时为O(NlogN)。另一种做法是以递归方式运用createMinimalBST方法，从而删去部分多余的遍历操作。这个方法会传入数组的一个区段，并返回最小树的根节点。</p>\n<h2 id=\"标准解答（bfs）\">标准解答（BFS）<a title=\"#标准解答（bfs）\" href=\"#标准解答（bfs）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static Node CreateNode(int[] a,int low, int high)&#123;</span><br><span class=\"line\">    if(low &lt; high)&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int mid &#x3D; (low + high)&#x2F;2;</span><br><span class=\"line\">    Node root &#x3D; new Node(a[mid]);</span><br><span class=\"line\">    root.left &#x3D; CreateNode(a,low, mid-1);</span><br><span class=\"line\">    root.right &#x3D; CreateNode(a,mid+1, high);</span><br><span class=\"line\">    return root;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  递归的时间复杂度往往是（偶尔不是）O(分支数^数的深度)，本题为O(2^N);</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  又忘记了边界检查。</p>\n<h2 id=\"（提示：#19，#73，#116）\">（提示：#19，#73，#116）<a title=\"#（提示：#19，#73，#116）\" href=\"#（提示：#19，#73，#116）\"></a></h2>\n<p>  -最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？<br>\n  -你可以通过找到“理想”的下一个要添加的元素和多次调用insertValue来实现。这样效率会有点儿低，因为你必须反复遍历树。尝试用递归代替。你能把这个问题分解为子问题吗？<br>\n  -最小的二叉树在每个节点左侧的节点数与右侧相同。现在我们把注意力放到根节点上，你要如何保证位于根的左侧和右侧的节点数量大致相同呢？</p>\n","prev":{"title":"问题1：三合一","link":"2020/07/03/问题1：三合一"},"next":{"title":"问题精析：渲染管线","link":"2020/07/01/问题精析：渲染管线"},"plink":"http://Ssssshinji.github.io/2020/07/01/问题2：最小高度树/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答（bfs）","title":"标准解答（BFS）","index":"5"},{"id":"复杂度分析","title":"复杂度分析","index":"6"},{"id":"反思","title":"反思","index":"7"},{"id":"（提示：#19，#73，#116）","title":"（提示：#19，#73，#116）","index":"8"}]}