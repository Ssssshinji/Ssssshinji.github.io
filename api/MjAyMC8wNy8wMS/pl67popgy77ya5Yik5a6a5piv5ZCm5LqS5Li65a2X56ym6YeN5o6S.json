{"title":"问题2：判定是否互为字符重排","date":"2020-06-30T17:35:53.000Z","date_formatted":{"ll":"Jul 1, 2020","L":"07/01/2020","MM-DD":"07-01"},"link":"2020/07/01/问题2：判定是否互为字符重排","tags":["数组与字符串"],"categories":["算法练习"],"updated":"2020-06-30T18:12:32.871Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  实现一个算法，确定一个字符串的所有字符是否不全都不同。假使不允许使用额外的数据结构，又该如何处理？（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  和前一个问题一样，可以使用字符数组来解决。搜索第一个字符串时，每遇到一个字符，相应数组位置加1，搜索第二个字符串时，每遇到一个字符，相应数组位置减1。如果两个互为字符重排的话，数组的每一个元素应该为0。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool IsAnagram(string str1, string str2)&#123;</span><br><span class=\"line\">    if(str1.Length !&#x3D; str2.Length)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int[] char_set &#x3D; new int[128];</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; str1.Length; i++)&#123;</span><br><span class=\"line\">        int val &#x3D; str1[i];</span><br><span class=\"line\">        char_set[val] +&#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; str2.Length; i++)&#123;</span><br><span class=\"line\">        int val &#x3D; str2[i];</span><br><span class=\"line\">        char_set[val] -&#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; char_set.Length; i++)&#123;</span><br><span class=\"line\">        if(char_set[i] !&#x3D; 0)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间复杂度\">时间复杂度<a title=\"#时间复杂度\" href=\"#时间复杂度\"></a></h2>\n<p>  经典O(n)。</p>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  -若两个字符串互为重排字符串，那么它们拥有同一组字符，只不过顺序不同。因此，对字符串排序，组成这两个重排字符串的字符就会有相同的顺序。我们只需比较排序后的字符串。<br>\n  -还可以充分利用变位词的定义——组成两个单词的字符数相同——来实现这个算法。创建一个类似于散列表的数组（从第4行到第7行），将其每个字符映射到其字符出现的次数。增加第一个字符串，然后减少第二个字符串，如果两者互为重排，则该数组最终将为0。若值为负值（一旦为负，则值将永为负值，不会为非0），就提早终止。若不这样做，则数组就会为0。原因在于，字符串长度相同，增加的次数与减少的次数也相同。若数组无负值，则不会有正值。（和我想得一模一样，优秀）</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static string Sort(string s)&#123;</span><br><span class=\"line\">    char[] content &#x3D; s.ToCharArray();</span><br><span class=\"line\">    Array.Sort(content);</span><br><span class=\"line\">    return new string(content);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bool Permutation(string s, string t)&#123;</span><br><span class=\"line\">    if(s.Length !&#x3D; t.Length)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Sort(s).Equals(Sort(t));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"标准解答（进阶）\">标准解答（进阶）<a title=\"#标准解答（进阶）\" href=\"#标准解答（进阶）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool IsAnagram(string str1, string str2)&#123;</span><br><span class=\"line\">    if(str1.Length !&#x3D; str2.Length)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int[] char_set &#x3D; new int[128];</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; str1.Length; i++)&#123;</span><br><span class=\"line\">        int val &#x3D; str1[i];</span><br><span class=\"line\">        char_set[val] +&#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; str2.Length; i++)&#123;</span><br><span class=\"line\">        int val &#x3D; str2[i];</span><br><span class=\"line\">        char_set[val] -&#x3D; 1;</span><br><span class=\"line\">        if(char_set[val] &lt; 0)&#123;</span><br><span class=\"line\">            return false;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  可以认为在内省排序中时间复杂度是O(nlogn)。<br>\n  这题解的比较顶了，不过还是忽略了可以优化的地方。</p>\n<h2 id=\"提示：#1，#84，#122，#131\">提示：#1，#84，#122，#131<a title=\"#提示：#1，#84，#122，#131\" href=\"#提示：#1，#84，#122，#131\"></a></h2>\n<p>  -描述两个字符串是否互为字符重排的含义。现在，看看你提供的定义，你能否根据这个定义检查字符串？<br>\n  -有一种解法需要O(NlogN)的时间。另一种解法需要使用一些空间，但需要运行时间为O(N)。<br>\n  -散列表有用吗？<br>\n  -两个重排的字符串应该具有相同的字符，但顺序不同。你可以让它们的顺序一样吗？</p>\n","prev":{"title":"问题精析：渲染管线","link":"2020/07/01/问题精析：渲染管线"},"next":{"title":"问题精析：延迟着色（deferred Shading）","link":"2020/06/30/问题精析：延迟着色（deferred Shading）"},"plink":"http://Ssssshinji.github.io/2020/07/01/问题2：判定是否互为字符重排/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"时间复杂度","title":"时间复杂度","index":"4"},{"id":"题目解析","title":"题目解析","index":"5"},{"id":"标准解答","title":"标准解答","index":"6"},{"id":"标准解答（进阶）","title":"标准解答（进阶）","index":"7"},{"id":"复杂度分析","title":"复杂度分析","index":"8"},{"id":"提示：#1，#84，#122，#131","title":"提示：#1，#84，#122，#131","index":"9"}]}