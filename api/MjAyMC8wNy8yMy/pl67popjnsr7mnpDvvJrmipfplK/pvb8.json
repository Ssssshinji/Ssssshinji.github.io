{"title":"问题精析：抗锯齿","date":"2020-07-23T10:32:10.000Z","date_formatted":{"ll":"Jul 23, 2020","L":"07/23/2020","MM-DD":"07-23"},"link":"2020/07/23/问题精析：抗锯齿","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-23T17:11:55.182Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"产生锯齿的原因\">产生锯齿的原因<a title=\"#产生锯齿的原因\" href=\"#产生锯齿的原因\"></a></h2>\n<p>  你能够清楚看见形成边缘的像素。这种现象被称之为锯齿(Aliasing)。锯齿的来源是因为场景的定义在三维空间中是连续的，而最终显示的像素则是一个离散的二维数组。所以判断一个点到底没有被某个像素覆盖的时候单纯是一个“有”或者“没有&quot;问题，丢失了连续性的信息，导致锯齿。<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_zoomed.png\" alt=\"\"><br>\n  光栅器是位于最终处理过的顶点之后到片段着色器之前所经过的所有的算法与过程的总和。光栅器会将一个图元的所有顶点作为输入，并将它转换为一系列的片段。顶点坐标理论上可以取任意值，但片段不行，因为它们受限于你窗口的分辨率。顶点坐标与片段之间几乎永远也不会有一对一的映射，所以光栅器必须以某种方式来决定每个顶点最终所在的片段/屏幕坐标。<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization.png\" alt=\"\"><br>\n  这里我们可以看到一个屏幕像素的网格，每个像素的中心包含有一个采样点(Sample Point)，它会被用来决定这个三角形是否遮盖了某个像素。图中红色的采样点被三角形所遮盖，在每一个遮住的像素处都会生成一个片段。虽然三角形边缘的一些部分也遮住了某些屏幕像素，但是这些像素的采样点并没有被三角形内部所遮盖，所以它们不会受到片段着色器的影响。<br>\n  你现在可能已经清楚走样的原因了。完整渲染后的三角形在屏幕上会是这样的：<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_filled.png\" alt=\"\"><br>\n  由于屏幕像素总量的限制，有些边缘的像素能够被渲染出来，而有些则不会。结果就是我们使用了不光滑的边缘来渲染图元，导致之前讨论到的锯齿边缘。</p>\n<h2 id=\"ssaa（超级采样）\">SSAA（超级采样）<a title=\"#ssaa（超级采样）\" href=\"#ssaa（超级采样）\"></a></h2>\n<p>  最开始我们有一种叫做超采样抗锯齿(Super Sample Anti-aliasing, SSAA)的技术，它会使用比正常分辨率更高的分辨率（即超采样）来渲染场景，当图像输出在帧缓冲中更新时，分辨率会被下采样(Downsample)至正常的分辨率。这些额外的分辨率会被用来防止锯齿边缘的产生。虽然它确实能够解决走样的问题，但是由于这样比平时要绘制更多的片段，它也会带来很大的性能开销。所以这项技术只拥有了短暂的辉煌。<br>\n  拿4xSSAA举例子，假设最终屏幕输出的分辨率是800x600, 4xSSAA就会先渲染到一个分辨率1600x1200的buffer上，然后再直接把这个放大4倍的buffer下采样致800x600。这种做法在数学上是最完美的抗锯齿。但是劣势也很明显，光栅化和着色的计算负荷都比原来多了4倍，render target的大小也涨了4倍。<br>\n  然而，在这项技术的基础上也诞生了更为现代的技术，叫做多重采样抗锯齿(Multisample Anti-aliasing, MSAA)。它借鉴了SSAA背后的理念，但却以更加高效的方式实现了抗锯齿。我们在这一节中会深度讨论OpenGL中内建的MSAA技术。</p>\n<h2 id=\"msaa（多重采样）\">MSAA（多重采样）<a title=\"#msaa（多重采样）\" href=\"#msaa（多重采样）\"></a></h2>\n<p>  为了理解什么是多重采样(Multisampling)，以及它是如何解决锯齿问题的，我们之前深入地了解OpenGL光栅器的工作方式。<br>\n  多重采样所做的正是将单一的采样点变为多个采样点（这也是它名称的由来）。我们不再使用像素中心的单一采样点，取而代之的是以特定图案排列的4个子采样点(Subsample)。我们将用这些子采样点来决定像素的遮盖度。当然，这也意味着颜色缓冲的大小会随着子采样点的增加而增加。<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_sample_points.png\" alt=\"\"><br>\n  上图的左侧展示了正常情况下判定三角形是否遮盖的方式。在例子中的这个像素上不会运行片段着色器（所以它会保持空白）。因为它的采样点并未被三角形所覆盖。上图的右侧展示的是实施多重采样之后的版本，每个像素包含有4个采样点。这里，只有两个采样点遮盖住了三角形。</p>\n<blockquote>\n<p>采样点的数量可以是任意的，更多的采样点能带来更精确的遮盖率。<br>\n  从这里开始多重采样就变得有趣起来了。我们知道三角形只遮盖了2个子采样点，所以下一步是决定这个像素的颜色。你的猜想可能是，我们对每个被遮盖住的子采样点运行一次片段着色器，最后将每个像素所有子采样点的颜色平均一下。在这个例子中，我们需要在两个子采样点上对被插值的顶点数据运行两次片段着色器，并将结果的颜色储存在这些采样点中。（幸运的是）这并<strong>不是</strong>它工作的方式，因为这本质上说还是需要运行更多次的片段着色器，会显著地降低性能。<br>\n  MSAA真正的工作方式是，无论三角形遮盖了多少个子采样点，（每个图元中）每个像素只运行一次片段着色器。片段着色器所使用的顶点数据会插值到每个像素的中心，所得到的结果颜色会被储存在每个被遮盖住的子采样点中。当颜色缓冲的子样本被图元的所有颜色填满时，所有的这些颜色将会在每个像素内部平均化。因为上图的4个采样点中只有2个被遮盖住了，这个像素的颜色将会是三角形颜色与其他两个采样点的颜色（在这里是无色）的平均值，最终形成一种淡蓝色。<br>\n  这样子做之后，颜色缓冲中所有的图元边缘将会产生一种更平滑的图形。让我们来看看前面三角形的多重采样会是什么样子：<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_samples.png\" alt=\"\"><br>\n  这里，每个像素包含4个子采样点（不相关的采样点都没有标注），蓝色的采样点被三角形所遮盖，而灰色的则没有。对于三角形的内部的像素，片段着色器只会运行一次，颜色输出会被存储到全部的4个子样本中。而在三角形的边缘，并不是所有的子采样点都被遮盖，所以片段着色器的结果将只会储存到部分的子样本中。根据被遮盖的子样本的数量，最终的像素颜色将由三角形的颜色与其它子样本中所储存的颜色来决定。<br>\n简单来说，一个像素中如果有更多的采样点被三角形遮盖，那么这个像素的颜色就会更接近于三角形的颜色。如果我们给上面的三角形填充颜色，就能得到以下的效果：<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/11/anti_aliasing_rasterization_samples_filled.png\" alt=\"\"><br>\n  对于每个像素来说，越少的子采样点被三角形所覆盖，那么它受到三角形的影响就越小。三角形的不平滑边缘被稍浅的颜色所包围后，从远处观察时就会显得更加平滑了。<br>\n  例如4xMSAA，三角形只覆盖了4个子采样点中的2个。所以这个三角形需要生成一个fragment在pixel shader里着色，只不过生成的fragment还是在<strong>像素中央</strong>（位置，法线等信息插值到像素中央）然后只运行一次pixel shader，最后得到的结果在resolve阶段会乘以0.5，因为这个三角形只覆盖了一半的采样点。<strong>现代所有GPU都在硬件上实现了这个算法，而且在shading的运算量远大于光栅化的今天，这个方法远比SSAA快很多。</strong><br>\n  不仅仅是颜色值会受到多重采样的影响，深度和模板测试也能够使用多个采样点。对深度测试来说，每个顶点的深度值会在运行深度测试之前被插值到各个子样本中。对模板测试来说，我们对每个子样本，而不是每个像素，存储一个模板值。当然，这也意味着深度和模板缓冲的大小会乘以子采样点的个数。</p>\n</blockquote>\n<h2 id=\"opengl关键代码\">OpenGL关键代码<a title=\"#opengl关键代码\" href=\"#opengl关键代码\"></a></h2>\n<p>  如果我们想要在OpenGL中使用MSAA，我们必须要使用一个能在每个像素中存储大于1个颜色值的颜色缓冲（因为多重采样需要我们为每个采样点都储存一个颜色）。所以，我们需要一个新的缓冲类型，来存储特定数量的多重采样样本，它叫做多重采样缓冲(Multisample Buffer)。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glfwWindowHint(GLFW_SAMPLES, 4);&#x2F;&#x2F;提示(Hint) GLFW，我们希望使用一个包含N个样本的多重采样缓冲。</span><br></pre></td></tr></table></figure>\n<p>  我们还需要调用glEnable并启用GL_MULTISAMPLE，来启用多重采样。在大多数OpenGL的驱动上，多重采样都是默认启用的，所以这个调用可能会有点多余，但显式地调用一下会更保险一点。这样子不论是什么OpenGL的实现都能够正常启用多重采样了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_MULTISAMPLE);</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/11%20Anti%20Aliasing/\" target=\"_blank\">抗锯齿</a><br>\n   1. <a href=\"https://www.zhihu.com/question/20236638/answer/14438218\" target=\"_blank\">请问FXAA、FSAA与MSAA有什么区别？效果和性能上哪个好？</a></p>\n","prev":{"title":"问题1：最后k行","link":"2020/07/26/问题1：最后k行"},"next":{"title":"问题1：合并排序的数组","link":"2020/07/23/问题1：合并排序的数组"},"plink":"http://Ssssshinji.github.io/2020/07/23/问题精析：抗锯齿/","toc":[{"id":"产生锯齿的原因","title":"产生锯齿的原因","index":"1"},{"id":"ssaa（超级采样）","title":"SSAA（超级采样）","index":"2"},{"id":"msaa（多重采样）","title":"MSAA（多重采样）","index":"3"},{"id":"opengl关键代码","title":"OpenGL关键代码","index":"4"},{"id":"参考资料","title":"参考资料","index":"5"}]}