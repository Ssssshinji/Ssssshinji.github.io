{"title":"问题1：合并排序的数组","date":"2020-07-23T04:30:45.000Z","date_formatted":{"ll":"Jul 23, 2020","L":"07/23/2020","MM-DD":"07-23"},"link":"2020/07/23/问题1：合并排序的数组","tags":["排序和查找"],"categories":["算法练习"],"updated":"2020-07-23T08:09:31.826Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  给定两个排序后的数组A和B，其中A的末端有足够的缓冲空间容纳B。编写一个方法，将B合并入A并排序。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  可以同时遍历A和B，将B中的元素按按大小插入A中，但是对于数组来说效率太低了。如果能从数组的末端往前面插入，利用本身的空余，可以减少移动数组元素的次数。可以很轻松得到B数组末端元素的位置，可是如何得到A数组最后一个有效元素的位置呢？</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void merge(int[] a, int[] b, int lastA, int lastB)&#123;</span><br><span class=\"line\">    int indexA &#x3D; lastA;</span><br><span class=\"line\">    int indexB &#x3D; lastB;</span><br><span class=\"line\">    int indexFinal &#x3D; lastA + lastB + 1;</span><br><span class=\"line\">    while(indexA &gt;&#x3D; 0 &amp;&amp; indexB &gt;&#x3D; 0)&#123;</span><br><span class=\"line\">        if(a[indexA] &gt; indexB)&#123;</span><br><span class=\"line\">            a[indexFinal] &#x3D; a[indexA];</span><br><span class=\"line\">            indexA --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            a[indexFinal] &#x3D; b[indexB];</span><br><span class=\"line\">            indexB --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        indexFinal--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;如果b中有剩余，还需进一步处理</span><br><span class=\"line\">    while(indexB &gt;&#x3D; 0)&#123;</span><br><span class=\"line\">        a[indexFinal] &#x3D; b[indexB];</span><br><span class=\"line\">        indexB --;</span><br><span class=\"line\">        indexFinal --;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  已知数组A末端有足够的缓冲，不需要再分配额外空间。处理方法很简单，就是逐一比较A和B中的元素，并按顺序插入数组，直至耗尽A和B中的所有元素。<br>\n  这么做的唯一问题是，如果将元素插入数组A的前端，就必须将原有的元素往后移动，以腾出空间。更好的做法是将元素插入数组A的末端，那里都是空闲的可用空间。<br>\n  下面的代码就实现了上述做法，从数组A和B的末端元素开始，将最大的元素放到数组A的末端。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void merge(int[] a, int[] b, int lastA, int lastB)&#123;</span><br><span class=\"line\">    int indexA &#x3D; lastA;</span><br><span class=\"line\">    int indexB &#x3D; lastB;</span><br><span class=\"line\">    int indexFinal &#x3D; lastA + lastB + 1;</span><br><span class=\"line\">    while(indexB &gt;&#x3D; 0)&#123;</span><br><span class=\"line\">        if(indexA &gt;&#x3D; 0 &amp;&amp;a[indexA] &gt; indexB)&#123;</span><br><span class=\"line\">            a[indexFinal] &#x3D; a[indexA];</span><br><span class=\"line\">            indexA --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            a[indexFinal] &#x3D; b[indexB];</span><br><span class=\"line\">            indexB --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        indexFinal--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  O(m+n)。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  又写的比我漂亮，吐啦！有重复代码的时候要考虑能不能合并。</p>\n<h2 id=\"提示：#332\">提示：#332<a title=\"#提示：#332\" href=\"#提示：#332\"></a></h2>\n<p>  -尝试从数组的末端向前端移动。</p>\n","prev":{"title":"问题精析：抗锯齿","link":"2020/07/23/问题精析：抗锯齿"},"next":{"title":"问题2：栈的最小值","link":"2020/07/22/问题2：栈的最小值"},"plink":"http://Ssssshinji.github.io/2020/07/23/问题1：合并排序的数组/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"复杂度分析","title":"复杂度分析","index":"6"},{"id":"反思","title":"反思","index":"7"},{"id":"提示：#332","title":"提示：#332","index":"8"}]}