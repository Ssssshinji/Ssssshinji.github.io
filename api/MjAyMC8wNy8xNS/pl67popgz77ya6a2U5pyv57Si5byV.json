{"title":"问题3：魔术索引","date":"2020-07-15T08:58:58.000Z","date_formatted":{"ll":"Jul 15, 2020","L":"07/15/2020","MM-DD":"07-15"},"link":"2020/07/15/问题3：魔术索引","tags":["递归与动态规划"],"categories":["算法练习"],"updated":"2020-07-15T10:03:29.114Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  在数组A[0…n-1]中，有所谓的魔术索引，满足条件A[i]=i。给定一个有序整数数组，元素值各不相同，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引。进阶：如果数组元素有重复值，又该如何处理呢？（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  如果a[i] &lt; i，比如说a[6] = 3,那么a[3]到a[6]之间都不可能有魔术索引。如果a[i] &gt; i,比如说a[4] = 7;那么在a[5]到a[7]之间都不可能有魔术索引，故可写出：</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int MagicIndex(int[] a)&#123;</span><br><span class=\"line\">    return MagicIndex(a,0,a.Length-1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static int MagicIndex(int[] a, int low, int high)&#123;</span><br><span class=\"line\">    if(a[low] &#x3D;&#x3D; low)return low;</span><br><span class=\"line\">    if(a[low] &lt; low)&#123;</span><br><span class=\"line\">        high &#x3D; a[low] -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(a[low] &gt; low)&#123;</span><br><span class=\"line\">        low &#x3D; a[low] + 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return MagicIndex(a,low,high);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  O(n)。</p>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  看到这个问题，第一个想到的应该是蛮力法，提到它并不丢人。蛮力法只需迭代访问整个数组，找出符合条件的元素即可。<br>\n  不过，既然给定数组是有序的，我们理应充分利用这个条件。你可能会发现这个问题与经典的二分查找问题大同小异。充分运用模式匹配法，就能找出适当的算法，我们又该怎么运用二分查找法呢？在二分查找中，要找出元素k，我们会先拿它跟数组中间的元素x比较，确定k位于x的左边还是右边。以此为基础，是否通过检查中间元素就能确定魔术索引的位置？下面来看一个样例数组。</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-40</td>\n<td>-20</td>\n<td>-1</td>\n<td>1</td>\n<td>2</td>\n<td>3</td>\n<td>5</td>\n<td>7</td>\n<td>9</td>\n<td>12</td>\n<td>13</td>\n</tr>\n</tbody>\n</table></div></div><p>  看到中间元素A[5]=3，我们可以断定魔术索引一定在数组右侧，因为A[mid]&lt;mid。<br>\n  <strong>为何魔术索引不会在数组左侧呢？注意，从元素i移至i-1时，此索引对应的值至少要减1，也可能更多（因为数组是有序的，且所有元素各不相同）。因此，如果中间元素因过小而不是魔术索引，那么往左侧移动时，索引减k，值至少也减k，所有余下的元素也会过小。</strong>(和自己的思路不一样)<br>\n  继续运用这个递归算法，就会写出与二分查找极为相似的代码</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public static int MagicIndex(int[] a)&#123;</span><br><span class=\"line\">    return MagicIndex(a,0,a.Length-1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public static int MagicIndex(int[] a, int low, int high)&#123;</span><br><span class=\"line\">    if(low &lt; high)&#123;return -1;&#125;</span><br><span class=\"line\">    int mid &#x3D; (low + high) &#x2F;2;</span><br><span class=\"line\">    if(a[mid] &#x3D;&#x3D; mid)&#123;</span><br><span class=\"line\">        return mid;</span><br><span class=\"line\">    &#125;else if(a[mid] &gt; mid)&#123;</span><br><span class=\"line\">        return MagicIndex(a,low,mid - 1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        return MagicIndex(a,mid + 1,high);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  如果数组元素有重复值，前面的算法就会失效。以下面的数组为例。</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n<th>6</th>\n<th>7</th>\n<th>8</th>\n<th>9</th>\n<th>10</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-10</td>\n<td>-5</td>\n<td>2</td>\n<td>2</td>\n<td>2</td>\n<td>3</td>\n<td>4</td>\n<td>7</td>\n<td>9</td>\n<td>12</td>\n<td>13</td>\n</tr>\n</tbody>\n</table></div></div><p>  看到A[mid]&lt;mid，我们无法断定魔术索引位于数组哪一边。它可能在数组右侧，跟前面一样。或者，也可能在左侧（在本例中的确在左侧）。<br>\n  它有没有可能在左侧的任意位置？未必。由A[5]=3可知，A[4]不可能是魔术索引。A[4]必须等于4，其索引才能成为魔术索引，但数组是有序的，故A[4]必定小于A[5]。<br>\n  其实，看到A[5]=3时，按照前面的做法，我们需要递归搜索右半部分。不过，若搜索左半部分，我们可以跳过一些元素，只递归搜索A[0]到A[3]的元素。A[3]是第一个可能成为魔术索引的元素。<br>\n  综上所述，我们得到一般模式：先比较midIndex和midValue是否相同。然后，若两者不同，则按如下方式递归搜索左半部分和右半部分。<br>\n  左半部分：搜索索引从start到Math.min(midIndex -1,midValue)的元素。<br>\n  右半部分：搜索索引从Math.max(midIndex+1, midValue)到end的元素。</p>\n<h2 id=\"标准解答（进阶）\">标准解答（进阶）<a title=\"#标准解答（进阶）\" href=\"#标准解答（进阶）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">与个人思路基本相同</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  对问题的一些细节理解的不到位，会导致构建出来的解题模型有一点问题。要对细节多思考，保证逻辑正确，简洁。</p>\n<h2 id=\"提示：#170，#204，#240，#286，#340\">提示：#170，#204，#240，#286，#340<a title=\"#提示：#170，#204，#240，#286，#340\" href=\"#提示：#170，#204，#240，#286，#340\"></a></h2>\n<p>  -先试试蛮力算法。<br>\n  -蛮力算法的运行时间可能为O(N)。如果试图击败那个运行时间，你认为会得到什么运行时间。什么样的算法具有该运行时间？<br>\n  -你能以O(logN)的时间复杂度来解决这个问题吗？<br>\n  -二分查找有O(logn)的运行时间。你能在这个问题中应用二分查找吗？<br>\n  -给定一个特定的索引和值，你能确定魔术索引是在它之前还是之后吗？</p>\n","prev":{"title":"问题精析：PBR材质","link":"2020/07/16/问题精析：PBR材质"},"next":{"title":"问题精析：OpenGL：VAO和VBO","link":"2020/07/15/问题精析：OpenGL：VAO和VBO"},"plink":"http://Ssssshinji.github.io/2020/07/15/问题3：魔术索引/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"复杂度分析","title":"复杂度分析","index":"4"},{"id":"题目解析","title":"题目解析","index":"5"},{"id":"标准解答","title":"标准解答","index":"6"},{"id":"标准解答（进阶）","title":"标准解答（进阶）","index":"7"},{"id":"反思","title":"反思","index":"8"},{"id":"提示：#170，#204，#240，#286，#340","title":"提示：#170，#204，#240，#286，#340","index":"9"}]}