{"title":"问题精析：柏林噪声代码实现","date":"2020-07-29T04:51:47.000Z","date_formatted":{"ll":"Jul 29, 2020","L":"07/29/2020","MM-DD":"07-29"},"link":"2020/07/29/问题精析：柏林噪声代码实现","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-29T05:05:16.557Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;类似与哈希函数，根据输入的顶点得到一个伪随机的梯度向量</span><br><span class=\"line\">    private static readonly int[] permutation &#x3D; &#123; 151,160,137,91,90,15, </span><br><span class=\"line\">        131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,</span><br><span class=\"line\">        190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,</span><br><span class=\"line\">        88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,</span><br><span class=\"line\">        77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,</span><br><span class=\"line\">        102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,</span><br><span class=\"line\">        135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,</span><br><span class=\"line\">        5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,</span><br><span class=\"line\">        223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,</span><br><span class=\"line\">        129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,</span><br><span class=\"line\">        251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,</span><br><span class=\"line\">        49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,</span><br><span class=\"line\">        138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180</span><br><span class=\"line\">    &#125;;  </span><br><span class=\"line\">    &#x2F;&#x2F;点乘</span><br><span class=\"line\">    static float Dot(Vector2 v1, Vector2 v2)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return v1.x * v2.x + v1.y * v2.y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;求梯度值(这里是求定点代表的梯度向量和距离向量的点积)</span><br><span class=\"line\">    static float Grad(Vector2 vertex, Vector2 p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        return Dot(new Vector2(permutation[(int)vertex.x], permutation[(int)vertex.y]), p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;二维柏林噪声</span><br><span class=\"line\">    static float perlinNoise(Vector2 p)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;向量两个维度向下取整,为了求出点在哪个方格</span><br><span class=\"line\">        Vector2 pi &#x3D; new Vector2((int)p.x, (int)p.y);</span><br><span class=\"line\">        &#x2F;&#x2F;计算缓和曲线，这里用的是最原始的</span><br><span class=\"line\">        Vector2 pf &#x3D; p - pi;</span><br><span class=\"line\">        Vector2 w &#x3D; pf * pf * (new Vector2(3.0f, 3.0f) - (float)2.0 * pf);</span><br><span class=\"line\">        &#x2F;&#x2F;二维晶格四个顶点</span><br><span class=\"line\">        Vector2[] vertex &#x3D; &#123; new Vector2(pi.x, pi.y), new Vector2(pi.x + 1, pi.y), new Vector2(pi.x, pi.y + 1), new Vector2(pi.x + 1, pi.y + 1) &#125;;</span><br><span class=\"line\">        &#x2F;&#x2F; Debug.Log(&quot;x_1&quot; + Mathf.Lerp(Grad(vertex[0], pf), Grad(vertex[1], pf - new Vector2(1.0f, 0.0f)), w.x));</span><br><span class=\"line\">        &#x2F;&#x2F; Debug.Log(w.x);</span><br><span class=\"line\">        &#x2F;&#x2F; Debug.Log(&quot;x_2&quot; + Mathf.Lerp(Grad(vertex[2], pf - new Vector2(0.0f, 1.0f)), Grad(vertex[1], pf - new Vector2(1.0f, 1.0f)), w.x));</span><br><span class=\"line\">        &#x2F;&#x2F; Debug.Log(w.y);</span><br><span class=\"line\">        return Mathf.Lerp(</span><br><span class=\"line\">                Mathf.Lerp(Grad(vertex[0], pf), Grad(vertex[1], pf - new Vector2(1.0f, 0.0f)), w.x),</span><br><span class=\"line\">                Mathf.Lerp(Grad(vertex[2], pf - new Vector2(0.0f, 1.0f)), Grad(vertex[1], pf - new Vector2(1.0f, 1.0f)), w.x),</span><br><span class=\"line\">                w.y);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://www.cnblogs.com/KillerAery/p/10765897.html\" target=\"_blank\">游戏开发中的噪声算法</a></p>\n","prev":{"title":"问题1：交换数字","link":"2020/07/29/问题1：交换数字"},"next":{"title":"问题6：后继者","link":"2020/07/29/问题6：后继者"},"plink":"http://Ssssshinji.github.io/2020/07/29/问题精析：柏林噪声代码实现/","toc":[{"id":"参考资料","title":"参考资料","index":"1"}]}