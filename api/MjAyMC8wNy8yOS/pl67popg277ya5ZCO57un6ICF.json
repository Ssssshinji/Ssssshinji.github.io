{"title":"问题6：后继者","date":"2020-07-29T03:48:16.000Z","date_formatted":{"ll":"Jul 29, 2020","L":"07/29/2020","MM-DD":"07-29"},"link":"2020/07/29/问题6：后继者","tags":["树与图"],"categories":["算法练习"],"updated":"2020-07-29T04:48:37.765Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  设计一个算法，找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。可以假定每个节点都含有指向父节点的连接。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  中序遍历二叉搜索树会得到一个升序排列。指定节点的下一个节点应该是右子树的最左节点，如果没有右子树，则是父节点。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;该解法有误！！！！！！未考虑当前节点是父节点的右子节点的情况</span><br><span class=\"line\">    static TreeNode FindNextNode(TreeNode node)&#123;</span><br><span class=\"line\">        TreeNode curr &#x3D; node;</span><br><span class=\"line\">        if(curr.right !&#x3D; null)&#123;</span><br><span class=\"line\">            curr &#x3D; curr.right;</span><br><span class=\"line\">            while(curr.left !&#x3D; null)&#123;</span><br><span class=\"line\">                curr &#x3D; curr.left;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            curr &#x3D; node.parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return curr;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  回想一下中序遍历，它会遍历左子树，然后是当前节点，接着是右子树。要解决这个问题，必须格外小心，想想具体是怎么回事。<br>\n  假定我们有一个假想的节点。已知访问顺序为左子树，当前节点，然后是右子树。显然，下一个节点应该位于右边。<br>\n  不过，到底是右子树的哪个节点呢？如果中序遍历右子树，那它就会是接下来第一个被访问的节点，也就是说，它应该是右子树最左边的节点。够简单的吧！<br>\n  但是，若这个节点没有右子树，又该怎么办？这种情况就有点棘手了。<br>\n  若节点n没有右子树，那就表示已遍访n的子树。我们必须回到n的父节点，记作q。<br>\n  若n在q的左边，那么，下一个我们应该访问的节点就是q（中序遍历，left -&gt; current -&gt;right）。<br>\n  若n在q的右边，则表示已遍历q的子树。我们需要从q往上访问，直至找到还未完全遍历过的节点x。怎么才能知道还未完全遍历节点x呢？之前从左节点访问至其父节点时，就已碰到了这种情况。左节点已完全遍历，但其父节点尚未完全遍历。伪代码大致如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Node InOrderSucc(Node n)&#123;</span><br><span class=\"line\">    if(n has a right subtree)&#123;</span><br><span class=\"line\">        return leftmost child of right subtree</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        while(n is a right child of n.parent)&#123;</span><br><span class=\"line\">            n &#x3D; n.parent; &#x2F;&#x2F;向上移动</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return n.parent &#x2F;&#x2F;如果父节点还未遍历</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  且慢，如果一路往上遍访这棵树都没发现左节点呢？只有当我们遇到中序遍历的最末端时，才会出现这种情况，也就是说，如果我们已位于树的最右边，那就不会再有中序后继，此时该返回null。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static TreeNode FindNextNode(TreeNode node)&#123;</span><br><span class=\"line\">    if(node &#x3D;&#x3D; null)return null;</span><br><span class=\"line\">    TreeNode curr &#x3D; node;</span><br><span class=\"line\">    if(curr.right !&#x3D; null)&#123;</span><br><span class=\"line\">        curr &#x3D; curr.right;</span><br><span class=\"line\">        while(curr.left !&#x3D; null)&#123;</span><br><span class=\"line\">            curr &#x3D; curr.left;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return curr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        curr &#x3D; node;</span><br><span class=\"line\">        TreeNode currParent &#x3D; curr.parent;</span><br><span class=\"line\">        &#x2F;&#x2F;找到curr是左子节点的节点</span><br><span class=\"line\">        while(currParent !&#x3D; null &amp;&amp; currParent.left !&#x3D; curr)&#123;</span><br><span class=\"line\">            curr &#x3D; currParent;</span><br><span class=\"line\">            currParent &#x3D; currParent.parent;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;如果是最右节点，currParent最后会是null</span><br><span class=\"line\">        return currParent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  这不是世上最复杂的算法问题，要写出完美无瑕的代码却有难度。面对这类问题，一种行之有效的做法是用伪代码勾勒大纲，仔细描绘各种不同的情况。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  情况没有考虑完全。</p>\n<h2 id=\"提示：#79，#91\">提示：#79，#91<a title=\"#提示：#79，#91\" href=\"#提示：#79，#91\"></a></h2>\n<p>  -想想中序遍历是如何工作的，并尝试对其进行“逆向工程”。<br>\n  -这只是逻辑方法中的一步：一个特定节点的后继节点是右子树的最左节点。如果没有右子树呢？</p>\n","prev":{"title":"问题精析：柏林噪声代码实现","link":"2020/07/29/问题精析：柏林噪声代码实现"},"next":{"title":"问题精析：c#：IComparable和IComparer","link":"2020/07/28/问题精析：c-：IComparable和IComparer"},"plink":"http://Ssssshinji.github.io/2020/07/29/问题6：后继者/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"反思","title":"反思","index":"6"},{"id":"提示：#79，#91","title":"提示：#79，#91","index":"7"}]}