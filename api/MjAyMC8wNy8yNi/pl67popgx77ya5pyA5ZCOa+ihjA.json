{"title":"问题1：最后k行","date":"2020-07-25T16:44:52.000Z","date_formatted":{"ll":"Jul 26, 2020","L":"07/26/2020","MM-DD":"07-26"},"link":"2020/07/26/问题1：最后k行","tags":["c和c++"],"categories":["算法练习"],"updated":"2020-07-25T17:10:02.687Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  用C++写个方法，打印输入文件的最后K行。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  对c++不是很了解，没有思路。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">太久没写我居然写不出来BFS，很难受。</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  此题的蛮力解法如下：先数出文件的行数（N），然后打印第N-K行到第N行。但是，这么做，文件要读两遍，会做无用功。我们需要一种解法，只读一遍文件就能打印最后K行。<br>\n  我们可以使用一个数组，存放从文件读取到的所有K行和最后的K行。因此，这个数组起初包含的是0至K行，然后是1至K+1行，接着是2至K+2行，以此类推。每次读取新的一行，就将数组中最早读入的那一行清掉。<br>\n  不过，你可能会问，这么做是不是还要移动数组元素，进而做大量的工作？不会，只要做法得当就不会。我们将使用循环式数组，而不必每次都移动数组元素。<br>\n  使用循环式数组（circular array），每次读取新的一行，都会替换数组中最早读入的元素。我们会以专门的变量记录这个元素，每次加入新元素，该变量就要随之更新。<br>\n  下面是循环式数组的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">步骤1（初始态）：array &#x3D; &#123;a,b,c,d,e,f&#125;. p &#x3D; 0</span><br><span class=\"line\">步骤1（初始态）：array &#x3D; &#123;g,b,c,d,e,f&#125;. p &#x3D; 1</span><br><span class=\"line\">步骤1（初始态）：array &#x3D; &#123;g,h,c,d,e,f&#125;. p &#x3D; 2</span><br><span class=\"line\">步骤1（初始态）：array &#x3D; &#123;g,h,i,d,e,f&#125;. p &#x3D; 3</span><br></pre></td></tr></table></figure>\n<p>  下面是该算法的实现代码。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">void</span> <span class=\"built_in\">print</span>:ast10Lines(<span class=\"keyword\">char</span>* fileName)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> K = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"function\">ifstream <span class=\"title\">file</span> <span class=\"params\">(fileName)</span></span>;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> L[K];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">size</span> = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//逐行读取文件，并存入循环式数组</span></span><br><span class=\"line\">    <span class=\"comment\">//行尾的EOF标志不算单独一行</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(file.<span class=\"built_in\">peek</span>() != EOF)&#123;</span><br><span class=\"line\">        getline(file,L[<span class=\"built_in\">size</span>%k]);</span><br><span class=\"line\">        <span class=\"built_in\">size</span>++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> start = <span class=\"built_in\">size</span> &gt; K ? (<span class=\"built_in\">size</span> % K) : <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count = <span class=\"built_in\">min</span>(K,<span class=\"built_in\">size</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0l</span> i &lt; count; i++)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;L[(start + i) % K] &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  这种解法要求读取整个文件，不过，任意时刻都只会在内存里存放10行内容。O(n)。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  这个方法可以记一下，没有快慢指针用的时候可以使用这种方法。</p>\n<h2 id=\"提示：#449，#459\">提示：#449，#459<a title=\"#提示：#449，#459\" href=\"#提示：#449，#459\"></a></h2>\n<p>  -如果已经有文件中的行数，我们要怎么做？<br>\n  -假设我们没有文件中的行数。有没有一种方法可以在不预先计算行数的情况下做到这件事。</p>\n","prev":{"title":"问题精析：光线追踪发展史3","link":"2020/07/26/问题精析：光线追踪发展史3"},"next":{"title":"问题精析：抗锯齿","link":"2020/07/23/问题精析：抗锯齿"},"plink":"http://Ssssshinji.github.io/2020/07/26/问题1：最后k行/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"复杂度分析","title":"复杂度分析","index":"6"},{"id":"反思","title":"反思","index":"7"},{"id":"提示：#449，#459","title":"提示：#449，#459","index":"8"}]}