{"title":"问题精析：光线追踪发展史3","date":"2020-07-25T17:19:12.000Z","date_formatted":{"ll":"Jul 26, 2020","L":"07/26/2020","MM-DD":"07-26"},"link":"2020/07/26/问题精析：光线追踪发展史3","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-25T17:45:26.000Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"whitted-raytrace\">Whitted RayTrace<a title=\"#whitted-raytrace\" href=\"#whitted-raytrace\"></a></h2>\n<h3 id=\"光线追踪基本算法\">光线追踪基本算法<a title=\"#光线追踪基本算法\" href=\"#光线追踪基本算法\"></a></h3>\n<p>  我们知道<strong>递归是光线追踪的最基本的特点</strong>，我们先来看没有递归的情况。其实<strong>没有递归的情况和RayCasting技术特点几乎是一模一样的。</strong><br>\n  将直接的shader函数用伪代码实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shader(point, ray)&#123;</span><br><span class=\"line\">    calculate surface normal vector</span><br><span class=\"line\">    use Phong illumination formula</span><br><span class=\"line\">    to calculate contributions of each light source</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  首先如之前所列的年代关系，出现Whitted光线追踪时，并没有提出我们现在做全局光照的渲染方程，所以当时依旧是使用的基于经验的光照模型，就像这里的phong。当然你也可以用其他的。<br>\n  我们来看递归的形式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shader(point, ray)&#123;</span><br><span class=\"line\">    radiance &#x3D; black;</span><br><span class=\"line\">    for each light source</span><br><span class=\"line\">        shadow_ray &#x3D; calc_shadow_ray(point,light)</span><br><span class=\"line\">        if !in_shadow(shadow_ray,light)</span><br><span class=\"line\">            radiance +&#x3D; phing_illumination(point,ray,light)</span><br><span class=\"line\">        if material is specularly reflective</span><br><span class=\"line\">            radiance +&#x3D; spec_reflectance * Trace(reflected_ray(point,ray)))</span><br><span class=\"line\">        if material is specularly transmissive</span><br><span class=\"line\">            radiance +&#x3D; spec_transmittance * Trace(refracted_ray(point,ray)))</span><br><span class=\"line\">        return radiance</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  首先进行这个点的颜色初始化，如果不在阴影中，我们phong模型的着色，如果材质拥有镜面反射，最后的颜色要加上镜面反射光线的颜色贡献，如果材质拥有折射特性，加上折射的贡献。<br>\n  当然，这里对于放射和折射的具体计算比较基础，就不表了。搞了这么多，我们先不进行其他的分析，先来看看效果上和RayCasting的区别<br>\n<img src=\"https://pic1.zhimg.com/80/v2-8e49ed5f14b179d1488880c2e5e9a23b_720w.jpg\" alt=\"递归两次\"><br>\n<img src=\"https://pic1.zhimg.com/80/v2-08bb73d113cd012a8afd7d183e32c5a6_720w.jpg\" alt=\"递归三次\"><br>\n  还有一个比较重要的问题是什么时候结束这个罪恶的递归？有两种情况。第一种情况是，光线没有打到物体上，第二种是由于每一次反射或者折射，贡献值会逐渐的降低，我们预先设定一个阈值，当它小于这个阈值的时候，我们停止。当然，如果你只按照上面的做法来渲染一个图片出来是可行的，但是会有一些需要解决的问题。</p>\n<h3 id=\"锯齿\">锯齿<a title=\"#锯齿\" href=\"#锯齿\"></a></h3>\n<p>  我们首要问的问题时，为什么会产生锯齿？由于之前的光线追踪算法对每一个像素值，都只创建了一个光线，都只采样了场景中的一个点，和那一个颜色，但是，对于一个像素而言，有可能包含了很多个不同的点，尤其是在物体边缘的情况下时，这些点不一定都有相同的颜色。而我们这种有规律的采样，就会导致这种锯齿。<br>\n  <strong>超级采样</strong>是为每个像素增加的光线数量的过程。这不能解决锯齿问题，但它会尝试减少它们对最终图像的影响。在以下示例中，从像素发出九条光线。六个是蓝色，三个是绿色。像素的最终颜色将是蓝色的三分之二和绿色的三分之一。<br>\n![(<a href=\"https://picb.zhimg.com/80/v2-7639a3642d49cfaabd5da52753b80263_720w.jpg\" target=\"_blank\" rel=\"noopener\">https://picb.zhimg.com/80/v2-7639a3642d49cfaabd5da52753b80263_720w.jpg</a>)<br>\n  <strong>自适应超级采样</strong>（也称为蒙特卡罗采样）是一种以更智能的方式进行超采样的尝试。首先发出固定数量的光线并比较它们的颜色。如果颜色相似，则程序假定像素正在查看同一个对象，并且光线的平均值被计算为该像素的颜色。如果光线颜色不同（由某个阈值定义）那么我们认为这个像素比较特殊需要进一步检查。在这种情况下，像素被细分为更小的区域，并且每个新区域被视为一个完整的像素。这个过程再次开始，同样的固定光线模式被射入每个新的部分。<br>\n  遗憾的是，自适应超级采样仍然将像素划分为规则的光线模式，并且会受到常规像素细分可能出现的混叠的影响。例如对象和采样网格机会是对齐的。总之有规律的方法都不得劲。<br>\n  <strong>Stochiastic（随机）采样</strong>将固定数量的光线发送到像素中，但确保它们是随机分布的（但或多或少均匀地覆盖该区域）。此外，stochiastic射线试图解决在凹凸不平的表面上跟随入射光线的问题。 这是分布式光线追踪中比较核心的概念，所以放在下面来说。</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://zhuanlan.zhihu.com/p/72673165\" target=\"_blank\">光线追踪</a><br>\n   2. [《Real-Time Rendering 3rd》 提炼总结]</p>\n","prev":{"title":"问题5：链表求和","link":"2020/07/26/问题5：链表求和"},"next":{"title":"问题1：最后k行","link":"2020/07/26/问题1：最后k行"},"plink":"http://Ssssshinji.github.io/2020/07/26/问题精析：光线追踪发展史3/","toc":[{"id":"whitted-raytrace","title":"Whitted RayTrace","index":"1","children":[{"id":"光线追踪基本算法","title":"光线追踪基本算法","index":"1.1"},{"id":"锯齿","title":"锯齿","index":"1.2"}]},{"id":"参考资料","title":"参考资料","index":"2"}]}