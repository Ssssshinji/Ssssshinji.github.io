{"title":"问题5：链表求和","date":"2020-07-26T14:54:44.000Z","date_formatted":{"ll":"Jul 26, 2020","L":"07/26/2020","MM-DD":"07-26"},"link":"2020/07/26/问题5：链表求和","tags":["链表"],"categories":["算法练习"],"updated":"2020-07-29T04:30:50.056Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  给定两个用链表表示的整数，每个节点包含一个数位。这些数位是<strong>反向</strong>存放的，也就是个位排在链表首部。编写函数对这两个整数求和，并用链表形式返回结果。（提示在页尾）</font><br>\n示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入：(7-&gt; 1-&gt; 6) + (5-&gt; 9-&gt; 2),即617加295</span><br><span class=\"line\">结果：2-&gt; 1-&gt; 9,即912</span><br></pre></td></tr></table></figure>\n<p><font size=4>  进阶：假设这些数位是正向存放的，请再做一遍。</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  考虑各种情况然后写个加法器出来，代码分支非常多而且丑陋。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static Node AddList(Node n1, Node n2)&#123;</span><br><span class=\"line\">    Node head &#x3D; new Node(0);</span><br><span class=\"line\">    Node curr &#x3D; head;</span><br><span class=\"line\">    &#x2F;&#x2F;进位</span><br><span class=\"line\">    int carryBit &#x3D; 0;</span><br><span class=\"line\">    while(n1 !&#x3D; null || n2 !&#x3D; null || carryBit !&#x3D; 0)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;链表1空，链表2未空</span><br><span class=\"line\">        if(n1 &#x3D;&#x3D; null &amp;&amp; n2 !&#x3D; null)&#123;</span><br><span class=\"line\">            curr.value &#x3D; n2.value + carryBit;</span><br><span class=\"line\">            n2 &#x3D; n2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;链表2空，链表1未空</span><br><span class=\"line\">        else if(n2 &#x3D;&#x3D; null &amp;&amp; n1 !&#x3D; null)&#123;</span><br><span class=\"line\">            curr.value &#x3D; n1.value + carryBit;</span><br><span class=\"line\">            n1 &#x3D; n1.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;只剩下进位，最高位相加的情况</span><br><span class=\"line\">        else if(n1 &#x3D;&#x3D; null&amp;&amp;n2 &#x3D;&#x3D; null&amp;&amp;carryBit !&#x3D; 0)&#123;</span><br><span class=\"line\">            curr.value &#x3D; carryBit;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            curr.value &#x3D; n1.value + n2.value + carryBit;</span><br><span class=\"line\">            n1 &#x3D; n1.next;</span><br><span class=\"line\">            n2 &#x3D; n2.next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(curr.value &gt;&#x3D; 10)&#123;</span><br><span class=\"line\">            curr.value &#x3D; curr.value%10;</span><br><span class=\"line\">            carryBit &#x3D; 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            carryBit &#x3D; 0;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;防止最后会多个curr.next，显示出一个0</span><br><span class=\"line\">        if(n1 &#x3D;&#x3D; null&amp;&amp;n2 &#x3D;&#x3D; null&amp;&amp;carryBit &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">            break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curr.next &#x3D; new Node(0);</span><br><span class=\"line\">        curr &#x3D; curr.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return head;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  可以用递归法模拟这个过程，将两个节点的值逐一相加，如有进位则转入下一个节点。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static Node AddList(Node n1, Node n2, int carryBit)&#123;</span><br><span class=\"line\">    if(n1 &#x3D;&#x3D; null &amp;&amp; n2 &#x3D;&#x3D; null &amp; carryBit &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node result &#x3D; new Node(0);</span><br><span class=\"line\">    int value &#x3D; carryBit;</span><br><span class=\"line\">    if(n1 !&#x3D; null)&#123;</span><br><span class=\"line\">        value +&#x3D; n1.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(n2 !&#x3D; null)&#123;</span><br><span class=\"line\">        value +&#x3D; n2.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    result.value &#x3D; value % 10;</span><br><span class=\"line\">    &#x2F;&#x2F;递归</span><br><span class=\"line\">    if(n1 !&#x3D; null || n2 !&#x3D; null)&#123;</span><br><span class=\"line\">        Node more &#x3D; AddList(n1 &#x3D;&#x3D; null ? null : n1.next,n2 &#x3D;&#x3D; null ? null : n2.next, value &gt;&#x3D; 10 ? 1 : 0);</span><br><span class=\"line\">        result.next &#x3D; more;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  O(n)。</p>\n<h2 id=\"进阶\">进阶<a title=\"#进阶\" href=\"#进阶\"></a></h2>\n<p>  从概念上来说，第二部分并无不同（递归，进位处理），但在实现时稍微复杂一些。<br>\n  1.一个链表的节点可能比另一个链表的少，我们无法直接处理这种情况。例如，假设要对(1-&gt; 2-&gt; 3-&gt; 4)与(5-&gt; 6-&gt; 7)求和。务必注意，5应该与2而不是1配对。对此，我们可以一开始先比较两个链表的长度并用0填充较短的链表。<br>\n  2.在前一个问题中，相加的结果不断追加到链表尾部（也即向前传递）。这就意味着递归调用会传入进位，而且会返回结果（随后追加至链表尾部）。不过，这里的结果要加到首部（也即向后传递）。跟前一个问题一样，递归调用必须返回结果和进位。实现也不是太难，但处理起来会更难一些，可以通过创建一个Partial Sum包裹类来解决这一点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class PartialSum &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;初始为null可以让末尾不会多出一位</span><br><span class=\"line\">    public Node sum &#x3D; null;</span><br><span class=\"line\">    public int carry &#x3D; 0;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static Node AddLists(Node n1, Node n2)&#123;</span><br><span class=\"line\">    int len1 &#x3D; Length(n1);</span><br><span class=\"line\">    int len2 &#x3D; Length(n2);</span><br><span class=\"line\">    &#x2F;&#x2F;将较短的表填充0</span><br><span class=\"line\">    if(len1&lt;len2)&#123;</span><br><span class=\"line\">        n1 &#x3D; PadList(n1, len2 - len1);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        n2 &#x3D; PadList(n2, len1 - len2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;链表相加</span><br><span class=\"line\">    PartialSum sum &#x3D; AddListsHelper(n1,n2);</span><br><span class=\"line\">    &#x2F;&#x2F;如果有进位，插入到链表首部，否则返回链表</span><br><span class=\"line\">    if(sum.carry &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">        return sum.sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else&#123;</span><br><span class=\"line\">        Node result &#x3D; InsertBefore(sum.sum,sum.carry);</span><br><span class=\"line\">        return result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static PartialSum AddListsHelper(Node n1, Node n2)&#123;</span><br><span class=\"line\">    if(n1 &#x3D;&#x3D; null &amp;&amp; n2 &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">        PartialSum sum1 &#x3D; new PartialSum();</span><br><span class=\"line\">        return sum1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;递归对较小的数位相加</span><br><span class=\"line\">    PartialSum sum &#x3D; AddListsHelper(n1.next,n2.next);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;进位相加</span><br><span class=\"line\">    int val &#x3D; sum.carry + n1.value + n2.value;</span><br><span class=\"line\">    &#x2F;&#x2F;加入当前数位的和</span><br><span class=\"line\">    Node full_result &#x3D; InsertBefore(sum.sum, val % 10);</span><br><span class=\"line\">    &#x2F;&#x2F;返回当前和进位</span><br><span class=\"line\">    sum.sum &#x3D; full_result;</span><br><span class=\"line\">    sum.carry &#x3D; val&#x2F;10;</span><br><span class=\"line\">    return sum;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;链表填充0</span><br><span class=\"line\">static Node PadList(Node n, int padding)&#123;</span><br><span class=\"line\">    Node head &#x3D; n;</span><br><span class=\"line\">    for(int i  &#x3D; 0; i &lt; padding; i++)&#123;</span><br><span class=\"line\">        head &#x3D; InsertBefore(head,0);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static Node InsertBefore(Node node, int data)&#123;</span><br><span class=\"line\">    Node n &#x3D; new Node(data);</span><br><span class=\"line\">    if(node !&#x3D; null)&#123;</span><br><span class=\"line\">        n.next &#x3D; node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return n;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static int Length(Node n)&#123;</span><br><span class=\"line\">    int count  &#x3D; 0;</span><br><span class=\"line\">    while(n !&#x3D; null)&#123;</span><br><span class=\"line\">        count +&#x3D; 1;</span><br><span class=\"line\">        n &#x3D; n.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  太强了。</p>\n<h2 id=\"提示：#7，#30，#71，#95，#109\">提示：#7，#30，#71，#95，#109<a title=\"#提示：#7，#30，#71，#95，#109\" href=\"#提示：#7，#30，#71，#95，#109\"></a></h2>\n<p>  -当然，你可以将链表转换为整数，计算总和，然后将其转换回新的链表。如果你在面试中这样做，面试官可能会接受答案，然后看看你在不能将其转换为数字然后返回的情况下，还能否做到这一点。<br>\n  -尝试递归。假设你有两个链表，A=1-&gt; 5-&gt; 9（代表951）和B=2-&gt; 3-&gt;6-&gt; 7（代表7632），以及一个操作链表其余部分的函数（5-&gt; 9和3-&gt; 6-&gt;7）。你能用这个来创建求和方法吗？sum(1-&gt; 5-&gt; 9, 2-&gt; 3-&gt; 6-&gt; 7)和sum(5-&gt; 9, 3-&gt; 6-&gt; 7)之间有何关系？<br>\n  -确保你考虑到了链表的长度不同的情况。<br>\n  -你的算法在形如9-&gt; 7-&gt; 8和6-&gt; 8-&gt; 5的链表上工作吗？仔细检查一下。<br>\n  -对于后续问题：问题是，当链表的长度不一样时，一个链表的首部可能代表1000的位置，而另一个链表代表10的位置。如果你把它们做的一样长呢？有没有方法修改链表来做到这一点，而不改变它所代表的值？</p>\n","prev":{"title":"问题精析：柏林噪声原理","link":"2020/07/27/问题精析：柏林噪声原理"},"next":{"title":"问题精析：光线追踪发展史3","link":"2020/07/26/问题精析：光线追踪发展史3"},"plink":"http://Ssssshinji.github.io/2020/07/26/问题5：链表求和/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"复杂度分析","title":"复杂度分析","index":"6"},{"id":"进阶","title":"进阶","index":"7"},{"id":"反思","title":"反思","index":"8"},{"id":"提示：#7，#30，#71，#95，#109","title":"提示：#7，#30，#71，#95，#109","index":"9"}]}