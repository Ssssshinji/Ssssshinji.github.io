{"title":"问题精析：Blooming","date":"2020-07-19T12:40:25.000Z","date_formatted":{"ll":"Jul 19, 2020","L":"07/19/2020","MM-DD":"07-19"},"link":"2020/07/19/问题精析：Blooming","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-22T18:27:41.164Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"意义\">意义<a title=\"#意义\" href=\"#意义\"></a></h2>\n<p>  这个问题的提出简单来说是为了解决这样的问题：例如有一张在阳光下的白纸，白纸在监视器上显示出是出白色，而前方的太阳也是纯白色的，所以基本上白纸和太阳就是一样的了，给太阳加一个光晕，这样太阳看起来似乎就比白纸更亮了！<br>\n<img src=\"https://learnopengl-cn.github.io/img/05/07/bloom_example.png\" alt=\"\"></p>\n<h2 id=\"重点概念\">重点概念<a title=\"#重点概念\" href=\"#重点概念\"></a></h2>\n<p>  Bloom和HDR结合使用效果很好。常见的一个误解是HDR和泛光是一样的，很多人认为两种技术是可以互换的。但是它们是两种不同的技术，用于各自不同的目的上。可以使用默认的8位精确度的帧缓冲，也可以在不使用泛光效果的时候，使用HDR。只不过在有了HDR之后再实现泛光就更简单了。</p>\n<h2 id=\"步骤\">步骤<a title=\"#步骤\" href=\"#步骤\"></a></h2>\n<p>  1.对物体进行普通着色，并使用MRT（Multiple Render Targets，多渲染目标）渲染到一个帧缓冲内的两个颜色缓冲中。我们先正常计算光照，将其传递给第一个像素着色器的输出变量FragColor。然后我们使用当前储存在FragColor的东西来决定它的亮度是否超过了一定阈限。我们通过恰当地将其转为灰度的方式计算一个fragment的亮度，如果它超过了一定阈限，我们就把颜色输出到第二个颜色缓冲，那里保存着所有亮部，暂称BrightColor。<br>\n  2.还需要创建一个帧缓冲（也需要右两个颜色缓冲），使用两步高斯模糊来对BrightColor进行处理。<br>\n  3.将FragColor和处理过的BrightColor进行合并。<br>\n  各步骤关键代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;第一步片元着色器</span><br><span class=\"line\">&#x2F;&#x2F;基本光照，然后写入到两个缓冲</span><br><span class=\"line\">#version 330 core</span><br><span class=\"line\">layout (location &#x3D; 0) out vec4 FragColor;</span><br><span class=\"line\">layout (location &#x3D; 1) out vec4 BrightColor;</span><br><span class=\"line\"></span><br><span class=\"line\">in VS_OUT &#123;</span><br><span class=\"line\">    vec3 FragPos;</span><br><span class=\"line\">    vec3 Normal;</span><br><span class=\"line\">    vec2 TexCoords;</span><br><span class=\"line\">&#125; fs_in;</span><br><span class=\"line\"></span><br><span class=\"line\">struct Light &#123;</span><br><span class=\"line\">    vec3 Position;</span><br><span class=\"line\">    vec3 Color;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">uniform Light lights[4];</span><br><span class=\"line\">uniform sampler2D diffuseTexture;</span><br><span class=\"line\">uniform vec3 viewPos;</span><br><span class=\"line\"></span><br><span class=\"line\">void main()</span><br><span class=\"line\">&#123;           </span><br><span class=\"line\">    vec3 color &#x3D; texture(diffuseTexture, fs_in.TexCoords).rgb;</span><br><span class=\"line\">    vec3 normal &#x3D; normalize(fs_in.Normal);</span><br><span class=\"line\">    &#x2F;&#x2F; ambient</span><br><span class=\"line\">    vec3 ambient &#x3D; 0.0 * color;</span><br><span class=\"line\">    &#x2F;&#x2F; lighting</span><br><span class=\"line\">    vec3 lighting &#x3D; vec3(0.0);</span><br><span class=\"line\">    vec3 viewDir &#x3D; normalize(viewPos - fs_in.FragPos);</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; 4; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; diffuse</span><br><span class=\"line\">        vec3 lightDir &#x3D; normalize(lights[i].Position - fs_in.FragPos);</span><br><span class=\"line\">        float diff &#x3D; max(dot(lightDir, normal), 0.0);</span><br><span class=\"line\">        vec3 result &#x3D; lights[i].Color * diff * color;      </span><br><span class=\"line\">        &#x2F;&#x2F; attenuation (use quadratic as we have gamma correction)</span><br><span class=\"line\">        float distance &#x3D; length(fs_in.FragPos - lights[i].Position);</span><br><span class=\"line\">        result *&#x3D; 1.0 &#x2F; (distance * distance);</span><br><span class=\"line\">        lighting +&#x3D; result;</span><br><span class=\"line\">                </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    vec3 result &#x3D; ambient + lighting;</span><br><span class=\"line\">    &#x2F;&#x2F; check whether result is higher than some threshold, if so, output as bloom threshold color</span><br><span class=\"line\">    float brightness &#x3D; dot(result, vec3(0.2126, 0.7152, 0.0722));</span><br><span class=\"line\">    if(brightness &gt; 1.0)</span><br><span class=\"line\">        BrightColor &#x3D; vec4(result, 1.0);</span><br><span class=\"line\">    else</span><br><span class=\"line\">        BrightColor &#x3D; vec4(0.0, 0.0, 0.0, 1.0);</span><br><span class=\"line\">    FragColor &#x3D; vec4(result, 1.0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;第二步片元着色器</span><br><span class=\"line\">#version 330 core</span><br><span class=\"line\">out vec4 FragColor;</span><br><span class=\"line\"></span><br><span class=\"line\">in vec2 TexCoords;</span><br><span class=\"line\"></span><br><span class=\"line\">uniform sampler2D image;</span><br><span class=\"line\"></span><br><span class=\"line\">uniform bool horizontal;</span><br><span class=\"line\">uniform float weight[5] &#x3D; float[] (0.2270270270, 0.1945945946, 0.1216216216, 0.0540540541, 0.0162162162);</span><br><span class=\"line\"></span><br><span class=\"line\">void main()</span><br><span class=\"line\">&#123;             </span><br><span class=\"line\">     vec2 tex_offset &#x3D; 1.0 &#x2F; textureSize(image, 0); &#x2F;&#x2F; gets size of single texel</span><br><span class=\"line\">     vec3 result &#x3D; texture(image, TexCoords).rgb * weight[0];</span><br><span class=\"line\">     if(horizontal)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         for(int i &#x3D; 1; i &lt; 5; ++i)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">            result +&#x3D; texture(image, TexCoords + vec2(tex_offset.x * i, 0.0)).rgb * weight[i];</span><br><span class=\"line\">            result +&#x3D; texture(image, TexCoords - vec2(tex_offset.x * i, 0.0)).rgb * weight[i];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     else</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         for(int i &#x3D; 1; i &lt; 5; ++i)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             result +&#x3D; texture(image, TexCoords + vec2(0.0, tex_offset.y * i)).rgb * weight[i];</span><br><span class=\"line\">             result +&#x3D; texture(image, TexCoords - vec2(0.0, tex_offset.y * i)).rgb * weight[i];</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     FragColor &#x3D; vec4(result, 1.0);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;第二步逻辑处理</span><br><span class=\"line\">第一次传入BrightColor，之后纵横交替进行模糊处理</span><br><span class=\"line\">    bool horizontal &#x3D; true, first_iteration &#x3D; true;</span><br><span class=\"line\">    unsigned int amount &#x3D; 10;</span><br><span class=\"line\">    shaderBlur.Use();</span><br><span class=\"line\">    for (unsigned int i &#x3D; 0; i &lt; amount; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        glBindFramebuffer(GL_FRAMEBUFFER, pingpongFBO[horizontal]);</span><br><span class=\"line\">        shaderBlur.SetInt(&quot;horizontal&quot;, horizontal);</span><br><span class=\"line\">        glBindTexture(GL_TEXTURE_2D, first_iteration ? colorBuffers[1] : pingpongColorbuffers[!horizontal]);  &#x2F;&#x2F; bind texture of other framebuffer (or scene if first iteration)</span><br><span class=\"line\">        renderQuad();</span><br><span class=\"line\">        horizontal &#x3D; !horizontal;</span><br><span class=\"line\">        if (first_iteration)</span><br><span class=\"line\">            first_iteration &#x3D; false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    glBindFramebuffer(GL_FRAMEBUFFER, 0);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;第三步片元着色器</span><br><span class=\"line\">#version 330 core</span><br><span class=\"line\">out vec4 FragColor;</span><br><span class=\"line\"></span><br><span class=\"line\">in vec2 TexCoords;</span><br><span class=\"line\"></span><br><span class=\"line\">uniform sampler2D scene;</span><br><span class=\"line\">uniform sampler2D bloomBlur;</span><br><span class=\"line\">uniform bool bloom;</span><br><span class=\"line\">uniform float exposure;</span><br><span class=\"line\"></span><br><span class=\"line\">void main()</span><br><span class=\"line\">&#123;             </span><br><span class=\"line\">    const float gamma &#x3D; 2.2;</span><br><span class=\"line\">    vec3 hdrColor &#x3D; texture(scene, TexCoords).rgb;      </span><br><span class=\"line\">    vec3 bloomColor &#x3D; texture(bloomBlur, TexCoords).rgb;</span><br><span class=\"line\">    if(bloom)</span><br><span class=\"line\">        hdrColor +&#x3D; bloomColor; &#x2F;&#x2F; additive blending</span><br><span class=\"line\">    &#x2F;&#x2F; tone mapping 这里是之前提到过的粗暴派，仅利用exp曲线</span><br><span class=\"line\">    vec3 result &#x3D; vec3(1.0) - exp(-hdrColor * exposure);</span><br><span class=\"line\">    &#x2F;&#x2F; also gamma correct while we&#39;re at it       </span><br><span class=\"line\">    result &#x3D; pow(result, vec3(1.0 &#x2F; gamma));</span><br><span class=\"line\">    FragColor &#x3D; vec4(result, 1.0);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<h1 id=\"  -1.-泛光\">   1. <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/07%20Bloom/\" target=\"_blank\" rel=\"noopener\">泛光</a><a title=\"#  -1.-泛光\" href=\"#  -1.-泛光\"></a></h1>\n","prev":{"title":"问题7：旋转矩阵","link":"2020/07/21/问题7：旋转矩阵"},"next":{"title":"问题精析：HDR和ToneMapping","link":"2020/07/19/问题精析：HDR和ToneMapping"},"plink":"http://Ssssshinji.github.io/2020/07/19/问题精析：Blooming/","toc":[{"id":"意义","title":"意义","index":"1"},{"id":"重点概念","title":"重点概念","index":"2"},{"id":"步骤","title":"步骤","index":"3"},{"id":"参考资料","title":"参考资料","index":"4"}]}