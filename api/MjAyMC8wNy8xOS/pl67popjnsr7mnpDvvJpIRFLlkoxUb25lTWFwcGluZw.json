{"title":"问题精析：HDR和ToneMapping","date":"2020-07-19T09:09:11.000Z","date_formatted":{"ll":"Jul 19, 2020","L":"07/19/2020","MM-DD":"07-19"},"link":"2020/07/19/问题精析：HDR和ToneMapping","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-19T10:18:35.868Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"hdr背景及概念\">HDR背景及概念<a title=\"#hdr背景及概念\" href=\"#hdr背景及概念\"></a></h2>\n<p>  一般来说，当存储在帧缓冲(Framebuffer)中时，亮度和颜色的值是默认被限制在0.0到1.0之间的。这个看起来无辜的语句使我们一直将亮度与颜色的值设置在这个范围内，尝试着与场景契合。这样是能够运行的，也能给出还不错的效果。但是如果我们遇上了一个特定的区域，其中有多个亮光源使这些数值总和超过了1.0，又会发生什么呢？答案是这些片段中超过1.0的亮度或者颜色值会被约束在1.0，从而导致场景混成一片，难以分辨：<br>\n<img src=\"https://learnopengl-cn.github.io/img/05/06/hdr_clamped.png\" alt=\"\"><br>\n  这是由于大量片段的颜色值都非常接近1.0，在很大一个区域内每一个亮的片段都有相同的白色。这损失了很多的细节，使场景看起来非常假。<br>\n  解决这个问题的一个方案是减小光源的强度从而保证场景内没有一个片段亮于1.0。然而这并不是一个好的方案，因为你需要使用不切实际的光照参数。一个更好的方案是让颜色暂时超过1.0，然后将其转换至0.0到1.0的区间内，从而防止损失细节。<br>\n  显示器被限制为只能显示值为0.0到1.0间的颜色，但是在光照方程中却没有这个限制。通过使片段的颜色超过1.0，我们有了一个更大的颜色范围，这也被称作HDR(High Dynamic Range, 高动态范围)。有了HDR，亮的东西可以变得非常亮，暗的东西可以变得非常暗，而且充满细节。<br>\n  HDR原本只是被运用在摄影上，摄影师对同一个场景采取不同曝光拍多张照片，捕捉大范围的色彩值。这些图片被合成为HDR图片，从而综合不同的曝光等级使得大范围的细节可见。看下面这个例子，左边这张图片在被光照亮的区域充满细节，但是在黑暗的区域就什么都看不见了；但是右边这张图的高曝光却可以让之前看不出来的黑暗区域显现出来。<br>\n<img src=\"https://learnopengl-cn.github.io/img/05/06/hdr_image.png\" alt=\"\"><br>\n  这与我们眼睛工作的原理非常相似，也是HDR渲染的基础。当光线很弱的啥时候，人眼会自动调整从而使过暗和过亮的部分变得更清晰，就像人眼有一个能自动根据场景亮度调整的自动曝光滑块。<br>\n  HDR渲染和其很相似，我们允许用更大范围的颜色值渲染从而获取大范围的黑暗与明亮的场景细节，最后将所有HDR值转换成在[0.0, 1.0]范围的LDR(Low Dynamic Range,低动态范围)。转换HDR值到LDR值得过程叫做色调映射(Tone Mapping)，现在现存有很多的色调映射算法，这些算法致力于在转换过程中保留尽可能多的HDR细节。这些色调映射算法经常会包含一个选择性倾向黑暗或者明亮区域的参数。<br>\n  在实时渲染中，HDR不仅允许我们超过LDR的范围[0.0, 1.0]与保留更多的细节，同时还让我们能够根据光源的真实强度指定它的强度。比如太阳有比闪光灯之类的东西更高的强度，那么我们为什么不这样子设置呢?(比如说设置一个10.0的漫亮度) 这允许我们用更现实的光照参数恰当地配置一个场景的光照，而这在LDR渲染中是不能实现的，因为他们会被上限约束在1.0。<br>\n  因为显示器只能显示在0.0到1.0范围之内的颜色，我们肯定要做一些转换从而使得当前的HDR颜色值符合显示器的范围。简单地取平均值重新转换这些颜色值并不能很好的解决这个问题，因为明亮的地方会显得更加显著。我们能做的是用一个不同的方程与/或曲线来转换这些HDR值到LDR值，从而给我们对于场景的亮度完全掌控，这就是之前说的色调变换，也是HDR渲染的最终步骤。</p>\n<h2 id=\"浮点帧缓冲\">浮点帧缓冲<a title=\"#浮点帧缓冲\" href=\"#浮点帧缓冲\"></a></h2>\n<p>  当一个帧缓冲的颜色缓冲的内部格式被设定成了GL_RGB16F, GL_RGBA16F, GL_RGB32F 或者GL_RGBA32F时，这些帧缓冲被叫做浮点帧缓冲(Floating Point Framebuffer)，浮点帧缓冲可以存储超过0.0到1.0范围的浮点值，所以非常适合HDR渲染。<br>\n  想要创建一个浮点帧缓冲，我们只需要改变颜色缓冲的内部格式参数就行了（注意GL_FLOAT参数)：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glBindTexture(GL_TEXTURE_2D, colorBuffer);</span><br><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGB, GL_FLOAT, NULL);</span><br></pre></td></tr></table></figure>\n<p>  默认的帧缓冲默认一个颜色分量只占用8位(bits)。当使用一个使用32位每颜色分量的浮点帧缓冲时(使用GL_RGB32F 或者GL_RGBA32F)，我们需要四倍的内存来存储这些颜色。所以除非你需要一个非常高的精确度，32位不是必须的，使用GLRGB16F就足够了。<br>\n  当光的强度值大于1.0时，一大块区域都是白色的。因为默认的帧缓冲中，所有片段着色器的输出值被约束在0.0到1.0间，超过1.0的地方损失了所有细节。因为我们直接转换HDR值到LDR值，这就像我们根本就没有应用HDR一样。为了修复这个问题我们需要做的是无损转化所有浮点颜色值回0.0-1.0范围中。我们需要应用到色调映射。<br>\n<img src=\"https://learnopengl-cn.github.io/img/05/06/hdr_direct.png\" alt=\"\"></p>\n<h2 id=\"色调映射(tone-mapping)\">色调映射(Tone Mapping)<a title=\"#色调映射(tone-mapping)\" href=\"#色调映射(tone-mapping)\"></a></h2>\n<p>  色调映射(Tone Mapping)是一个损失很小的转换浮点颜色值至我们所需的LDR[0.0, 1.0]范围内的过程，通常会伴有特定的风格的色平衡(Stylistic Color Balance)。</p>\n<h3 id=\"经验派\">经验派<a title=\"#经验派\" href=\"#经验派\"></a></h3>\n<p>  Reinhard tone mapping,伪代码如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float3 ReinhardToneMapping(float3 color, float adapted_lum) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    const float MIDDLE_GREY &#x3D; 1;</span><br><span class=\"line\">    color *&#x3D; MIDDLE_GREY &#x2F; adapted_lum;</span><br><span class=\"line\">    return color &#x2F; (1.0f + color);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  这种tone mapping的方法更多地来自于经验，没什么原理在后面。所以就姑且称它为经验派吧。它的优点是简单直接，把亮的变暗，暗的变量。这样暗处和亮处细节就都出来了。但缺点也很明显，就是灰暗。个个颜色都朝着灰色的方向被压缩了，画面像蒙了一层纱。</p>\n<h3 id=\"粗暴派\">粗暴派<a title=\"#粗暴派\" href=\"#粗暴派\"></a></h3>\n<p>  到了2007年，孤岛危机（Crysis）的CryEngine 2，为了克服Reinhard灰暗的缺点，开始用了另一个tone mapping的方法。前面提到了tone mapping就是个S曲线，那么既然你要S曲线，我就搞出一个S曲线。这个方法更简单，只要一行，而且没有magic number。用一个exp来模拟S曲线。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float3 CEToneMapping(float3 color, float adapted_lum) </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    return 1 - exp(-adapted_lum * color);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  CE的方法在于快速，并且视觉效果比Reinhard。但是这个方法纯粹就是凑一个函数，没人知道应该如何改进。属于粗暴地合成。</p>\n<h3 id=\"拟合派\">拟合派<a title=\"#拟合派\" href=\"#拟合派\"></a></h3>\n<p>  到了2010年，Uncharted 2公开了它的tone mapping方法，称为Filmic tone mapping。当年我也写过一篇博客讲KlayGE切换到Filmic tone mapping的事情。这个方法的本质是把原图和让艺术家用专业照相软件模拟胶片的感觉，人肉tone mapping后的结果去做曲线拟合，得到一个高次曲线的表达式。这样的表达式应用到渲染结果后，就能在很大程度上自动接近人工调整的结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float3 F(float3 x)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconst float A &#x3D; 0.22f;</span><br><span class=\"line\">\tconst float B &#x3D; 0.30f;</span><br><span class=\"line\">\tconst float C &#x3D; 0.10f;</span><br><span class=\"line\">\tconst float D &#x3D; 0.20f;</span><br><span class=\"line\">\tconst float E &#x3D; 0.01f;</span><br><span class=\"line\">\tconst float F &#x3D; 0.30f;</span><br><span class=\"line\"> </span><br><span class=\"line\">\treturn ((x * (A * x + C * B) + D * E) &#x2F; (x * (A * x + B) + D * F)) - E &#x2F; F;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">float3 Uncharted2ToneMapping(float3 color, float adapted_lum)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconst float WHITE &#x3D; 11.2f;</span><br><span class=\"line\">\treturn F(1.6f * adapted_lum * color) &#x2F; F(WHITE);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  那些ABCDEF都是多项式的系数，而WHITE是个magic number，表示白色的位置。这个方法开启了tone mapping的新路径，让人们知道了曲线拟合的好处。并且，其他颜色空间的变换，比如gamma矫正，也可以一起合并到这个曲线里来，一次搞定，不会增加额外开销。缺点就是运算量有点大，两个多项式的计算，并且相除。因为Filmic tone mapping的优异表现，大部分游戏都切换到了这个方法。包括CE自己，也在某个时候完成了切换。</p>\n<h3 id=\"最强派\">最强派<a title=\"#最强派\" href=\"#最强派\"></a></h3>\n<p>  在大家以为Filmic tone mapping会统治很长时间的时候，江湖中来了一位异域高手。他认为，你们这帮搞游戏/实时图形的，都是渣渣。让我们电影业来教你们什么叫tone mapping。这位高手叫美国电影艺术与科学学会，就是颁布奥斯卡奖的那个机构。不要以为他们只是个评奖的单位，美国电影艺术与科学学会的第一宗旨就是提高电影艺术与科学的质量。<br>\n  他们发明的东西叫Academy Color Encoding System（ACES），是一套颜色编码系统，或者说是一个新的颜色空间。它是一个通用的数据交换格式，一方面可以不同的输入设备转成ACES，另一方面可以把ACES在不同的显示设备上正确显示。不管你是LDR，还是HDR，都可以在ACES里表达出来。这就直接解决了VDR的问题，不同设备间都可以互通数据。<br>\n  然而对于实时渲染来说，没必要用全套ACES。因为第一，没有什么“输入设备”。渲染出来的HDR图像就是个线性的数据，所以直接就在ACES空间中。而输出的时候需要一次tone mapping，转到LDR或另一个HDR。也就是说，我们只要ACES里的非常小的一条路径，而不是纷繁复杂的整套体系。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float3 ACESToneMapping(float3 color, float adapted_lum)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tconst float A &#x3D; 2.51f;</span><br><span class=\"line\">\tconst float B &#x3D; 0.03f;</span><br><span class=\"line\">\tconst float C &#x3D; 2.43f;</span><br><span class=\"line\">\tconst float D &#x3D; 0.59f;</span><br><span class=\"line\">\tconst float E &#x3D; 0.14f;</span><br><span class=\"line\"></span><br><span class=\"line\">\tcolor *&#x3D; adapted_lum;</span><br><span class=\"line\">\treturn (color * (A * color + B)) &#x2F; (color * (C * color + D) + E);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  看着很像Uncharted 2的做法吧，都是多项式拟合。但是式子比Uncharted的简单，并不需要算两个多项式并相除，只要算一个，一次搞定。它的曲线是这样的。S感很浓，并且比Uncharted的更向小的方向移，即便很小的数值和接近1的数值也有梯度。这样能很好地保留暗处和亮处的细节。<br>\n<img src=\"https://pic1.zhimg.com/80/0149709ceeb67532d4202a1a450f3584_720w.png\" alt=\"\"><br>\n  更好的地方是，按照前面说的，ACES为的是解决所有设备之间的颜色空间转换问题。所以这个tone mapper不但可以用于HDR到LDR的转换，还可以用于从一个HDR转到另一个HDR。也就是从根本上解决了VDR的问题。这个函数的输出是线性空间的，所以要接到LDR的设备，只要做一次sRGB校正。要接到HDR10的设备，只要做一次Rec 2020颜色矩阵乘法。Tone mapping部分是通用的，这也是比之前几个算法都好的地方。</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/06%20HDR/\" target=\"_blank\">HDR</a><br>\n   2. <a href=\"https://zhuanlan.zhihu.com/p/21983679\" target=\"_blank\">Tone mapping进化论</a></p>\n","prev":{"title":"问题精析：Blooming","link":"2020/07/19/问题精析：Blooming"},"next":{"title":"问题6：字符串压缩","link":"2020/07/18/问题6：字符串压缩"},"plink":"http://Ssssshinji.github.io/2020/07/19/问题精析：HDR和ToneMapping/","toc":[{"id":"hdr背景及概念","title":"HDR背景及概念","index":"1"},{"id":"浮点帧缓冲","title":"浮点帧缓冲","index":"2"},{"id":"色调映射(tone-mapping)","title":"色调映射(Tone Mapping)","index":"3","children":[{"id":"经验派","title":"经验派","index":"3.1"},{"id":"粗暴派","title":"粗暴派","index":"3.2"},{"id":"拟合派","title":"拟合派","index":"3.3"},{"id":"最强派","title":"最强派","index":"3.4"}]},{"id":"参考资料","title":"参考资料","index":"4"}]}