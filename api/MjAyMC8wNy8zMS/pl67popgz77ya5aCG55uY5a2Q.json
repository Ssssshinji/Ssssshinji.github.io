{"title":"问题3：堆盘子","date":"2020-07-31T03:54:56.000Z","date_formatted":{"ll":"Jul 31, 2020","L":"07/31/2020","MM-DD":"07-31"},"link":"2020/07/31/问题3：堆盘子","tags":["栈与队列"],"categories":["算法练习"],"updated":"2020-07-31T05:36:20.508Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  设想有一堆盘子，堆太高可能会倒下来。因此，在现实生活中，盘子堆到一定高度时，我们就会另外堆一堆盘子。请实现数据结构SetOfStacks，模拟这种行为。SetOfStacks应该由多个栈组成，并且在前一个栈填满时新建一个栈。此外，SetOfStacks.push()和SetOfStacks.pop()应该与普通栈的操作方法相同（也就是说，pop()返回的值，应该跟只有一个栈时的情况一样）。进阶：实现一个popAt(int index)方法，根据指定的子栈，执行pop操作。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  怎么管理几个栈，怎么样得到每个栈的栈头。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SetOfStacks&lt;T&gt;&#123;</span><br><span class=\"line\">    List&lt;Stack&lt;T&gt;&gt; stacks &#x3D; new List&lt;Stack&lt;T&gt;&gt;();</span><br><span class=\"line\">    public int capacity &#x3D; 10;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T Pop()&#123;</span><br><span class=\"line\">        Stack&lt;T&gt; last &#x3D; GetLastStack();</span><br><span class=\"line\">        if(last &#x3D;&#x3D; null) throw new Exception();</span><br><span class=\"line\">        T v &#x3D; last.Pop();</span><br><span class=\"line\">        if(last.Count &#x3D;&#x3D; 0)stacks.Remove(stacks[stacks.Count -1]);</span><br><span class=\"line\">        return v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void Push(T v)&#123;</span><br><span class=\"line\">        Stack&lt;T&gt; last &#x3D; GetLastStack();</span><br><span class=\"line\">        if(last !&#x3D; null &amp;&amp; last.Count !&#x3D; capacity)&#123;</span><br><span class=\"line\">            last.Push(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;&#x2F;&#x2F;必须创建新栈</span><br><span class=\"line\">            Stack&lt;T&gt; stack &#x3D; new Stack&lt;T&gt;(capacity);</span><br><span class=\"line\">            stack.Push(v);</span><br><span class=\"line\">            stacks.Add(stack);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Stack&lt;T&gt; GetLastStack()&#123;</span><br><span class=\"line\">        return stacks[stacks.Count - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  push()的行为必须跟单一栈的一样，这就意味着push()要对栈数组的最后一个栈调用push()。不过，这里处理起来必须格外小心：若最后一个栈被填满，就需新建一个栈。实现代码大致如下。<br>\n  那么，pop()该怎么做？其操作类似于push()，也就是说，应该操作最后一个栈。若最后一个栈为空（执行出栈操作后），就必须从栈数组中移除这个栈。</p>\n<h2 id=\"进阶：实现popat(int-index)\">进阶：实现popAt(int index)<a title=\"#进阶：实现popat(int-index)\" href=\"#进阶：实现popat(int-index)\"></a></h2>\n<p>  这个实现起来有点棘手，不过，我们可以设想一个“推入”动作。从栈1弹出元素时，我们需要移出栈2的栈底元素，并将其推到栈1中。随后，将栈3的栈底元素推入栈2，将栈4的栈底元素推入栈3，以此类推。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class SetOfStacks&lt;T&gt;&#123;</span><br><span class=\"line\">    List&lt;Stack&lt;T&gt;&gt; stacks &#x3D; new List&lt;Stack&lt;T&gt;&gt;();</span><br><span class=\"line\">    public int capacity &#x3D; 10;</span><br><span class=\"line\">    public SetOfStacks(int capacity)&#123;</span><br><span class=\"line\">        this.capacity &#x3D; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public T Pop()&#123;</span><br><span class=\"line\">        Stack&lt;T&gt; last &#x3D; GetLastStack();</span><br><span class=\"line\">        if(last &#x3D;&#x3D; null) throw new Exception();</span><br><span class=\"line\">        T v &#x3D; last.Pop();</span><br><span class=\"line\">        if(last.size &#x3D;&#x3D; 0)stacks.Remove(stacks[stacks.Count -1]);</span><br><span class=\"line\">        return v;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void Push(T v)&#123;</span><br><span class=\"line\">        Stack&lt;T&gt; last &#x3D; GetLastStack();</span><br><span class=\"line\">        if(last !&#x3D; null &amp;&amp; last.size !&#x3D; capacity)&#123;</span><br><span class=\"line\">            last.Push(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;&#x2F;&#x2F;必须创建新栈</span><br><span class=\"line\">            Stack&lt;T&gt; stack &#x3D; new Stack&lt;T&gt;(capacity);</span><br><span class=\"line\">            stack.Push(v);</span><br><span class=\"line\">            stacks.Add(stack);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public Stack&lt;T&gt; GetLastStack()&#123;</span><br><span class=\"line\">        if(stacks.Count &#x3D;&#x3D; 0)&#123;return null;&#125;</span><br><span class=\"line\">        return stacks[stacks.Count - 1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public bool IsEmpty()&#123;</span><br><span class=\"line\">        Stack&lt;T&gt; last &#x3D; GetLastStack();</span><br><span class=\"line\">        return last &#x3D;&#x3D; null || last.size &#x3D;&#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T PopAt(int index)&#123;</span><br><span class=\"line\">        return LeftShift(index,true);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T LeftShift(int index, bool removeTop)&#123;</span><br><span class=\"line\">        Stack&lt;T&gt; stack &#x3D; stacks[index];</span><br><span class=\"line\">        T removedItem;</span><br><span class=\"line\">        if(removeTop) removedItem &#x3D; stack.Pop();</span><br><span class=\"line\">        else removedItem &#x3D; stack.RemoveBottom();</span><br><span class=\"line\">        if(stack.size &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">            stacks.Remove(stacks[index]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;将之后的栈中底部的数分别移动到前一个栈的栈顶，保证前面的栈栈满</span><br><span class=\"line\">        else if(stacks.Count &gt; index + 1)&#123;</span><br><span class=\"line\">            T v &#x3D; LeftShift(index + 1, false); </span><br><span class=\"line\">            stack.Push(v);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return removedItem;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">public class Stack&lt;T&gt;&#123;</span><br><span class=\"line\">    private int capacity;</span><br><span class=\"line\">    public Node&lt;T&gt; top,bottom;</span><br><span class=\"line\">    public int size &#x3D; 0;</span><br><span class=\"line\">    public Stack(int capacity)&#123;</span><br><span class=\"line\">        this.capacity &#x3D; capacity;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public bool isFull()&#123;</span><br><span class=\"line\">        return capacity &#x3D;&#x3D; size;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public void join(Node&lt;T&gt; above, Node&lt;T&gt; below)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;要用到双向链表</span><br><span class=\"line\">        if(below !&#x3D; null)below.above &#x3D; above;</span><br><span class=\"line\">        if(above !&#x3D; null)above.below &#x3D; below;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public bool Push(T v)&#123;</span><br><span class=\"line\">        if(size &gt;&#x3D; capacity) return false;</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">        Node&lt;T&gt; n &#x3D; new Node&lt;T&gt;(v);</span><br><span class=\"line\">        if(size &#x3D;&#x3D; 1) bottom &#x3D; n;</span><br><span class=\"line\">        join(n,top);</span><br><span class=\"line\">        top &#x3D; n;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T Pop()&#123;</span><br><span class=\"line\">        Node&lt;T&gt; t &#x3D; top;</span><br><span class=\"line\">        top &#x3D; top.below;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        return t.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public bool IsEmpty()&#123;</span><br><span class=\"line\">        return size &#x3D;&#x3D; 0;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    public T RemoveBottom()&#123;</span><br><span class=\"line\">        Node&lt;T&gt; b &#x3D; bottom;</span><br><span class=\"line\">        bottom &#x3D; bottom.above;</span><br><span class=\"line\">        if(bottom !&#x3D; null)bottom.below &#x3D; null;</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        return b.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  你可能会指出，何必执行“推入”操作，有些栈不填满也挺好的。而且，这还会改善时间复杂度（元素很多时尤其明显），但是，若之后有人假定所有的栈（最后一个栈除外）都是填满的，就可能会让我们陷于束手无策的境地。这个问题并没有“标准答案”，你应该跟面试官讨论各种做法的优劣。<br>\n  从概念上来看，这个问题解决起来并不难，但要完整实现需要编写大量代码。面试官一般不会要求你写出全部代码。<br>\n  解决这类问题有个很好的策略，就是尽量将代码分离出来，写成独立的方法，比如popAt可以调用的leftShift。这样一来，你的代码就会更加清晰，而你在处理细节之前，也有机会先铺设好代码的骨架。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  先根据所需要的操作，在方法中列出API的名称，根据API来考虑如何实现。</p>\n<h2 id=\"提示：#64，#81\">提示：#64，#81<a title=\"#提示：#64，#81\" href=\"#提示：#64，#81\"></a></h2>\n<p>  -你需要追踪每个子栈的大小。当一个栈已满时，你可能需要创建一个新栈。<br>\n  -在一个特定的子栈中弹出一个元素意味着一些栈没有满。这是个问题吗？没有正确的答案，但你应该考虑如何处理这个问题。</p>\n","prev":{"title":"问题4：幂集","link":"2020/07/31/问题4：幂集"},"next":{"title":"问题精析：骨骼层级及坐标空间变换","link":"2020/07/31/问题精析：骨骼层级及坐标空间变换"},"plink":"http://Ssssshinji.github.io/2020/07/31/问题3：堆盘子/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"题目解析","title":"题目解析","index":"3"},{"id":"进阶：实现popat(int-index)","title":"进阶：实现popAt(int index)","index":"4"},{"id":"反思","title":"反思","index":"5"},{"id":"提示：#64，#81","title":"提示：#64，#81","index":"6"}]}