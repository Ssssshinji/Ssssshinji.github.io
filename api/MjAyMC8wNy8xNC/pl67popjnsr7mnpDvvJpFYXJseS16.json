{"title":"问题精析：Early-z","date":"2020-07-14T15:13:36.000Z","date_formatted":{"ll":"Jul 14, 2020","L":"07/14/2020","MM-DD":"07-14"},"link":"2020/07/14/问题精析：Early-z","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-30T06:16:37.758Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"为什么会有early-z\">为什么会有Early-z<a title=\"#为什么会有early-z\" href=\"#为什么会有early-z\"></a></h2>\n<p>  传统的渲染管线在之前有过详细介绍，一系列的测试实在执行过片元着色器之后才进行的，也就是说就算我们指定了一些测试条件来剔除掉一部分像素，但是这些像素还是经过了计算的，便产生了Over Draw，因为这部分计算也就显得没有必要。<br>\n  Early-z便由此产生，在光栅化阶段的片元着色器计算前，先利用深度测试丢弃那些不会显示出来的像素。</p>\n<h2 id=\"实现early-z\">实现Early-z<a title=\"#实现early-z\" href=\"#实现early-z\"></a></h2>\n<p>  Early-z是一种硬件特性，每个厂商在实现时也会有所不同。需要一些方法，我们才能利用这种特性。</p>\n<blockquote>\n<p>  This sample demonstrates two ways to take advantage of early Z rejection. When rendering, if the hardware detects that after performing vertex shading a fragment will fail the depth test, it can avoid the cost of executing the pixel shader and reject the fragment. To best take advantage of this feature, it is necessary to maximize the number of fragments that can be rejected because of depth testing. This sample demonstrates two ways of doing this:front to back rendering and z pre-pass.</p>\n</blockquote>\n<p>  简单的说，一种是通过从前向后渲染，一种是通过z pre-pass。</p>\n<h3 id=\"从前向后渲染\">从前向后渲染<a title=\"#从前向后渲染\" href=\"#从前向后渲染\"></a></h3>\n<p>  我们知道在编写shaderlab的时候会为我们的shader指定渲染队列，这个渲染队列其实就是unity帮我们实现从前向后渲染功能的工具（根据渲染队列进行渲染，unity使用了正数索引代表渲染队列，索引号越小越早被渲染）。不透明物体，我们最好使用从前向后渲染，这样可以使用early-z功能，减少绘制的像素。而透明物体不可以使用这种early-z的方式，因为透明物体盖住的物体还是需要被渲染出来的，所以unity中不透明物体是从后往前渲染的，而且<strong>透明物体需要在不透明物体渲染完之后再进行渲染</strong>。所以unity已经帮我们实现了这种early-z的功能，我们只需要合理控制物体的渲染队列，就可以实现优化了。<br>\n  很容易理解，从前到后渲染，能保证无用的像素都在进入片元着色器前通过Early-z丢弃。</p>\n<h3 id=\"z-pre-pass\">z-pre pass<a title=\"#z-pre-pass\" href=\"#z-pre-pass\"></a></h3>\n<blockquote>\n<p>  For Z pre-pass, all opaque geometry is rendered in two passes. The first pass populates the Z buffer with depth values from all opaque geometry. A null pixel shader is used and the color buffer is not updated. For this first pass, only simple vertex shading is performed so unnecessary constant buffer updates and vertex-layout data should be avoided. For the second pass, the geometry is resubmitted with Z writes disabled but Z testing on and full vertex and pixel shading is performed. The graphics hardware takes advantage of Early-Z to avoid performing pixel shading on geometry that is not visible.<br>\n  文章中有提到第一个pass中只进行了简单的顶点着色，要避免不必要的常量缓冲区更新和顶点布局数据。也就是说这个渲染管线也与第一篇文章所描述的相同。early-z是在顶点着色器与片元着色器之间操作的。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pass &#123;</span><br><span class=\"line\">    ZWrite On</span><br><span class=\"line\">    ColorMask 0</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"early-z失效\">Early-z失效<a title=\"#early-z失效\" href=\"#early-z失效\"></a></h2>\n<p>  1.片元着色器里里修改了深度值，显然。<br>\n  2.打开了alpha test(或fragment shader里discard了fragment)，原因和blending和depth test的关系是类似的，early-z可能会更新之后被alpha test discard掉的fragment。</p>\n<h2 id=\"总结\">总结<a title=\"#总结\" href=\"#总结\"></a></h2>\n<p>  1.Early Z由硬件实现，随着硬件的演进，它的功能也在不断进化，处理的情况也变多。<br>\n  2.Alpha Test或者Depth modify都会使用early z失效，但是后面渲染的批次还可以继续使用early z（Hierachical Z）优化。<br>\n  3.渲染API可以通过设置earlydepthstencil<a href=\"d3d\">vii</a>或者layout(early_fragment_tests) in;（opengl）来强制使用early z。<br>\n  我们知道现在不透明物体开启了深度写入与深度测试后，会进行early-Z判断，但是这个时候还是需要应用层把相关的顶点数据传递给GPU，以进行深度测试。所以在FrameDebugger中，我们可以看到就算前面有一个很大的不透明物体，把后面的不透明物体都挡住了，但是后面的物体还是会占用drawcall，这个drawcall就是应用层把信息传递给GPU的数据。所以深度测试其实无法对CPU瓶颈进行优化，只是可以让没有通过深度测试的物体，不进行片元着色器的计算，从而减少计算量，降低GPU瓶颈。</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"http://www.someabcd.com/jscode/3454487357.html\" target=\"_blank\">alpha test, blending, early-z, later-z之间的次序关系</a><br>\n   2. <a href=\"https://zhuanlan.zhihu.com/p/53092784\" target=\"_blank\">深入剖析GPU Early Z优化</a><br>\n   2. <a href=\"https://www.jianshu.com/p/837c70c98644\" target=\"_blank\">[unity]神秘的Early-Z到底是个啥？</a></p>\n","prev":{"title":"问题精析：OpenGL：VAO和VBO","link":"2020/07/15/问题精析：OpenGL：VAO和VBO"},"next":{"title":"问题精析：PBR:基本原理及推导","link":"2020/07/12/问题精析：PBR-基本原理及推导"},"plink":"http://Ssssshinji.github.io/2020/07/14/问题精析：Early-z/","toc":[{"id":"为什么会有early-z","title":"为什么会有Early-z","index":"1"},{"id":"实现early-z","title":"实现Early-z","index":"2","children":[{"id":"从前向后渲染","title":"从前向后渲染","index":"2.1"},{"id":"z-pre-pass","title":"z-pre pass","index":"2.2"}]},{"id":"early-z失效","title":"Early-z失效","index":"3"},{"id":"总结","title":"总结","index":"4"},{"id":"参考资料","title":"参考资料","index":"5"}]}