[{"title":"问题1：判定字符是否唯一","date":"2020-06-25T07:36:02.000Z","date_formatted":{"ll":"Jun 25, 2020","L":"06/25/2020","MM-DD":"06-25"},"updated":"2020-06-25T09:16:33.958Z","content":"题目描述\n  实现一个算法，确定一个字符串的所有字符是否不全都不同。假使不允许使用额外的数据结构，又该如何处理？（提示在页尾）\n个人思路\n  如果可用其他的数据结构，创建一个list，逐个将字符加入到list中。在加入前调用List.Contains()查询是否已经有该字符，有则报错。如果不可用别的数据结构，按照ASCII码排序，再看是否有相邻字符相等，或者拿每一个和剩下的字符比较。\n个人解答（使用数据结构）\n1234567891011121314151617Boolean isUnique(string str)&#123;    ArrayList list &#x3D; new ArrayList();    for (int i &#x3D; 0; i &lt; str.Length; i++)    &#123;        if (!list.Contains(str[i]))        &#123;            list.Add(str[i]);        &#125;        else        &#123;            return false;        &#125;    &#125;    return true;&#125;\n题目解析\n  -要关注字符串是ASCII串还是Unicode串，这关系到你需要使用的数组大小（在标准解答中，按照ASCII处理）\n  -如果字符串长度超过了字母表中不同字符的个数(ASCII:128)，直接返回false\n标准解答（使用数据结构）\n1234567891011121314Boolean isUnique(string str)&#123;    if(str.Length &gt; 128)return false;    bool[] char_set &#x3D; new bool[128];    for(int i &#x3D; 0; i &lt; str.Length; i++)&#123;        int val &#x3D; str[i];        &#x2F;&#x2F;在字符串中已找到过        if(char_set[val])&#123;            return false;        &#125;        char_set[val] &#x3D; true;    &#125;    return true;&#125;\n复杂度分析\n  这段代码的时间复杂度为O(n)，其中n为字符串长度。空间复杂度为O(1)。你也可以认为时间复杂度是O(1)，因为for循环的迭代永远不会超过128次。如果不想假设字符集是恒定的，也可以认为空间复杂度是O(c )，时间复杂度是O(min(c,n))或者O(c )，其中c是字符集的大小。\n不使用数据结构的情况\n  思路和自己的思路相同，无代码解析。\n反思\n  没有注意到字符数量是有限的，从而利用数组解决问题。类似的使用数组的方式还有很多，需要注意。\n提示\n  -用散列表试试\n  -位向量有用吗\n  -你能用O(NlogN)的时间复杂度解决它吗\n","plink":"http://Ssssshinji.github.io/2020/06/25/问题1：判定字符是否唯一/"},{"title":"算法常见面试题1-5","date":"2020-06-24T13:14:39.000Z","date_formatted":{"ll":"Jun 24, 2020","L":"06/24/2020","MM-DD":"06-24"},"updated":"2020-06-25T07:42:03.548Z","content":"\n1.算法的几个特征是什么？\n  1.有穷性 (Finiteness) 指算法必须在执行有限个步骤之后终止。\n  2.确切性 (Definiteness) 算法的每一步骤必须有确切的定义。\n  3.输入项 (Input) 一个算法有0个或者多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。\n  4.输出项 (Output) 一个算法有一个或者多个输出，以反映对输入数据加工后的结果。没有输出的算法毫无意义。\n  5.可行性 (Effectiveness) 算法中执行的任何计算步骤都可以被分解为基本的可执行操作，即每个计算步骤都可以在有限时间内完成，也称之为有效性。\n2.算法复杂性的定义。大O、θ、Ω、小o分别表示的含义是什么？\n  算法复杂度分为空间复杂度S(n)和时间复杂度T(n)。\n  空间复杂度指在运行过程中为局部变量分配的存储空间的大小，它包括参数列表中的形参变量和函数体中定义的局部变量两个部分，记作S(n) = O(f(n))。时间复杂度定性描述了该算法的运行时间，记作T(n) = O(f(n))。\n  如果算法A需要的时间与f(n)成正比，则称算法A为f(n)阶，记为O(f(n))。函数f(n)称为算法的增率函数(growth-rate function)。该表示法使用大学字母O(Order)来表示，故称为大O表示法。若规模为n的问题需要的时间与n成正比，则问题表示为O(n),即n阶。若需要的时间与\\(n^2\\)成正比，则问题表示为O(\\(n^2\\)),以此类推。**O并不是一个函数。**他的属性有：\n  1.可忽略算法增率函数的低阶项\n  2.可忽略算法增率函数中高阶项的倍输常量\n  3.O(f(n)) + O(g(n))=O(f(n)+g(n))可组合增率函数\n  形式化定义：\n  给定2个正值函数f和g，定义：f(n) = O(g(n)),条件为：存在正实数c和N，使得对于所有的n\\(\\ge\\)N,有|f(n)|\\(\\le\\)|cg(n)|。上述的定义表明，当n足够大，大过一个特定的N时，且存在一个正数c，使得|f(n)|不大于|cg(n)|,则f是g的O表示。关系可以解释为g(n)是f(n)的一个上界，也可以理解为f增长的速度最多和g一样快，而不会超过g。\n\n\n名称\n表示法\n定义\n\n\n\n\nTilde\nf(n)~g(n)\n$$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 1$$\n\n\nBig Oh\nf(n) is O(g(n))\n$$\\exists c \\gt 0, n_0 \\ge 0$$such that \\( 0 \\le f(n) \\le c \\cdot g(n)\\) for all \\(n \\ge n_0\\)\n\n\nBig Omega\nf(n) is \\(\\Omega\\)(g(n))\ng(n) is O(f(n))\n\n\nBig Theta\nf(n) is \\(\\Theta\\)(g(n))\nf(n) is both O(g(n)) and \\(\\Omega\\)(g(n))\n\n\nLittle oh\nf(n) is o(g(n))\n$$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0$$\n\n\nLittle omega\nf(n) is \\(\\omega\\)(g(n))\ng(n) is o(f(n))\n\n\n3.递归算法的定义，及其两要素。\n  递归就是循环定义，对于一个方法来说，就是自己调用自己。\n  两要素：\n  -终止条件\n  -递推公式\n  经典汉诺塔问题(c#实现)\n1234567891011121314151617181920212223using System;namespace Hanoi_Tower&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            int n &#x3D; Int32.Parse(Console.ReadLine());            Hanoi(n,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);        &#125;        private static void Hanoi(int n, string a,string b, string c)&#123;            if(n &#x3D;&#x3D; 1)Move(a,c);            else &#123;                Hanoi(n-1, a, c, b);                Move(a,c);                Hanoi(n-1, b, a, c);            &#125;        &#125;        private static void Move(string origin, string des)&#123;            Console.WriteLine(origin+ &quot;---&gt;&quot; + des);        &#125;    &#125;&#125;\n4.分治算法的思想，经典的分治算法(全排列、二分搜索、归并排序、快速排序、线性时间选择、最接近点对问题)。\n","plink":"http://Ssssshinji.github.io/2020/06/24/算法常见面试题1-5/"},{"title":"图片测试","date":"2020-06-20T11:53:43.000Z","date_formatted":{"ll":"Jun 20, 2020","L":"06/20/2020","MM-DD":"06-20"},"updated":"2020-06-24T10:50:10.571Z","content":"\n","plink":"http://Ssssshinji.github.io/2020/06/20/image/"},{"title":"幸运星 第一话（外链视频测试）","date":"2020-06-20T09:32:57.000Z","date_formatted":{"ll":"Jun 20, 2020","L":"06/20/2020","MM-DD":"06-20"},"updated":"2020-06-24T12:33:37.079Z","content":"\n \n\n","plink":"http://Ssssshinji.github.io/2020/06/20/video/"}]