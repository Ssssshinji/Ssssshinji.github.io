[{"title":"问题1：节点间通路","date":"2020-06-27T07:39:32.000Z","date_formatted":{"ll":"Jun 27, 2020","L":"06/27/2020","MM-DD":"06-27"},"updated":"2020-06-27T09:01:47.972Z","content":"题目描述\n  给定有向图，设计一个算法，找出两个节点之间是否存在一条路径（提示在页尾）\n个人思路\n  题目含义很明确，就是让手写DFS和BFS。而对于寻找路径来说，BFS是更好的选择。\n个人解答\n1太久没写我居然写不出来BFS，很难受。\n题目解析\n  -无解析\n标准解答（BFS）\n12345678910111213141516171819202122232425static bool Search(Graph g,Vertex start, Vertex end)&#123;            if(start &#x3D;&#x3D; end)return true;            foreach(Vertex v in g.GetVertexs())&#123;                v.state &#x3D; State.Unvisited;            &#125;            Queue&lt;Vertex&gt; q &#x3D; new Queue&lt;Vertex&gt;();            start.State &#x3D; State.Visiting;            q.Enqueue(start);            while(q.Count !&#x3D; 0)&#123;                Node u &#x3D; q.Dequeue();                if(u !&#x3D; null)&#123;                    foreach(Vertex v in u.GetAdjacent())&#123;                        if(v.state &#x3D;&#x3D; State.Unvisited)&#123;                            if(v &#x3D;&#x3D; end)return true;                            else&#123;                                v.state &#x3D; State.Visiting;                                q.Enqueue(v);                            &#125;                        &#125;                    &#125;                    u.state &#x3D; State.Visted;                &#125;            &#125;            return false;        &#125;\n复杂度分析\n  如果是单链表实现的队列，其入队时间复杂度为O(n),出队为O(1)。这段代码的时间复杂度为O(n)。双链表则为O(1)。\n反思\n  基础知识不扎实，越是耳熟能详的算法越要自己亲手实现过才算是真正掌握了。\n提示\n  -有两个众所周知的算法可以做到这一点，其利弊是什么？\n","plink":"http://Ssssshinji.github.io/2020/06/27/问题1：节点间通路/"},{"title":"求职岗位调研（渲染相关）","date":"2020-06-26T14:47:36.000Z","date_formatted":{"ll":"Jun 26, 2020","L":"06/26/2020","MM-DD":"06-26"},"updated":"2020-06-26T16:59:18.975Z","content":"字节跳动相关职位\n渲染引擎研发工程师-抖音/抖音火山版/直播\n职位描述\n  1.参与开发面向移动端的特效引擎项目；\n  2.参与特效引擎的核心模块开发；\n  3.支持特效业务的实现和落地；\n  4.支持特效工具链的建设。\n职业要求\n  1.图像处理或图形学相关专业或主修过相关课程，2021届获得本科及以上学历；\n  2.熟练掌握C++，熟悉C11标准相关特性；\n  3.熟悉图形开发相关技术（OPENGL，DirectX，METAL，VULCAN）和GPU架构优先；\n  4.有商业引擎的实践经验优先，如：Unity，UE，CryEngine, GamePlay3D等；\n  5.对技术有极大的热情，学习能力强，责任心强，工作认真细致，具备良好的服务意识，具有良好的团队沟通与协作能力。\n\n游戏引擎开发工程师\n职位描述\n  1.参与引擎和游戏基础组件和工具的研发；\n  2.帮助项目组解决引擎，组件和工具问题；\n  3.帮助项目组研究解决方案，优化性能问题。\n职业要求\n  1.大学本科及以上学历，计算机软件专业或数学专业优先，2021年毕业；\n  2.至少熟练掌握一⻔计算机语言；\n  3.计算机基础素养优秀，熟悉语言，数据结构，操作系统，计算机网络等；\n  4.熟悉Unity或Unreal引擎，熟悉计算机图形学，熟悉Shader开发；\n  5.有较强的学习能力，能够熟练阅读英文技术文档，具有较强的分析与解决问题能力；\n  6.熟悉OpenGL、DirectX、Metal或Vulkan等技术的优先；\n  7.熟悉移动端开发经验者优先；\n\n游戏技术美术-游戏业务\n职位描述\n  1.成为国内一流游戏研发团队的一员，和国内顶级的研发团队一起工作，完成挑战；\n  2.研究业界领先的渲染,物理，动画等技术，与美术大牛一起推动各种新技术在项目中应用落地；\n  3.探索游戏行业先进的技术和工具，完善项目的内容制作流程与内容生产管线，不断完善游戏的开发效率和品质体验；\n  4.针对各个软硬件平台进行游戏性能和表现的极致优化；\n  5.提取项目中的最佳实践，推动优秀技术方案的普及和广泛应用。\n职业要求\n  1.大学本科及以上学历，2021年毕业；\n  2.熟悉shader，能制作符合美术需求的shader，有shader性能优化经验；\n  3.有良好的审美和逻辑思维能力，具备独立解决美术向技术问题的能力；\n  4.积极主动，能承受一定的工作压力，对游戏开发充满热情。\n以下是加分项\n  5.热爱：热爱游戏，体验过大量且多种类型游戏，对游戏制作拥有极大热情；\n  6.技术：熟悉一款主流美术软件3dMax、Maya、Zbrush、Substance Painter等，熟悉Unity、Unreal等主流商业引擎；\n  7.奖项：在GameJam比赛中斩获过奖项；\n  8.积累：有自己的技术博客、开源项目者，有过海外留学经历者，或有游戏公司实习经验。\n\n完美世界相关职位\n游戏技术美术工程师\n职位描述\n  1.负责引擎相关工具的开发与维护；\n  2.根据美术需求编写相关shader；\n  3.对美术工作中遇到的问题提供技术支持；\n  4.制定美术资源制作规范；\n  5.优化效率，了解相关性能分析工具。\n岗位要求\n  1.热爱生活、热爱游戏，对玩游戏和做游戏充满激情，并渴望做出成功的游戏；\n  2.熟练掌握C#语言，了解或者熟悉MaxScript、JavaScript、Python；\n  3.熟悉计算机图形渲染管线和基础知识；能根据需求独立编写shader；\n  4.了解3D美术相关工具，包括：3DMax、Substance Painter、Photoshop等；\n  5.熟悉Unity3D相关知识，有实际开发经验者优先考虑。\n\n引擎开发程师\n职位描述\n  1.负责3D游戏引擎和工具的开发；\n  2.对渲染关技术进行前瞻性研究；\n  3.负责引擎的改进和维护工作。\n岗位要求\n  1.熟练掌握C++知识与多线程技术 ；\n  2.熟练掌握3D数学、渲染相关算法与数据结构 ；\n  3.掌握D3D或OpenGL渲染管线流程 ；\n  4.掌握图形API和Shader语言（D3D hlsl 或 OpenGL glsl）；\n  5.有性能优先的开发思路，懂得基本的代码优化技巧；\n  6.独立思考和分析能力，面对复杂问题能够快速找到答案 ；\n  7. 熟练的沟通与表达能力，有团队合作精神 。\n\n巨人网络\n游戏引擎开发工程师\n职位描述\n  1.负责3D引擎的相关开发，如场景管理，人物动画，特效，SHADER，动作融合，粒子等;\n  2.负责游戏美术相关插件编写；\n  3.负责引擎相关工具开发，优化3D引擎的性能。\n岗位要求\n  1.计算机基础知识扎实，有一定的编程经验；\n  2.熟悉C++、STL及各种设计模式,熟悉各种数据结构和算法；\n  3.熟悉3D图形学原理,熟悉3d图形的常用技术,有较强的数学功底；\n  4.熟悉HLSL,Shader编写；\n  5.具备良好的逻辑思维、综合分析能力，以及团队协作能力。有主动学习的能力和意愿，对技术研究有热情;\n  6.硕士及以上学历，计算机或相关专业。\n\nIGG\n高级技术美术\n职位描述\n  1.和美术人员、引擎程序员一起设计渲染方案，负责Shader编写，实现优秀的美术效果\n  2.充分全面了解美术流程各环节的需求和问题，及时高质量地提供开发工具，技术指导和解决方案；\n  3.制定美术资源规范，监督项目人员规范执行；\n  4.对游戏性能进行Profiling，设计优化方案；\n岗位要求\n  1.熟悉计算机图形学，包括图形管线及图形API，着色器语言，有渲染器设计经验者加分；\n  2.熟练精通Unity游戏引擎，有Unreal或其他商业游戏引擎经验者加分；\n  3.熟悉编程和脚本语言：Maxscript, Mel, Python至少一项，C#/C++至少一项，有美术软件工具集或引擎开发经验者加分；\n  4.熟悉常用美术工具，如Max/Maya，Photoshop，Substance，ZBrush等，并具备较好的审美能力和美术功底；\n  5.熟悉常用的PC及移动端Profiling工具，GPA，Renderdoc，Nsight，SnapdragonProfiler等；\n  6.良好的沟通交流能力，工作积极主动，能承受一定的工作压力，有英文交流能力者加分；\n  7.8+年游戏开发经验，5+年技术美术相关经验，具备次世代游戏项目开发经验者加分。\n分析及总结\n  渲染相关的工作大致分为两种，第一个方向是研发引擎类，该类除了图形学的技术，还重视个人的编程能力和计算机基础知识（尤其是数据结构）的扎实程度。作为应对，刷题是一个很好的选择。另一个方向是技美，该类稍微放宽了计算机基础知识及编程能力的门槛，但相对的，需要对shader有更好的掌握，并且至少熟悉一种商业3D软件，同时对美术素养也有一定要求。平时自己制作shader和捏人对这方面是个不错的锻炼。\n  可以选择的有各个游戏公司（技美），视频处理相关的公司（渲染引擎研发），想研发自己渲染/游戏引擎的公司。总的来说，就职范围不广，市场需求较少，且要求较高。感觉基本是凉了\n  1.\n  2.\n  3.\n  4.对游戏性能进行Profiling，设计优化方案；\n  5.\n  6.\n  7.\n","plink":"http://Ssssshinji.github.io/2020/06/26/求职岗位调研（渲染相关）/"},{"title":"问题1：移除重复节点","date":"2020-06-26T13:27:58.000Z","date_formatted":{"ll":"Jun 26, 2020","L":"06/26/2020","MM-DD":"06-26"},"updated":"2020-06-27T07:43:33.887Z","content":"题目描述\n  编写代码，移除未排序链表中的重复节点。进阶：如果不得使用临时缓冲区，该怎么解决？（提示在页尾）\n个人思路\n  新建一个字典(dictionary)，依次把每个节点的value当作键添加到字典中，字典的值随便取。每次碰到新节点时先调用CintainsKey(key)方法，因为字典中键的唯一性，返回true时说明该节点重复。不使用缓冲区不会做。\n个人解答\n123456789101112void deleteDups(LinkedListNode node)&#123;    Dictionary&lt;key,value&gt; dic &#x3D; new Dictionary&lt;key,value&gt;();    LinkedListNode previous &#x3D; null;    while(node !&#x3D; null)&#123;        if(dic.ContainsKey(node.value))&#123;            previous.Next &#x3D; node.next;        &#125; else &#123;            dic.Add(node.value);            previous &#x3D; node;        &#125;    node.next;    &#125;\n题目解析\n  -要想移除链表中的重复节点，需要设法记录有哪些是重复的。这里只要用到一个简单的散列表。\n标准解答\n12345678910111213void deleteDups(LinkedListNode node)&#123;    HashSet&lt;item&gt; set &#x3D; new HashSet&lt;item&gt;();    LinkedListNode previous &#x3D; null;    while(node !&#x3D; null)&#123;        if(set.Contains(node.value))&#123;            previous.Next &#x3D; node.next;        &#125; else &#123;            set.Add(node.value);            previous &#x3D; node;        &#125;    node.next;    &#125; &#125;\n复杂度分析\n  这段代码的时间复杂度为O(n),n为链表节点数目。\n不使用临时缓冲区的情况\n  如果不使用额外的缓冲区，可以使用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的节点时候重复。\n标准解答（不使用临时缓冲区）\n1234567891011121314void deleteDups(LinkedListNode head)&#123;    LinkedListNode current &#x3D; head;    while(current !&#x3D; null)&#123;        LinkedListNode runner &#x3D; current;        while(runner.next !&#x3D; null)&#123;            if(current.value &#x3D;&#x3D; runner.next.value)&#123;                runner.next &#x3D; runner.next.next;            &#125;            else&#123;                runner &#x3D; runner.next;            &#125;        &#125;        current &#x3D; current.next;    &#125;\n复杂度分析\n  这段代码的空间复杂度为O(1)，但时间复杂度为O(N^2)。\n反思\n  第一问基本思路相同，刚好复习一下dictionary和hashSet的区别。对于不使用缓冲区的情况，老想着怎么样轻易解决，却忘了大部分算法都是先用最简单的方式得出结果再慢慢优化的，忽略了双指针循环。\n提示\n  -你有没有试过一个散列表？你应该可以通过一次链表遍历做到这一点。\n  -没有额外的空间，你需要O(N^2)的时间。尝试使用两个指针，其中第二个指针在第一个指针之前搜索。\n","plink":"http://Ssssshinji.github.io/2020/06/26/问题1：移除重复节点/"},{"title":"问题1：判定字符是否唯一","date":"2020-06-25T07:36:02.000Z","date_formatted":{"ll":"Jun 25, 2020","L":"06/25/2020","MM-DD":"06-25"},"updated":"2020-06-25T09:16:33.958Z","content":"题目描述\n  实现一个算法，确定一个字符串的所有字符是否不全都不同。假使不允许使用额外的数据结构，又该如何处理？（提示在页尾）\n个人思路\n  如果可用其他的数据结构，创建一个list，逐个将字符加入到list中。在加入前调用List.Contains()查询是否已经有该字符，有则报错。如果不可用别的数据结构，按照ASCII码排序，再看是否有相邻字符相等，或者拿每一个和剩下的字符比较。\n个人解答（使用数据结构）\n1234567891011121314151617Boolean isUnique(string str)&#123;    ArrayList list &#x3D; new ArrayList();    for (int i &#x3D; 0; i &lt; str.Length; i++)    &#123;        if (!list.Contains(str[i]))        &#123;            list.Add(str[i]);        &#125;        else        &#123;            return false;        &#125;    &#125;    return true;&#125;\n题目解析\n  -要关注字符串是ASCII串还是Unicode串，这关系到你需要使用的数组大小（在标准解答中，按照ASCII处理）\n  -如果字符串长度超过了字母表中不同字符的个数(ASCII:128)，直接返回false\n标准解答（使用数据结构）\n1234567891011121314Boolean isUnique(string str)&#123;    if(str.Length &gt; 128)return false;    bool[] char_set &#x3D; new bool[128];    for(int i &#x3D; 0; i &lt; str.Length; i++)&#123;        int val &#x3D; str[i];        &#x2F;&#x2F;在字符串中已找到过        if(char_set[val])&#123;            return false;        &#125;        char_set[val] &#x3D; true;    &#125;    return true;&#125;\n复杂度分析\n  这段代码的时间复杂度为O(n)，其中n为字符串长度。空间复杂度为O(1)。你也可以认为时间复杂度是O(1)，因为for循环的迭代永远不会超过128次。如果不想假设字符集是恒定的，也可以认为空间复杂度是O(c )，时间复杂度是O(min(c,n))或者O(c )，其中c是字符集的大小。\n不使用数据结构的情况\n  思路和自己的思路相同，无代码解析。\n反思\n  没有注意到字符数量是有限的，从而利用数组解决问题。类似的使用数组的方式还有很多，需要注意。\n提示\n  -用散列表试试\n  -位向量有用吗\n  -你能用O(NlogN)的时间复杂度解决它吗\n","plink":"http://Ssssshinji.github.io/2020/06/25/问题1：判定字符是否唯一/"},{"title":"算法常见面试题1-5","date":"2020-06-24T13:14:39.000Z","date_formatted":{"ll":"Jun 24, 2020","L":"06/24/2020","MM-DD":"06-24"},"updated":"2020-06-25T07:42:03.548Z","content":"\n1.算法的几个特征是什么？\n  1.有穷性 (Finiteness) 指算法必须在执行有限个步骤之后终止。\n  2.确切性 (Definiteness) 算法的每一步骤必须有确切的定义。\n  3.输入项 (Input) 一个算法有0个或者多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。\n  4.输出项 (Output) 一个算法有一个或者多个输出，以反映对输入数据加工后的结果。没有输出的算法毫无意义。\n  5.可行性 (Effectiveness) 算法中执行的任何计算步骤都可以被分解为基本的可执行操作，即每个计算步骤都可以在有限时间内完成，也称之为有效性。\n2.算法复杂性的定义。大O、θ、Ω、小o分别表示的含义是什么？\n  算法复杂度分为空间复杂度S(n)和时间复杂度T(n)。\n  空间复杂度指在运行过程中为局部变量分配的存储空间的大小，它包括参数列表中的形参变量和函数体中定义的局部变量两个部分，记作S(n) = O(f(n))。时间复杂度定性描述了该算法的运行时间，记作T(n) = O(f(n))。\n  如果算法A需要的时间与f(n)成正比，则称算法A为f(n)阶，记为O(f(n))。函数f(n)称为算法的增率函数(growth-rate function)。该表示法使用大学字母O(Order)来表示，故称为大O表示法。若规模为n的问题需要的时间与n成正比，则问题表示为O(n),即n阶。若需要的时间与\\(n^2\\)成正比，则问题表示为O(\\(n^2\\)),以此类推。**O并不是一个函数。**他的属性有：\n  1.可忽略算法增率函数的低阶项\n  2.可忽略算法增率函数中高阶项的倍输常量\n  3.O(f(n)) + O(g(n))=O(f(n)+g(n))可组合增率函数\n  形式化定义：\n  给定2个正值函数f和g，定义：f(n) = O(g(n)),条件为：存在正实数c和N，使得对于所有的n\\(\\ge\\)N,有|f(n)|\\(\\le\\)|cg(n)|。上述的定义表明，当n足够大，大过一个特定的N时，且存在一个正数c，使得|f(n)|不大于|cg(n)|,则f是g的O表示。关系可以解释为g(n)是f(n)的一个上界，也可以理解为f增长的速度最多和g一样快，而不会超过g。\n\n\n名称\n表示法\n定义\n\n\n\n\nTilde\nf(n)~g(n)\n$$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 1$$\n\n\nBig Oh\nf(n) is O(g(n))\n$$\\exists c \\gt 0, n_0 \\ge 0$$such that \\( 0 \\le f(n) \\le c \\cdot g(n)\\) for all \\(n \\ge n_0\\)\n\n\nBig Omega\nf(n) is \\(\\Omega\\)(g(n))\ng(n) is O(f(n))\n\n\nBig Theta\nf(n) is \\(\\Theta\\)(g(n))\nf(n) is both O(g(n)) and \\(\\Omega\\)(g(n))\n\n\nLittle oh\nf(n) is o(g(n))\n$$ \\lim_{x \\to \\infty} \\frac{f(n)}{g(n)} = 0$$\n\n\nLittle omega\nf(n) is \\(\\omega\\)(g(n))\ng(n) is o(f(n))\n\n\n3.递归算法的定义，及其两要素。\n  递归就是循环定义，对于一个方法来说，就是自己调用自己。\n  两要素：\n  -终止条件\n  -递推公式\n  经典汉诺塔问题(c#实现)\n1234567891011121314151617181920212223using System;namespace Hanoi_Tower&#123;    class Program    &#123;        static void Main(string[] args)        &#123;            int n &#x3D; Int32.Parse(Console.ReadLine());            Hanoi(n,&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);        &#125;        private static void Hanoi(int n, string a,string b, string c)&#123;            if(n &#x3D;&#x3D; 1)Move(a,c);            else &#123;                Hanoi(n-1, a, c, b);                Move(a,c);                Hanoi(n-1, b, a, c);            &#125;        &#125;        private static void Move(string origin, string des)&#123;            Console.WriteLine(origin+ &quot;---&gt;&quot; + des);        &#125;    &#125;&#125;\n4.分治算法的思想，经典的分治算法(全排列、二分搜索、归并排序、快速排序、线性时间选择、最接近点对问题)。\n","plink":"http://Ssssshinji.github.io/2020/06/24/算法常见面试题1-5/"},{"title":"图片测试","date":"2020-06-20T11:53:43.000Z","date_formatted":{"ll":"Jun 20, 2020","L":"06/20/2020","MM-DD":"06-20"},"updated":"2020-06-24T10:50:10.571Z","content":"\n","plink":"http://Ssssshinji.github.io/2020/06/20/image/"},{"title":"幸运星 第一话（外链视频测试）","date":"2020-06-20T09:32:57.000Z","date_formatted":{"ll":"Jun 20, 2020","L":"06/20/2020","MM-DD":"06-20"},"updated":"2020-06-24T12:33:37.079Z","content":"\n \n\n","plink":"http://Ssssshinji.github.io/2020/06/20/video/"}]