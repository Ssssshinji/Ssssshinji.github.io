{"title":"问题精析：延迟着色（deferred Shading）","date":"2020-06-29T18:42:23.000Z","date_formatted":{"ll":"Jun 30, 2020","L":"06/30/2020","MM-DD":"06-30"},"link":"2020/06/30/问题精析：延迟着色（deferred Shading）","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-18T06:04:55.396Z","content":"<h2 id=\"背景以及概念\">背景以及概念<a title=\"#背景以及概念\" href=\"#背景以及概念\"></a></h2>\n<p>  我们现在一直使用的光照方式叫做<strong>正向渲染(Forward Rendering)<strong>或者</strong>正向着色法(Forward Shading)</strong>，它是我们渲染物体的一种非常直接的方式，在场景中我们根据所有光源照亮一个物体，之后再渲染下一个物体，以此类推。它非常容易理解，也很容易实现，但是同时它对程序性能的影响也很大，因为对于每一个需要渲染的物体，程序都要对每一个光源每一个需要渲染的片段进行迭代，这是<strong>非常多</strong>的！因为大部分片段着色器的输出都会被之后的输出覆盖，正向渲染还会在场景中因为高深的复杂度(多个物体重合在一个像素上)浪费大量的片段着色器运行时间。</p>\n<p>  延迟着色法(Deferred Shading)，或者说是延迟渲染(Deferred Rendering)，为了解决上述问题而诞生了，它大幅度地改变了我们渲染物体的方式。这给我们优化拥有大量光源的场景提供了很多的选择，因为它能够在渲染上百甚至上千光源的同时还能够保持能让人接受的帧率。</p>\n<p>  延迟着色法基于我们延迟(Defer)或推迟(Postpone)大部分计算量非常大的渲染(像是光照)到后期进行处理的想法。它包含两个处理阶段(Pass)：在第一个几何处理阶段(Geometry Pass)中，我们先渲染场景一次，之后获取对象的各种几何信息，并储存在一系列叫做G缓冲(G-buffer)的纹理中；像位置向量(Position Vector)、颜色向量(Color Vector)、法向量(Normal Vector)和/或镜面值(Specular Value)。场景中这些储存在G缓冲中的几何信息将会在之后用来做(更复杂的)光照计算。G缓冲，G-Buffer，全称Geometric Buffer ，译作几何缓冲区，它主要用于存储每个像素对应的位置（Position），法线（Normal），漫反射颜色（Diffuse Color）以及其他有用材质参数。根据这些信息，就可以在像空间（二维空间）中对每个像素进行光照处理。<strong>（G缓冲中的内容不是固定的，是可以根据需要来增删的。比如说OpenGL教程中就多存储了镜面值 Specular Value）</strong><br>\n  我们会在第二个光照处理阶段(Lighting Pass)中使用G缓冲内的纹理数据。在光照处理阶段中，我们渲染一个屏幕大小的方形，并使用G缓冲中的几何数据对每一个片段计算场景的光照；在每个像素中我们都会对G缓冲进行迭代。我们对于渲染过程进行解耦，将它高级的片段处理挪到后期进行，而不是直接将每个对象从顶点着色器带到片段着色器。光照计算过程还是和我们以前一样，但是现在我们需要从对应的G缓冲而不是顶点着色器(和一些uniform变量)那里获取输入变量了。</p>\n<h2 id=\"片元着色器代码\">片元着色器代码<a title=\"#片元着色器代码\" href=\"#片元着色器代码\"></a></h2>\n<figure class=\"highlight glsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#version 330 core</span></span><br><span class=\"line\"><span class=\"keyword\">out</span> <span class=\"type\">vec4</span> FragColor;</span><br><span class=\"line\"><span class=\"keyword\">in</span> <span class=\"type\">vec2</span> TexCoords;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> gPosition;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> gNormal;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">sampler2D</span> gAlbedoSpec;</span><br><span class=\"line\"></span><br><span class=\"line\">struct Light &#123;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> Position;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> Color;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">float</span> Linear;</span><br><span class=\"line\">    <span class=\"type\">float</span> Quadratic;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"type\">int</span> NR_LIGHTS = <span class=\"number\">32</span>;</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> Light lights[NR_LIGHTS];</span><br><span class=\"line\"><span class=\"keyword\">uniform</span> <span class=\"type\">vec3</span> viewPos;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> main()</span><br><span class=\"line\">&#123;             </span><br><span class=\"line\">    <span class=\"comment\">// // 从G缓冲中获取数据</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> FragPos = <span class=\"built_in\">texture</span>(gPosition, TexCoords).rgb;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> Normal = <span class=\"built_in\">texture</span>(gNormal, TexCoords).rgb;</span><br><span class=\"line\">    <span class=\"type\">vec3</span> Diffuse = <span class=\"built_in\">texture</span>(gAlbedoSpec, TexCoords).rgb;</span><br><span class=\"line\">    <span class=\"type\">float</span> Specular = <span class=\"built_in\">texture</span>(gAlbedoSpec, TexCoords).a;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 然后和往常一样地计算光照</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> lighting  = Diffuse * <span class=\"number\">0.1</span>; <span class=\"comment\">// hard-coded ambient component</span></span><br><span class=\"line\">    <span class=\"type\">vec3</span> viewDir  = <span class=\"built_in\">normalize</span>(viewPos - FragPos);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; NR_LIGHTS; ++i)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">// Diffuse</span></span><br><span class=\"line\">        <span class=\"type\">vec3</span> lightDir = <span class=\"built_in\">normalize</span>(lights[i].Position - FragPos);</span><br><span class=\"line\">        <span class=\"type\">vec3</span> diffuse = <span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(Normal, lightDir), <span class=\"number\">0.0</span>) * Diffuse * lights[i].Color;</span><br><span class=\"line\">        <span class=\"comment\">// Specular</span></span><br><span class=\"line\">        <span class=\"type\">vec3</span> halfwayDir = <span class=\"built_in\">normalize</span>(lightDir + viewDir);  </span><br><span class=\"line\">        <span class=\"type\">float</span> spec = <span class=\"built_in\">pow</span>(<span class=\"built_in\">max</span>(<span class=\"built_in\">dot</span>(Normal, halfwayDir), <span class=\"number\">0.0</span>), <span class=\"number\">16.0</span>);</span><br><span class=\"line\">        <span class=\"type\">vec3</span> specular = lights[i].Color * spec * Specular;</span><br><span class=\"line\">        <span class=\"comment\">// Attenuation</span></span><br><span class=\"line\">        <span class=\"type\">float</span> <span class=\"built_in\">distance</span> = <span class=\"built_in\">length</span>(lights[i].Position - FragPos);</span><br><span class=\"line\">        <span class=\"type\">float</span> attenuation = <span class=\"number\">1.0</span> / (<span class=\"number\">1.0</span> + lights[i].Linear * <span class=\"built_in\">distance</span> + lights[i].Quadratic * <span class=\"built_in\">distance</span> * <span class=\"built_in\">distance</span>);</span><br><span class=\"line\">        diffuse *= attenuation;</span><br><span class=\"line\">        specular *= attenuation;</span><br><span class=\"line\">        lighting += diffuse + specular;</span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">    FragColor = <span class=\"type\">vec4</span>(lighting, <span class=\"number\">1.0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"优点\">优点<a title=\"#优点\" href=\"#优点\"></a></h2>\n<p>  Deferred Rendering 的最大的优势就是将光源的数目和场景中物体的数目在复杂度层面上完全分开。也就是说场景中不管是一个三角形还是一百万个三角形，最后的复杂度不会随光源数目变化而产生巨大变化。<br>\n一些要点：<br>\n  - 复杂度仅O(n+m)。<br>\n  - 只渲染可见的像素，节省计算量。<br>\n  - 用更少的shader（也算缺点，见缺点4）。<br>\n  - 对后处理支持良好。<br>\n  - 在大量光源的场景优势尤其明显。</p>\n<h2 id=\"缺点\">缺点<a title=\"#缺点\" href=\"#缺点\"></a></h2>\n<p>一些要点：<br>\n  - 内存开销较大。<br>\n  - 读写G-buffer的内存带宽用量是性能瓶颈。<br>\n  - 对透明物体的渲染存在问题。在这点上需要结合正向渲染进行渲染（因为不能使用混合 Blending）。<br>\n  - 对多重采样抗锯齿（MultiSampling Anti-Aliasing, MSAA）的支持不友好，主要因为需开启MRT。<br>\n  - 迫使你对大部分场景的光照使用相同的光照算法，你可以通过包含更多关于材质的数据到G缓冲中来减轻这一缺点。</p>\n<h2 id=\"与正向渲染比较\">与正向渲染比较<a title=\"#与正向渲染比较\" href=\"#与正向渲染比较\"></a></h2>\n<h3 id=\"正向渲染\">正向渲染<a title=\"#正向渲染\" href=\"#正向渲染\"></a></h3>\n<p>  - 正向渲染（Forward Rendering），先执行着色计算，再执行深度测试。<br>\n  - 正向渲染渲染n个物体在m个光源下的着色，复杂度为O(n*m)次。<br>\n  - Forward Rendering，光源数量对计算复杂度影响巨大，所以比较适合户外这种光源较少的场景。<br>\n  - Forward Rendering的核心伪代码可以表示为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For each light:</span><br><span class=\"line\">    For each object affected by the light: </span><br><span class=\"line\">        framebuffer +&#x3D; object * light</span><br></pre></td></tr></table></figure>\n<p>  - Forward Rendering的管线流程如下：顶点 -&gt; 图元 -&gt; 光栅化 -&gt; 片元 -&gt; 可选帧缓冲（实现后处理之类） -&gt; 帧缓冲</p>\n<h3 id=\"延迟渲染\">延迟渲染<a title=\"#延迟渲染\" href=\"#延迟渲染\"></a></h3>\n<p>  - 延迟渲染( Deferred Rendering)，先执行深度测试，再执行着色计算。<br>\n  - 将光源的数目和场景中物体的数目在复杂度层面上完全分开。<br>\n  - 延迟渲染渲染n个物体在m个光源下的着色，复杂度为O(n+m)次。<br>\n  - Deferred Rendering的核心伪代码可以表示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">For each object: </span><br><span class=\"line\">    Render to multiple targets For each light: </span><br><span class=\"line\">        Apply light as a 2D postprocess</span><br></pre></td></tr></table></figure>\n<p>  - Deferred Rendering的管线流程如下：顶点 -&gt; 图元 -&gt; 光栅化 -&gt; 几何处理阶段 -&gt; 可选帧缓冲（实现后处理之类）-&gt; G-buffer -&gt; 光照处理阶段 -&gt; 帧缓冲</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. 《Real-Time Rendering 3rd》 提炼总结<br>\n   2. <a href=\"https://learnopengl-cn.github.io/05%20Advanced%20Lighting/08%20Deferred%20Shading/\" target=\"_blank\">延迟着色法</a></p>\n","prev":{"title":"问题2：判定是否互为字符重排","link":"2020/07/01/问题2：判定是否互为字符重排"},"next":{"title":"问题2：迷路的机器人","link":"2020/06/30/问题2：迷路的机器人"},"plink":"http://Ssssshinji.github.io/2020/06/30/问题精析：延迟着色（deferred Shading）/","toc":[{"id":"背景以及概念","title":"背景以及概念","index":"1"},{"id":"片元着色器代码","title":"片元着色器代码","index":"2"},{"id":"优点","title":"优点","index":"3"},{"id":"缺点","title":"缺点","index":"4"},{"id":"与正向渲染比较","title":"与正向渲染比较","index":"5","children":[{"id":"正向渲染","title":"正向渲染","index":"5.1"},{"id":"延迟渲染","title":"延迟渲染","index":"5.2"}]},{"id":"参考资料","title":"参考资料","index":"6"}]}