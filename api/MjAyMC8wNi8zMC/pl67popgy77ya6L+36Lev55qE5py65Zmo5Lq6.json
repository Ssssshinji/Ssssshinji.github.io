{"title":"问题2：迷路的机器人","date":"2020-06-29T17:06:28.000Z","date_formatted":{"ll":"Jun 30, 2020","L":"06/30/2020","MM-DD":"06-30"},"link":"2020/06/30/问题2：迷路的机器人","tags":["递归与动态规划"],"categories":["算法练习"],"updated":"2020-06-29T18:38:01.800Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  设想有个机器人坐在一个网格的左上角，网格r行c列。机器人只能向下或向右移动，但不能走到一些被禁止的网格。设计一种算法，寻找机器人从左上角移动到右下角的路径。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  这个应该属于动态规划的范围内，从最后一步往前倒着思考试试。想了想好像能结合DFS写出来。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ArrayList FindPath(bool[][] maze)&#123;</span><br><span class=\"line\">    if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ArrayList path &#x3D; new ArrayList();</span><br><span class=\"line\">    if(maze.Length &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">        path.Add(new Point(0,0));</span><br><span class=\"line\">        return path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(FindPath(maze,maze.Length-1,maze[0].Length-1,path))&#123;</span><br><span class=\"line\">        return path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static bool FindPath(bool[][] maze,int row, int col,ArrayList path)&#123;</span><br><span class=\"line\">    if(isAtOrigin())&#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(FindPath(maze,row-1,col,path))&#123;</span><br><span class=\"line\">        path.Add(new Point(row,col));</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(FindPath(maze,row,col-1,path))&#123;</span><br><span class=\"line\">        path.Add(new Point(row,col));</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  O(2^(r+c))。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ArrayList FindPath(bool[][] maze)&#123;</span><br><span class=\"line\">    if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ArrayList path &#x3D; new ArrayList();</span><br><span class=\"line\">    if(maze.Length &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">        path.Add(new Point(0,0));</span><br><span class=\"line\">        return path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(FindPath(maze,maze.Length-1,maze[0].Length-1,path))&#123;</span><br><span class=\"line\">        return path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static bool FindPath(bool[][] maze,int row, int col,ArrayList path)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;边界检查</span><br><span class=\"line\">    if(col &lt; 0 || row &lt; 0 || !maze[row][col])&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bool isAtOrigin &#x3D; (row &#x3D;&#x3D; 0) &amp;&amp; (col &#x3D;&#x3D; 0);</span><br><span class=\"line\">    if(isAtOrigin||FindPath(maze,row-1,col,path)||FindPath(maze,row,col-1,path))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        path.Add(new Point(row,col));</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析-1\">复杂度分析<a title=\"#复杂度分析-1\" href=\"#复杂度分析-1\"></a></h2>\n<p>  O(2^(r+c))。</p>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  -如果把网格画出来，你会发现移动到位置(r,c)的唯一方式，就是先移动到它的相邻点，即(r-1,c)或(r,c-1)。因此，我们需要找到一条移至(r-1,c)或(r,c-1)的路径。<br>\n  -怎么才能找出前往这些位置的路径呢？要找出前往(r-1,c)或(r,c-1)的路径，我们需要先移至其中一个相邻点。因此，要找到一条路径移动到(r-1,c)的相邻点，坐标为(r-2,c)和(r-1,c-1)或(r,c-1)的相邻点，其坐标为(r-1,c-1)和(r,c-2)。注意，坐标(r-1,c-1)一共出现了两次。<br>\n  -理想情况下，我们应该能记住访问过(r-1,c-1)节点以节省时间。</p>\n<h2 id=\"标准解答（进阶）\">标准解答（进阶）<a title=\"#标准解答（进阶）\" href=\"#标准解答（进阶）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static ArrayList FindPath(bool[][] maze)&#123;</span><br><span class=\"line\">    if(maze &#x3D;&#x3D; null || maze.Length &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ArrayList path &#x3D; new ArrayList();</span><br><span class=\"line\">    HashSet&lt;Point&gt; failedPoints &#x3D; new HashSet&lt;Point&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    if(maze.Length &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">        path.Add(new Point(0,0));</span><br><span class=\"line\">        return path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    if(FindPath(maze,maze.Length-1,maze[0].Length-1,path,failedPoints))&#123;</span><br><span class=\"line\">        return path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static bool FindPath(bool[][] maze,int row, int col,ArrayList path,HashSet&lt;Point&gt; failedPoints)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;边界检查</span><br><span class=\"line\">    if(col &lt; 0 || row &lt; 0 || !maze[row][col])&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Point p &#x3D; new Point(row,col);</span><br><span class=\"line\">    if(failedPoints.Contains(p))&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bool isAtOrigin &#x3D; (row &#x3D;&#x3D; 0) &amp;&amp; (col &#x3D;&#x3D; 0);</span><br><span class=\"line\">    if(isAtOrigin||FindPath(maze,row-1,col,path,failedPoints)||FindPath(maze,row,col-1,path,failedPoints))&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        path.Add(p);</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    failedPoints.Add(p);</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  又忘记了边界检查，有先后顺序的if可以利用||运算符写在一个if里,在完成算法之后尽量优化。</p>\n<h2 id=\"提示：#331，#360，#388\">提示：#331，#360，#388<a title=\"#提示：#331，#360，#388\" href=\"#提示：#331，#360，#388\"></a></h2>\n<p>  -为了让机器人到最后一个格子，必须找出到倒数第二个格子的路径。为了到倒数第二个格子，必须找出到倒数第三个格子的路径。<br>\n  -首先明确是否有路径，以便稍微简化这个问题。然后，修改你的算法跟踪路径。<br>\n  -再考虑一下你算法的效率。你能优化它吗？</p>\n","prev":{"title":"问题精析：延迟着色（deferred Shading）","link":"2020/06/30/问题精析：延迟着色（deferred Shading）"},"next":{"title":"问题1：三步问题","link":"2020/06/28/问题1：三步问题"},"plink":"http://Ssssshinji.github.io/2020/06/30/问题2：迷路的机器人/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"复杂度分析","title":"复杂度分析","index":"4"},{"id":"标准解答","title":"标准解答","index":"5"},{"id":"复杂度分析-1","title":"复杂度分析","index":"6"},{"id":"题目解析","title":"题目解析","index":"7"},{"id":"标准解答（进阶）","title":"标准解答（进阶）","index":"8"},{"id":"反思","title":"反思","index":"9"},{"id":"提示：#331，#360，#388","title":"提示：#331，#360，#388","index":"10"}]}