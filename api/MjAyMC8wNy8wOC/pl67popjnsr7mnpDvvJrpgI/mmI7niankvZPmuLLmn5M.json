{"title":"问题精析：透明物体渲染","date":"2020-07-07T18:01:28.000Z","date_formatted":{"ll":"Jul 8, 2020","L":"07/08/2020","MM-DD":"07-08"},"link":"2020/07/08/问题精析：透明物体渲染","tags":["计算机图形学"],"categories":["问题精析"],"updated":"2020-07-07T18:25:11.619Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"丢弃片段(discard)\">丢弃片段(Discard)<a title=\"#丢弃片段(discard)\" href=\"#丢弃片段(discard)\"></a></h2>\n<p>  些图片并不需要半透明，只需要根据纹理颜色值，显示一部分，或者不显示一部分，没有中间情况。比如说草，如果想不太费劲地创建草这种东西，你需要将一个草的纹理贴在一个2D四边形(Quad)上，然后将这个四边形放到场景中。然而，草的形状和2D四边形的形状并不完全相同，所以你只想显示草纹理的某些部分，而忽略剩下的部分。<br>\n  下面这个纹理正是这样的，它要么是完全不透明的（alpha值为1.0），要么是完全透明的（alpha值为0.0），没有中间情况。你可以看到，只要不是草的部分，这个图片显示的都是网站的背景颜色而不是它本身的颜色。<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/03/grass.png\" alt=\"\"><br>\n  所以当添加像草这样的植被到场景中时，我们不希望看到草的方形图像，而是只显示草的部分，并能看透图像其余的部分。我们想要丢弃(Discard)显示纹理中透明部分的片段，不将这些片段存储到颜色缓冲中。在此之前，我们还要学习如何加载一个透明的纹理。<br>\n  要想加载有alpha值的纹理，我们并不需要改很多东西，stb_image在纹理有alpha通道的时候会自动加载，但我们仍要在纹理生成过程中告诉OpenGL，我们的纹理现在使用alpha通道了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);</span><br></pre></td></tr></table></figure>\n<p>  同样，保证你在片段着色器中获取了纹理的全部4个颜色分量，而不仅仅是RGB分量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#version 330 core</span><br><span class=\"line\">out vec4 FragColor;</span><br><span class=\"line\"></span><br><span class=\"line\">in vec2 TexCoords;</span><br><span class=\"line\"></span><br><span class=\"line\">uniform sampler2D texture1;</span><br><span class=\"line\"></span><br><span class=\"line\">void main()</span><br><span class=\"line\">&#123;             </span><br><span class=\"line\">    vec4 texColor &#x3D; texture(texture1, TexCoords);</span><br><span class=\"line\">    if(texColor.a &lt; 0.1)</span><br><span class=\"line\">        discard;</span><br><span class=\"line\">    FragColor &#x3D; texColor;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  这里，我们检测被采样的纹理颜色的alpha值是否低于0.1的阈值，如果是的话，则丢弃这个片段。片段着色器保证了它只会渲染不是（几乎）完全透明的片段。</p>\n<blockquote>\n<p>  注意，当采样纹理的边缘的时候，OpenGL会对边缘的值和纹理下一个重复的值进行插值（因为我们将它的环绕方式设置为了GL_REPEAT。这通常是没问题的，但是由于我们使用了透明值，纹理图像的顶部将会与底部边缘的纯色值进行插值。这样的结果是一个半透明的有色边框，你可能会看见它环绕着你的纹理四边形。要想避免这个，每当你alpha纹理的时候，请将纹理的环绕方式设置为GL_CLAMP_TO_EDGE。</p>\n</blockquote>\n<h2 id=\"混合\">混合<a title=\"#混合\" href=\"#混合\"></a></h2>\n<p>  OpenGL中，混合(Blending)通常是实现物体透明度(Transparency)的一种技术。透明就是说一个物体（或者其中的一部分）不是纯色(Solid Color)的，它的颜色是物体本身的颜色和它背后其它物体的颜色的不同强度结合。一个有色玻璃窗是一个透明的物体，玻璃有它自己的颜色，但它最终的颜色还包含了玻璃之后所有物体的颜色。这也是混合这一名字的出处，我们混合(Blend)（不同物体的）多种颜色为一种颜色。所以透明度能让我们看穿物体。<br>\n  虽然直接丢弃片段很好，但它不能让我们渲染半透明的图像。我们要么渲染一个片段，要么完全丢弃它。要想渲染有多个透明度级别的图像，我们需要启用混合(Blending)。和OpenGL大多数的功能一样，我们可以启用GL_BLEND来启用混合：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">glEnable(GL_BLEND);</span><br></pre></td></tr></table></figure>\n<p>  启用了混合之后，我们需要告诉OpenGL它该如何混合。OpenGL中的混合是通过下面这个方程来实现的：<br>\n$$<br>\nC_result=C_source∗F_source+C_destination∗F_destination<br>\n$$<br>\nCsource：源颜色向量。这是源自纹理的颜色向量。<br>\nCdestination：目标颜色向量。这是当前储存在颜色缓冲中的颜色向量。<br>\nFsource：源因子值。指定了alpha值对源颜色的影响。<br>\nFdestination：目标因子值。指定了alpha值对目标颜色的影响。<br>\n  片段着色器运行完成后，<strong>并且所有的测试都通过之后</strong>，这个混合方程(Blend Equation)才会应用到片段颜色输出与当前颜色缓冲中的值（当前片段之前储存的之前片段的颜色）上。源颜色和目标颜色将会由OpenGL自动设定，但源因子和目标因子的值可以由我们来决定。我们先来看一个简单的例子：<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/03/blending_equation.png\" alt=\"\"></p>\n<p>  我们有两个方形，我们希望将这个半透明的绿色方形绘制在红色方形之上。红色的方形将会是目标颜色（所以它应该先在颜色缓冲中），我们将要在这个红色方形之上绘制这个绿色方形。<br>\n  问题来了：我们将因子值设置为什么？嘛，我们至少想让绿色方形乘以它的alpha值，所以我们想要将Fsrc设置为源颜色向量的alpha值，也就是0.6。接下来就应该清楚了，目标方形的贡献应该为剩下的alpha值。如果绿色方形对最终颜色贡献了60%，那么红色方块应该对最终颜色贡献了40%，即1.0 - 0.6。所以我们将Fdestination设置为1减去源颜色向量的alpha值。这个方程变成了：<br>\n$$<br>\n\\begin{pmatrix}<br>\n0.0 &amp; \\\\<br>\n1.0 &amp;  \\\\<br>\n0.0 &amp;  \\\\<br>\n0.6 &amp;  \\\\<br>\n\\end{pmatrix} * 0.6 +<br>\n\\begin{pmatrix}<br>\n1 &amp; \\\\<br>\n0 &amp;  \\\\<br>\n0 &amp;  \\\\<br>\n1 &amp;  \\\\<br>\n\\end{pmatrix} * (1-0.6)<br>\n$$<br>\n  结果就是重叠方形的片段包含了一个60%绿色，40%红色的一种脏兮兮的颜色：<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/03/blending_equation_mixed.png\" alt=\"\"><br>\n  最终的颜色将会被储存到颜色缓冲中，替代之前的颜色。<br>\n  glBlendFunc(GLenum sfactor, GLenum dfactor)函数接受两个参数，来设置源和目标因子。OpenGL为我们定义了很多个选项。</p>\n<h2 id=\"半透明物体遮挡问题\">半透明物体遮挡问题<a title=\"#半透明物体遮挡问题\" href=\"#半透明物体遮挡问题\"></a></h2>\n<p>  最前面窗户的透明部分遮蔽了背后的窗户？这为什么会发生呢？<br>\n<img src=\"https://learnopengl-cn.github.io/img/04/03/blending_incorrect_order.png\" alt=\"\"><br>\n  深度测试和混合一起使用的话会产生一些麻烦。当写入深度缓冲时，深度缓冲不会检查片段是否是透明的，所以透明的部分会和其它值一样写入到深度缓冲中。结果就是窗户的整个四边形不论透明度都会进行深度测试。即使透明的部分应该显示背后的窗户，深度测试仍然丢弃了它们。<br>\n  所以我们不能随意地决定如何渲染窗户，让深度缓冲解决所有的问题了。这也是混合变得有些麻烦的部分。要想保证窗户中能够显示它们背后的窗户，我们需要首先绘制背后的这部分窗户。这也就是说在绘制的时候，我们必须先手动将窗户按照最远到最近来排序，再按照顺序渲染。</p>\n<blockquote>\n<p>  注意，对于草这种全透明的物体，我们可以选择丢弃透明的片段而不是混合它们，这样就解决了这些头疼的问题（没有深度问题）。</p>\n</blockquote>\n<p>  要想让混合在多个物体上工作，我们需要最先绘制最远的物体，最后绘制最近的物体。普通不需要混合的物体仍然可以使用深度缓冲正常绘制，所以它们不需要排序。但我们仍要保证它们在绘制（排序的）透明物体之前已经绘制完毕了。当绘制一个有不透明和透明物体的场景的时候，大体的原则如下：<br>\n  1.先绘制所有不透明的物体。<br>\n  2.对所有透明的物体排序。<br>\n  3.按顺序绘制所有透明的物体。(从远到近，右手坐标系来说是-z到+z)</p>\n<h2 id=\"参考资料\">参考资料<a title=\"#参考资料\" href=\"#参考资料\"></a></h2>\n<p>   1. <a href=\"https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/03%20Blending/\" target=\"_blank\">混合</a></p>\n","prev":{"title":"问题3：特定深度结点链表","link":"2020/07/08/问题3：特定深度结点链表"},"next":{"title":"问题3：删除中间节点","link":"2020/07/08/问题3：删除中间节点"},"plink":"http://Ssssshinji.github.io/2020/07/08/问题精析：透明物体渲染/","toc":[{"id":"丢弃片段(discard)","title":"丢弃片段(Discard)","index":"1"},{"id":"混合","title":"混合","index":"2"},{"id":"半透明物体遮挡问题","title":"半透明物体遮挡问题","index":"3"},{"id":"参考资料","title":"参考资料","index":"4"}]}