{"title":"问题3：特定深度结点链表","date":"2020-07-08T07:53:49.000Z","date_formatted":{"ll":"Jul 8, 2020","L":"07/08/2020","MM-DD":"07-08"},"link":"2020/07/08/问题3：特定深度结点链表","tags":["树与图"],"categories":["算法练习"],"updated":"2020-07-08T11:23:44.105Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为D，则会创建出D个链表）。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  题目只说创建没有说返回，则可以不考虑返回值。可以用BFS遍历所有节点但是怎么样和深度产生联系呢?即使写一个函数求出深度，也不知道怎么和节点联系起来</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无解答</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  乍一看，你可能会认为这个问题需要逐一遍历，但其实并无必要。可用任意方式遍历整棵树，只需记住节点位于哪一层即可。<br>\n  我们可以将前序遍历算法稍作修改，将level+1传入下一个递归调用。下面是使用深度优先搜索的实现代码。</p>\n<h2 id=\"标准解答（dfs）\">标准解答（DFS）<a title=\"#标准解答（dfs）\" href=\"#标准解答（dfs）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void createLevelLinkedList(TreeNode root, ArrayList lists, int level)&#123;</span><br><span class=\"line\">    if(root &#x3D;&#x3D; null) return;</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; list &#x3D; null;</span><br><span class=\"line\">    if(lists.Count &#x3D;&#x3D; level)&#123;</span><br><span class=\"line\">        list &#x3D; new LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        lists.Add(list);</span><br><span class=\"line\">    &#125;else&#123;</span><br><span class=\"line\">        list &#x3D; (LinkedList&lt;TreeNode&gt;)lists[level];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    list.AddLast(root);</span><br><span class=\"line\">    createLevelLinkedList(root.left, lists, level+1);</span><br><span class=\"line\">    createLevelLinkedList(root.right, lists, level+1);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;包装函数</span><br><span class=\"line\">ArrayList createLevelLinkedList(TreeNode root)&#123;</span><br><span class=\"line\">    ArrayList lists &#x3D; new ArrayList();</span><br><span class=\"line\">    createLevelLinkedList(root,lists,0);</span><br><span class=\"line\">    return lists;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  另一种做法是对广度优先搜索稍加修改，即从根节点开始迭代，然后第2层，第3层，以此类推。处于第i层时，则表明我们已访问过第i-1层的所有节点，也就是说，要得到i层的节点，只需直接查看i-1层节点的所有子节点即可。</p>\n<h2 id=\"标准解答（bfs）\">标准解答（BFS）<a title=\"#标准解答（bfs）\" href=\"#标准解答（bfs）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ArrayList createLevelLinkedList(TreeNode root, int level)&#123;</span><br><span class=\"line\">    if(root &#x3D;&#x3D; null) return null;</span><br><span class=\"line\">    ArrayList result &#x3D; new ArrayList();</span><br><span class=\"line\">    LinkedList&lt;TreeNode&gt; list &#x3D; new LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">    list.AddLast(root);</span><br><span class=\"line\">    while(list.Count !&#x3D; 0)&#123;</span><br><span class=\"line\">        result.Add(list);</span><br><span class=\"line\">        LinkedList&lt;TreeNode&gt; parents &#x3D; list;</span><br><span class=\"line\">        list &#x3D; new LinkedList&lt;TreeNode&gt;();</span><br><span class=\"line\">        foreach(TreeNode node in parents)&#123;</span><br><span class=\"line\">            if(node.left !&#x3D; null)&#123;</span><br><span class=\"line\">                list.AddLast(node.left);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(node.right !&#x3D; null)&#123;</span><br><span class=\"line\">                list.AddLast(node.right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  两者的时间复杂度皆为O(N)，那么空间效率呢？乍一看，我们可能会以为第二种解法的空间效率更高。在某种意义上，这么说也对。第一种解法会用到O(logN)次递归调用（在平衡树中），每次调用都会在栈里增加一级。第二种解法采用迭代遍历法，不需要这部分额外空间。不过，两种解法都要返回O(N)的数据，因此，递归实现所需的额外的O(logN)空间，跟必须传回的O(N)数据相比，并不算多。虽然第一种解法确实使用了较多的空间，但从大O记法的角度来看，两者效率是一样的。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  这种BFS的变形是我怎么也没想到了，再看了一遍后边回忆边写还是会出错。</p>\n<h2 id=\"提示：#107，#123，#135\">提示：#107，#123，#135<a title=\"#提示：#107，#123，#135\" href=\"#提示：#107，#123，#135\"></a></h2>\n<p>  -尝试修改图形搜索算法，从根开始追踪深度。<br>\n  -从层号映射到该层节点的散列表或数组也许有些用处。<br>\n  -你应该能够提出一个既包括深度优先搜索又包含广度优先搜索的算法。</p>\n","prev":{"title":"问题精析：PBR概述","link":"2020/07/08/问题精析：PBR概述"},"next":{"title":"问题精析：透明物体渲染","link":"2020/07/08/问题精析：透明物体渲染"},"plink":"http://Ssssshinji.github.io/2020/07/08/问题3：特定深度结点链表/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"标准解答（dfs）","title":"标准解答（DFS）","index":"5"},{"id":"标准解答（bfs）","title":"标准解答（BFS）","index":"6"},{"id":"复杂度分析","title":"复杂度分析","index":"7"},{"id":"反思","title":"反思","index":"8"},{"id":"提示：#107，#123，#135","title":"提示：#107，#123，#135","index":"9"}]}