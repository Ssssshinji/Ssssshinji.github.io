{"title":"问题5：栈排序","date":"2020-08-03T17:19:03.000Z","date_formatted":{"ll":"Aug 4, 2020","L":"08/04/2020","MM-DD":"08-04"},"link":"2020/08/04/问题5：栈排序","tags":["栈与队列"],"categories":["算法练习"],"updated":"2020-08-03T17:58:49.672Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek和isEmpty。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  每当有元素（称其为x）要入栈时，先对栈进行Peek操作，和将要x元素比较大小，如果栈中元素小，将其出栈到临时栈中。循环此操作，待到栈中元素大于x元素时，入栈，并把临时栈中的元素依次入栈回栈中。不对，是对已有的栈排序，那不会了。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">无</span><br></pre></td></tr></table></figure>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  一种做法是实现初步的排序算法。搜索整个栈，找出最小元素，之后将其压入另一个栈。然后，在剩余元素中找出最小的，并将其入栈。这种做法实际上需要三个栈：s1为原先的栈，s2为最终排好序的栈，s3在搜索s1时用作缓冲区。要在s1中搜索最小值，我们需要弹出s1的元素，将它们压入缓冲区s3。<br>\n  可惜，这需要两个额外的栈，而我们只能使用其中一个。有没有更好的做法？有。<br>\n  我们不需要反复搜索最小值，若要对s1排序，可以从s1逐一弹出元素，然后按顺序插入s2中。具体怎么做呢？<br>\n  假设有如下两个栈，其中s2是“排序的”，s1则是未排序的。</p>\n<img src=\"/2020/08/04/%E9%97%AE%E9%A2%985%EF%BC%9A%E6%A0%88%E6%8E%92%E5%BA%8F/1.png\" class=\"\">\n<p>  从s1中弹出5时，我们需要在s2中找个合适的位置插入这个数。在这个例子中，正确位置是在s2元素3之上。怎样才能将5插入那个位置呢？我们可以先从s1中弹出5，将其存放在临时变量中。然后，将12和8移至s1（从s2中弹出这两个数，并将它们压入s1中），然后将5压入s2。</p>\n<img src=\"/2020/08/04/%E9%97%AE%E9%A2%985%EF%BC%9A%E6%A0%88%E6%8E%92%E5%BA%8F/2.png\" class=\"\">\n<p>  注意，8和12仍在s1中，这没关系。对于这两个数，我们可以像处理5那样重复相关步骤，每次弹出s1栈顶元素，将其放入s2中的合适位置。当然，我们可以将8和12直接从s2移至s1，因为这两个数都比5大，这些元素的“正确位置”就是放在5之上。我们不需要打乱s2的其他元素，当tmp为8或12时，下面代码中的第二个while循环不会执行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static void SortStack(Stack s)&#123;</span><br><span class=\"line\">    Stack tempStack &#x3D; new Stack();</span><br><span class=\"line\">    while(s.Count !&#x3D; 0)&#123;</span><br><span class=\"line\">        int a &#x3D; (int)s.Pop();</span><br><span class=\"line\">        while(tempStack.Count !&#x3D; 0 &amp;&amp; (int)tempStack.Peek() &gt; a)&#123;</span><br><span class=\"line\">            s.Push(tempStack.Pop());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        tempStack.Push(a);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    while(tempStack.Count &gt; 0)&#123;</span><br><span class=\"line\">        s.Push(tempStack.Pop());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"时间复杂度\">时间复杂度<a title=\"#时间复杂度\" href=\"#时间复杂度\"></a></h2>\n<p>  这个算法的时间复杂度为O(N^2)，空间复杂度为O(N)。<br>\n  如果允许使用的栈数量不限，我们可以实现修改版的quicksort或mergesort。<br>\n  对于mergesort解法，我们可以再创建两个栈，并将这个栈分为两部分。我们会递归排序每个栈，然后将它们归并到一起并排好序，放回原来的栈中。注意，该解法要求每层递归都创建两个额外的栈。<br>\n  对于quicksort解法，我们会创建两个额外的栈，并根据基准元素（pivot element）将这个栈分为两个栈。这两个栈会进行递归排序，然后归并在一起，放回原来的栈中。与上一个解法一样，每层递归都会创建两个额外的栈。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  自己只能想到比题目更简单的情况的解法，看到题目稍微复杂一点，一下子没了思路，就放弃了。其实顺着自己的思路一点一点往前走，是能找到和题目的联系的。</p>\n<h2 id=\"提示：#15，#32，#43\">提示：#15，#32，#43<a title=\"#提示：#15，#32，#43\" href=\"#提示：#15，#32，#43\"></a></h2>\n<p>  -排序数组的一种方法是遍历数组，并将每个元素按排序顺序插入到一个新数组中。你可以用一个栈实现吗？<br>\n  -假设二级栈已排序。你能按顺序插入元素吗？你可能需要一些额外的存储空间。你可以使用什么额外的存储？<br>\n  -保持二级栈的排序顺序，最大的元素在顶部。使用主栈进行额外的存储。</p>\n","prev":{"title":"问题精析：反向运动学2","link":"2020/08/04/问题精析：反向运动学2"},"next":{"title":"问题精析：反向运动学1","link":"2020/08/03/问题精析：反向运动学1"},"plink":"http://Ssssshinji.github.io/2020/08/04/问题5：栈排序/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"题目解析","title":"题目解析","index":"4"},{"id":"时间复杂度","title":"时间复杂度","index":"5"},{"id":"反思","title":"反思","index":"6"},{"id":"提示：#15，#32，#43","title":"提示：#15，#32，#43","index":"7"}]}