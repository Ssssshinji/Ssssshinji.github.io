{"title":"问题5：合法二叉搜索树","date":"2020-07-16T04:39:46.000Z","date_formatted":{"ll":"Jul 16, 2020","L":"07/16/2020","MM-DD":"07-16"},"link":"2020/07/16/问题5：合法二叉搜索树","tags":["树与图"],"categories":["算法练习"],"updated":"2020-07-16T09:03:11.272Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  实现一个函数，检查一棵二叉树是否为二叉搜索树。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  保证leftChild &lt; node &lt; rightChild,不仅如此，左边的每个节点必须小于当前节点，该节点还必须小于右边的所有节点。也就是说，左子树都有最大值，右子树有最小值。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static bool IsSearchTree(Treenode node,int min, int max)&#123;</span><br><span class=\"line\">    if(node &#x3D;&#x3D; null)&#123;</span><br><span class=\"line\">        return true;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(node.value &lt; min || node.value &gt; max)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(node.value &lt; node.left.value || node.value &gt; node.right.value)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">        return IsSearchTree(node.left,Int32.MinValue,node.value) &amp;&amp; IsSearchTree(node.right,node.value,Int32.MaxValue);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  O(n)。</p>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  此题有两种不同的解法：第一种是利用中序遍历，第二种则建立在left&lt;=current&lt;right这项特性之上。<br>\n  **解法1：中序遍历：**看到此题，首先想到的可能是中序遍历，即将所有元素复制到数组中，然后检查该数组是否有序。这种解法会占用一点儿额外的内存，但大部分情况下都奏效。唯一的问题在于，它无法正确处理树中的重复值。例如，一棵树的左子节点和本身都是20，一棵树的右子节点和本身都是20，该算法无法区分这两棵树（其中一棵是无效的）。因为两者的中序遍历结果相同。不过，要是假定这棵树不得包含重复值，那么这种做法还是行之有效的。该方法的伪码大致如下。</p>\n<h2 id=\"标准解答\">标准解答<a title=\"#标准解答\" href=\"#标准解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int[] array &#x3D; new int[tree.size];</span><br><span class=\"line\">for（中序遍历）&#123;</span><br><span class=\"line\">    array[i++] &#x3D; node;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">比较数组中前一个和后一个的大小</span><br></pre></td></tr></table></figure>\n<p>  注意，这里必须记录数组在逻辑上的“尾部”，用它来分配空间以存储所有元素。<br>\n  仔细检查该解法，就会发现代码中的数组实无必要。除了用来比较某个元素和前一个元素，别无他用。那么，为什么不在进行比较时，直接记下最后的元素？<br>\n  下面是该算法的实现代码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int32 last_printed &#x3D; Int32.MinValue;</span><br><span class=\"line\">bool checkBST(Treenode n)&#123;</span><br><span class=\"line\">    if(n &#x3D;&#x3D; null)return true;</span><br><span class=\"line\">    &#x2F;&#x2F;对左子树递归</span><br><span class=\"line\">    if(!checkBST(n.left))return false;</span><br><span class=\"line\">    &#x2F;&#x2F;检查当前节点</span><br><span class=\"line\">    if(last_printed !&#x3D; Int32.MinValue &amp;&amp; n.data &lt;&#x3D; last_printed)&#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    last_printed &#x3D; n.data;</span><br><span class=\"line\">    &#x2F;&#x2F;对右子树递归</span><br><span class=\"line\">    if(!checkBST(n.right))return false;</span><br><span class=\"line\">    return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  <strong>解法2：最小与最大法</strong>一棵什么样的树才可称为二叉搜索树？我们知道这棵树必须满足以下条件：对于每个节点，left.data&lt;=current.data&lt; right.data，但是这样还不够。更准确地说，成为二叉搜索树的条件是：所有左边的节点必须小于或等于当前节点，而当前节点必须小于所有右边的节点。<br>\n  利用这一点，我们可以通过自上而下传递最小和最大值来解决这个问题。在迭代遍历整个树的过程中，我们会用逐渐变窄的范围来检查各个节点。利用这一点，我们可以通过自上而下传递最小和最大值来解决这个问题。在迭代遍历整个树的过程中，我们会用逐渐变窄的范围来检查各个节点。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">与个人思路基本相同</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  对前序遍历的性质掌握不到位。</p>\n<h2 id=\"提示：#35，#57，#86，#113，#128\">提示：#35，#57，#86，#113，#128<a title=\"#提示：#35，#57，#86，#113，#128\" href=\"#提示：#35，#57，#86，#113，#128\"></a></h2>\n<p>  -如果使用前序遍历来遍历树，元素的顺序是正确的，这是否表明树实际上是有序的？有重复元素会发生什么？如果允许重复元素，它们必须位于特定的一边（通常是左边）。<br>\n  -作为一个二叉搜索树，并不是说每个节点都满足left.value&lt;=current.value&lt; right就够了。左边的每个节点必须小于当前节点，该节点还必须小于右边的所有节点。<br>\n  -如果左边的每个节点必须小于或等于当前节点，那么这就等于左边最大的节点必须小于或等于当前节点。<br>\n  -相比于根据leftTree.max和rightTree.min来验证当前节点的值，我们可以翻转逻辑吗？验证左子树的节点以确保其小于current.value。<br>\n  -把checkBST函数当作一个递归函数，保证每个节点在允许范围内（最小，最大）。首先，这个范围是无限的。当我们遍历左边，最小的是负无穷大，最大的是root.value。你能实现这个递归函数，并且随着遍历而适当调整这些范围吗？</p>\n","prev":{"title":"问题精析：PBR实现ByOpenGL","link":"2020/07/17/问题精析：PBR实现ByOpenGL"},"next":{"title":"问题精析：PBR材质","link":"2020/07/16/问题精析：PBR材质"},"plink":"http://Ssssshinji.github.io/2020/07/16/问题5：合法二叉搜索树/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"复杂度分析","title":"复杂度分析","index":"4"},{"id":"题目解析","title":"题目解析","index":"5"},{"id":"标准解答","title":"标准解答","index":"6"},{"id":"反思","title":"反思","index":"7"},{"id":"提示：#35，#57，#86，#113，#128","title":"提示：#35，#57，#86，#113，#128","index":"8"}]}