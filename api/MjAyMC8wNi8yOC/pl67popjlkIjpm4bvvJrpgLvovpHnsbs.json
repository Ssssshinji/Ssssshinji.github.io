{"title":"问题合集：逻辑类","date":"2020-06-28T04:08:30.000Z","date_formatted":{"ll":"Jun 28, 2020","L":"06/28/2020","MM-DD":"06-28"},"link":"2020/06/28/问题合集：逻辑类","tags":["数学与逻辑题"],"categories":["算法练习"],"updated":"2020-07-19T12:45:44.566Z","content":"<script type=\"text/javascript\" async src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML\"></script>\n<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  较重的药丸。有20瓶药丸，其中19瓶装有1.0克的药丸，余下1瓶装有1.1克的药丸。给你一台称重精准的天平，怎么找出比较重的那瓶药丸？天平只能用一次。（提示在后面）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  只能称重一次，可能的操作无非就是分成两组称重罢了。分成2组，一组10个药丸。这时候一边重一边轻。依次对调两边相同位置的药丸，比较重的药丸在对调后使轻的那一侧变重。</p>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  -有时候，严格的限制条件反倒能提供解题的线索。在这个问题中，限制条件是天平只能用一次。天平只能用一次，从而得出一个有趣的事实，即一次必须同时称很多药丸，其实更准确地说，是必须从19瓶中拿出药丸进行称重。否则，如果跳过2瓶或更多瓶药丸，又该如何区分没称过的那几瓶呢？别忘了，天平只能用一次。<br>\n  那么，该怎么称重取自多个药瓶的药丸，并确定哪一瓶装有比较重的药丸？假设只有2瓶药丸，其中一瓶的药丸比较重。每瓶取出一粒药丸，称得重量为2.1克，但无从知晓这多出来的0.1克来自哪一瓶。我们必须设法区分这些药瓶。<br>\n  如果从药瓶#1取出一粒药丸，从药瓶#2取出两粒药丸，那么，称得重量为多少呢？结果要依情况而定。如果药瓶#1的药丸较重，则称得重量为3.1克。如果药瓶#2的药丸较重，则称得重量为3.2克。这就是这个问题的接替窍门。<br>\n  称一堆药丸时，我们会有个“预期”重量。借由预期重量和实测重量之间的差别，就能得出哪一瓶药丸比较重，前提是从每个药瓶取出不同数量的药丸。<br>\n  将之前两瓶药丸的解法加以推广，就能得到完整解法，即从药瓶#1取出一粒药丸，从药瓶#2取出两粒，从药瓶#3取出三粒，以此类推。如果每粒药丸均重1克，则称得总重量为210克（1+2+…+20=20×21/2=210），“多出来的”重量必定来自每粒多0.1克的药丸。<br>\n  药瓶的编号可由下列算式得出：<br>\n$$\\frac{weight - 210grams} {0.1grams}$$<br>\n因此，若这堆药丸称得重量为211.3克，则药瓶#13装有较重的药丸。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  自己的思路实际上是用了多次天平，违背了题意。忽略了重量与数量之间的，预期重量与实际重量之间的关系。</p>\n<h2 id=\"提示\">提示<a title=\"#提示\" href=\"#提示\"></a></h2>\n<p>  -你只能使用天平一次。这意味着必须使用所有或几乎所有的药瓶。还必须使用不同的处理方法，否则你无法将它们区分开来。<br>\n  -如果你把每个瓶子中的一粒药丸放在天平上，会怎么样？如果你从每个瓶子中取两粒药丸放在天平上，又会如何？<br>\n  -想象一下只有3个瓶子，其中一瓶中有更重的药丸。假设你从每个瓶子中分别取出不同数量的药丸放在天平上（例如，从药瓶#1中取出5粒药丸，从药瓶#2中取出2粒药丸，从药瓶#3中取出9粒药丸），天平会怎样？<br>\n  -你应该能得到一个会告诉你哪一个是重瓶子的基于重量的方程。</p>\n<h2 id=\"题目描述-1\">题目描述<a title=\"#题目描述-1\" href=\"#题目描述-1\"></a></h2>\n<p><font size=4>  有个篮球框，下面两种玩法可任选一种。<br>\n  玩法1：一次出手机会，投篮命中得分。<br>\n  玩法2：三次出手机会，必须投中两次。<br>\n  如果p是某次投篮命中的概率，则p的值为多少时才会选择玩法1或玩法2？（提示在后面）</font></p>\n<h2 id=\"个人思路-1\">个人思路<a title=\"#个人思路-1\" href=\"#个人思路-1\"></a></h2>\n<p>  第一种玩法得分的概率和第二种玩法得分的概率比较即可。第一种是\\(p\\),第二种是\\(1-c_3^1 p^1(1-p)^2\\)。</p>\n<h2 id=\"题目解析-1\">题目解析<a title=\"#题目解析-1\" href=\"#题目解析-1\"></a></h2>\n<p>  与个人思路基本相同</p>\n<h2 id=\"提示-1\">提示<a title=\"#提示-1\" href=\"#提示-1\"></a></h2>\n<p>  -分别计算赢得第一场比赛和赢得第二场比赛的概率，然后对其进行比较。<br>\n  -要计算玩法2获胜的概率，首先要计算第1、2次投中，第3次未投中的概率。<br>\n  -如果两个事件是互斥的（它们不能同时发生），你可以将它们的概率加在一起。你能找到一组互斥的事件，代表三次投篮中的两次吗？<br>\n  -三投两中的概率为：（第1、2次投中，第3次未投中）的概率+（第1、3次投中，第2次未投中）的概率+（第1次未投中，第2、3次投中）的概率+（3次全投中）的概率。</p>\n<h2 id=\"题目描述-2\">题目描述<a title=\"#题目描述-2\" href=\"#题目描述-2\"></a></h2>\n<p><font size=4>  有个8×8棋盘，其中对角的角落上，两个方格被切掉了。给定31块多米诺骨牌，一块骨牌恰好可以覆盖两个方格。用这31块骨牌能否盖住整个棋盘？请证明你的答案（提供范例或证明为什么不能）。</font></p>\n<h2 id=\"个人思路-2\">个人思路<a title=\"#个人思路-2\" href=\"#个人思路-2\"></a></h2>\n<p>  从2*2的棋盘开始试验，试到5*5发现好像都没有办法铺满。看了提示后意识到，一个多米诺骨牌会占据一个黑色格子和一个白色各自，而对角的两个格子始终是同一种颜色的，会出现一种格子比另一种多两个的情况，则永远没有办法铺满整个棋盘。</p>\n<h2 id=\"题目解析-2\">题目解析<a title=\"#题目解析-2\" href=\"#题目解析-2\"></a></h2>\n<p>  乍一看，似乎是可以盖住的。棋盘大小为8×8，共有64个方格，但其中两个方格已被切掉，因此只剩62个方格。31块骨牌应该刚好能盖住整个棋盘，对吧？<br>\n  尝试用骨牌盖住第1行，而第1行只有7个方格，因此有一块骨牌必须铺至第2行。而用骨牌盖住第2行时，我们又必须将一块骨牌铺至第3行。<br>\n  要盖住每一行，总有一块骨牌必须铺至下一行。无论尝试多少次，使用多少种方法，我们都无法成功铺下所有骨牌。<br>\n  其实，可以更简洁而严谨地证明为什么不可能。棋盘原本有32个黑格和32个白格。将对角角落上的两个方格（相同颜色）切掉，棋盘只剩下30个同色的方格和32个另一种颜色的方格。为了方便论证，我们假定棋盘上剩下30个黑格和32个白格。<br>\n  放在棋盘上的每块骨牌必定会盖住一个白格和一个黑格。因此，31块骨牌正好盖住31个白格和31个黑格。然而，这个棋盘只有30个黑格和32个白格，所以，31块骨牌盖不住整个棋盘。</p>\n<h2 id=\"提示：#367，#397\">提示：#367，#397<a title=\"#提示：#367，#397\" href=\"#提示：#367，#397\"></a></h2>\n<p>  -想象一块多米诺骨牌放在棋盘上。它盖住了多少个黑色方格？多少个白色方格？<br>\n  -棋盘上有多少个黑色方格？多少个白色方格？</p>\n<h2 id=\"题目描述-3\">题目描述<a title=\"#题目描述-3\" href=\"#题目描述-3\"></a></h2>\n<p><font size=4>  三角形的三个顶点上各有一只蚂蚁。如果蚂蚁开始沿着三角形的边爬行，两只或三只蚂蚁撞在一起的概率有多大？假定每只蚂蚁会随机选一个方向，每个方向被选到的概率相等，而且三只蚂蚁的爬行速度相同。</font></p>\n<h2 id=\"个人思路-3\">个人思路<a title=\"#个人思路-3\" href=\"#个人思路-3\"></a></h2>\n<p>  只有都同向的时候才不会相撞。<br>\n$$<br>\n1-(1/2)^3 - (1/2)^3<br>\n$$</p>\n<h2 id=\"题目解析-3\">题目解析<a title=\"#题目解析-3\" href=\"#题目解析-3\"></a></h2>\n<p>  与个人思路基本相同。<br>\n  若要将这个方法推广至n个顶点的多边形，同样地，蚂蚁也只有以顺时针或逆时针同方向。<br>\n$$<br>\nP_(碰撞)= 1-P_(同方向)=1-(1/2)^(n-1)<br>\n$$</p>\n<h2 id=\"提示：#157，#195，#296\">提示：#157，#195，#296<a title=\"#提示：#157，#195，#296\" href=\"#提示：#157，#195，#296\"></a></h2>\n<p>  -在什么情况下其不会碰撞？<br>\n  -只有三只蚂蚁都向同一个方向爬行，它们才不致相撞。三只蚂蚁都按顺时针爬行的概率是多少？<br>\n  -你可以认为这是概率（3只蚂蚁走顺时针方向）+概率（3只蚂蚁走逆时针方向）。或者，你可以把它看作：第一只蚂蚁选择了一个方向。其他蚂蚁选择同一方向的概率是多少？</p>\n<h2 id=\"题目描述-4\">题目描述<a title=\"#题目描述-4\" href=\"#题目描述-4\"></a></h2>\n<p><font size=4>  有两个水壶，容量分别为3夸脱[插图]和5夸脱，若水的供应不限量（但没有量杯），怎么用这两个水壶得到刚好4夸克的水？注意，这两个水壶呈不规则状，无法精准地装满“半壶”水。</font></p>\n<h2 id=\"个人思路-4\">个人思路<a title=\"#个人思路-4\" href=\"#个人思路-4\"></a></h2>\n<p>  倒一倒就出来了。装满5夸克容器，倒进3夸克容器，5夸克容器剩余2夸克，3夸克容器清空，将2夸克水倒进3夸克容器，重新装满5夸克容器，用其装满3夸克容器，5夸克容器中剩余即为4夸克。</p>\n<h2 id=\"题目解析-4\">题目解析<a title=\"#题目解析-4\" href=\"#题目解析-4\"></a></h2>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>5夸克水壶</th>\n<th>3夸克水壶</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>3</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>0</td>\n<td>2</td>\n</tr>\n<tr>\n<td>5</td>\n<td>2</td>\n</tr>\n<tr>\n<td>4</td>\n<td>3</td>\n</tr>\n</tbody>\n</table></div></div><h2 id=\"提示：#149，#379，#400\">提示：#149，#379，#400<a title=\"#提示：#149，#379，#400\" href=\"#提示：#149，#379，#400\"></a></h2>\n<p>  -把玩水壶，来回倒水，看看你能否测量3夸脱或5夸脱以外的东西。这是一个开始。<br>\n  -如果你装满5夸脱的水壶，再用它装满3夸脱的水壶，那么5夸脱的水壶里就剩下2夸脱了。你可以把这2夸脱放在那里，也可以把小水壶里的水倒干净，然后倒入这2夸脱。<br>\n  -一旦你找到一个解决这个问题的方法，就可以从更具普遍意义的角度去考虑它。如果给你一个大小为X的水壶和另一个大小为Y的水壶，你能用它们来测量出Z吗？</p>\n<h2 id=\"题目描述-5\">题目描述<a title=\"#题目描述-5\" href=\"#题目描述-5\"></a></h2>\n<p><font size=4>  有个岛上住着一群人，有一天来了个游客，定了一条奇怪的规矩：所有蓝眼睛的人都必须尽快离开这个岛。每晚8点会有一个航班离岛。每个人都看得见别人眼睛的颜色，但不知道自己的（别人也不可以告知）。此外，他们不知道岛上到底有多少人有蓝眼睛，只知道至少有一个人的眼睛是蓝色的。所有蓝眼睛的人要花几天才能离开这个岛？（提示在后面）</font></p>\n<h2 id=\"个人思路-5\">个人思路<a title=\"#个人思路-5\" href=\"#个人思路-5\"></a></h2>\n<p>  题目有些描述不清楚的地方。比如说要是A旁边的人说A的眼睛是蓝色的，A会不会相信然后离岛。还有面对离岛这件事，蓝眼睛的人是积极的还是消极的，身边的人是积极还是消极。此处我们假设，周围的人不会告知他人的眼睛颜色，只有蓝色眼睛的人自身通过推理确认了自己眼睛的颜色后才会离岛。</p>\n<h2 id=\"题目解析-5\">题目解析<a title=\"#题目解析-5\" href=\"#题目解析-5\"></a></h2>\n<p>  下面将采用简单构造法。假定这个岛上一共有n人，其中c人有蓝眼睛。由题目可知，c&gt; 0。<br>\n  <strong>1. 情况c=1：只有一人眼睛是蓝色的</strong>：<br>\n  假设岛上所有人都智力超群，蓝眼睛的人四处观察之后，发现没有人的眼睛是蓝色的。但他知道至少有一人眼睛是蓝色的，于是就推导出自己的眼睛一定是蓝色的。因此，他会搭乘当晚的飞机离开。<br>\n  <strong>2. 情况c=2：只有两人眼睛是蓝色的</strong>：<br>\n  两个蓝眼睛的人看到对方，并不确定c是1还是2，但是由上一种情况得知，如果c=1，那个蓝眼睛的人第一晚就会离岛。因此，发现另一个蓝眼睛的人仍在岛上，他一定能推断出c=2，也就意味着他自己的眼睛也是蓝色的。于是，两个蓝眼睛的人都会在第二晚离岛。<br>\n  <strong>3. 情况c&gt; 2：一般情况</strong>：<br>\n  逐步增加c时，我们可以看出上述公式仍旧适用。如果c=3，那么，这三个人会立即意识到有两到三人的眼睛是蓝色的。如果有两人眼睛是蓝色的，那么这两人会在第二晚离岛。因此，如果过了第二晚另外两人还在岛上，每个蓝眼睛的人都能推断出c=3，因此这三人都有蓝眼睛。他们会在第三晚离岛。<br>\n  无论c为何值，都可套用这个公式。所以，如果有c人有蓝眼睛，则所有蓝眼睛的人要用c晚才能离岛，且都在同一晚离开。</p>\n<h2 id=\"反思-1\">反思<a title=\"#反思-1\" href=\"#反思-1\"></a></h2>\n<p>  本来觉得有些逻辑问题，后来还是想通了。假如有三个蓝眼睛的人，他们分别能看到另外的两个蓝眼睛的人，所以要是第二天晚上还没人离开的话，就会同时在第三天离开。非蓝色眼睛的人能看到3个蓝眼睛的人，所以即使要推测自己是蓝眼睛然后离开，也是在第四天。而第三天时三个人已经离开了的话，他也就可以判断出自己不是蓝眼睛。</p>\n<h2 id=\"提示：#218，#282，#341，#370\">提示：#218，#282，#341，#370<a title=\"#提示：#218，#282，#341，#370\" href=\"#提示：#218，#282，#341，#370\"></a></h2>\n<p>  -这是一个逻辑问题，而不是一个巧妙的单词问题。使用逻辑/数学/算法来解决该问题。<br>\n  -假设只有一个蓝眼睛的人。那个人会看到什么？他们什么时候离开？<br>\n  -现在假设有两个蓝眼睛的人。他们会看到什么？他们会知道什么？他们什么时候离开？从先前的提示想一下你的答案。假设他们知道前面提示的答案。<br>\n  -由此推导下去。如果有3个蓝眼睛的人呢？如果有4个蓝眼睛的人呢？</p>\n<h2 id=\"题目描述-6\">题目描述<a title=\"#题目描述-6\" href=\"#题目描述-6\"></a></h2>\n<p><font size=4>  在大灾难后的新世界，世界女王非常关心出生率。因此，她规定所有家庭都必须有一个女孩，否则将面临巨额罚款。如果所有的家庭都遵守这个政策——所有家庭在得到一个女孩之前不断生育，生了女孩之后立即停止生育——那么新一代的性别比例是多少（假设每次怀孕后生男生女的概率是相等的）？通过逻辑推理解决这个问题，然后使用计算机进行模拟。（提示在后面）</font></p>\n<h2 id=\"个人思路-6\">个人思路<a title=\"#个人思路-6\" href=\"#个人思路-6\"></a></h2>\n<p>  应该需要计算期望，算出来是1：1，脑海里总觉得应该是男生比较多，差得很远，故选择看答案。</p>\n<h2 id=\"题目解析-6\">题目解析<a title=\"#题目解析-6\" href=\"#题目解析-6\"></a></h2>\n<p>  如果每个家庭都遵守该政策，那么每个家庭都会先生育0至多个男孩，再生育一个女孩。换句话说，如果用G表示女孩，B表示男孩，那么孩子出生的序列可由以下任意一种序列表示，即G，BG，BBG，BBBG，以此类推。<br>\n  <strong>1. 数学方法</strong>：<br>\n  如果从药瓶#1取出一粒药丸，从药瓶#2取出两粒药丸，那么，称得重量为多少呢？结果要依情况而定。如果药瓶#1的药丸较重，则称得重量为3.1克。如果药瓶#2的药丸较重，则称得重量为3.2克。这就是这个问题的接替窍门。<br>\n  P(G)=1/2。换句话说，50%的家庭会首先生育一个女孩，其他家庭则会生育更多的孩子。<br>\n  P(BG)=1/4。对于那些可以生育第二个孩子的家庭（占总家庭数的50%），第二个有50%会生育一个女孩。<br>\n  P(BBG)=1/8。对于那些可以生育第三个孩子的家庭（占总家庭数的25%），第三个50%会生育一个女孩。<br>\n  我们知道每个家庭都有且只有一个女孩。那么每个家庭平均生育多少个男孩？为了回答该问题，我们可以计算生育男孩数量的期望值，而该期望值可以通过计算每种生育序列的概率与序列中男孩的数量的乘积得出。</p>\n<div class=\"φcy\"><div class=\"φda\"><table><thead>\n<tr>\n<th>序列</th>\n<th>男孩数量</th>\n<th>概率</th>\n<th>男孩数量*概率</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>G</td>\n<td>0</td>\n<td>1/2</td>\n<td>0</td>\n</tr>\n<tr>\n<td>BG</td>\n<td>1</td>\n<td>1/4</td>\n<td>1/4</td>\n</tr>\n<tr>\n<td>BBG</td>\n<td>2</td>\n<td>1/8</td>\n<td>2/8</td>\n</tr>\n<tr>\n<td>BBBG</td>\n<td>3</td>\n<td>1/16</td>\n<td>3/16</td>\n</tr>\n<tr>\n<td>BBBBG</td>\n<td>4</td>\n<td>1/32</td>\n<td>4/32</td>\n</tr>\n<tr>\n<td>BBBBBG</td>\n<td>5</td>\n<td>1/64</td>\n<td>5/64</td>\n</tr>\n</tbody>\n</table></div></div><p>  换句话说，期望值可以通过计算级数“i除以2^i”的求和公式得到，其中i的范围为0至无穷大，公式如下。<br>\n$$<br>\n\\sum_{i=0}^{\\infty} = \\frac{i}{2^{i+1}}<br>\n$$<br>\n  利用上面的公式求期望，结果接近于64/64（即1）。该估值方法大有用处，但是并不是严格意义上的数学推导。然而，其可以助下面所述的逻辑方法一臂之力。结果会是1吗？<br>\n  <strong>2. 逻辑方法</strong>：<br>\n  如果上面方法得出的和为1，那么这就意味着性别比例是平衡的。每个家庭刚好生育一个女孩，而平均生育一个男孩。因此该生育政策是无效的。你觉得这样的结论合理吗？<br>\n  第一眼看上去，这似乎是一个错误的答案。该生育政策设计之初是为了生育更多的女孩，原因在于该政策确保了每个家庭都能够生育女孩。但是另一方面，每个家庭都有可能生育多个男孩。这会对冲掉“生育一个女孩”政策的影响。<br>\n  思考该问题的另一个方法是，我们可以将所有家庭的生育序列表示为一个巨大的字符串。如果家庭1生育序列为BG，家庭2生育序列为BBG，家庭3生育序列为G，我们可以将所有家庭的生育序列记作BGBBGG。<br>\n  事实上，我们不需要关心如何以家庭为单位列出字符串，这是因为我们真正关心的是总人口的性别比例。只要有一个孩子出生，我们即可将其性别B或者G加入到字符串的尾部。<br>\n  下一个字符是G的可能性有多大？其实，如果生育男孩和女孩的可能性是一样的，那么下一个字符为G的可能性即为50%。因此，大体上一半的字符串会是G字符，另一半会是B字符，也就是说性别的比例是一致的。<br>\n  这样看来就合理多了。生物学并没有被改变。一半新出生的婴儿是男孩，一半新出生的婴儿是女孩。遵守任何关于“在某一时刻停止生育”的政策不会改变生物学这一事实。<br>\n  因此，性别比例是50%的男孩和50%的女孩。<br>\n  <strong>3. 算法模拟</strong>：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static double p()&#123;</span><br><span class=\"line\">    int[] genders &#x3D; new int[2];</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt;&#x3D; 10000; i++)&#123;</span><br><span class=\"line\">        int[] gerder &#x3D; OneFamily();</span><br><span class=\"line\">        genders[0] +&#x3D; gerder[0];</span><br><span class=\"line\">        genders[1] +&#x3D; gerder[1];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return (double)genders[0]&#x2F;genders[1];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static int[] OneFamily()&#123;</span><br><span class=\"line\">    int[] gerder &#x3D; new int[2];</span><br><span class=\"line\">    gerder[0] &#x3D; 0;</span><br><span class=\"line\">    gerder[1] &#x3D; 0;</span><br><span class=\"line\">    while(gerder[1] &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">        if(new Random().Next(2) &lt; 1)&#123;</span><br><span class=\"line\">            gerder[1] +&#x3D; 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            gerder[0] +&#x3D; 1;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return gerder;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思-2\">反思<a title=\"#反思-2\" href=\"#反思-2\"></a></h2>\n<p>  概率论的基础不扎实，生怕是自己算错了。</p>\n<h2 id=\"提示：#154，#160，#171，#188，#201\">提示：#154，#160，#171，#188，#201<a title=\"#提示：#154，#160，#171，#188，#201\" href=\"#提示：#154，#160，#171，#188，#201\"></a></h2>\n<p>  -注意每个家庭都有一个女孩。<br>\n  -考虑将每个家庭写成Bs和Gs的序列。<br>\n  -虽然数学很难，但你可以试着使用数学方法。估算一下比如6个孩子的家庭可能会较为容易。这不会给你一个很好的数学证明方法，但可能会向你指出获得答案的正确方向。<br>\n  -逻辑可能比数学容易。想象一下，我们把每次出生都写进了一个巨大的字符串，它由字符B和G组成。注意家庭的分组对于这个问题是无关紧要的。字符串的下一个字符是B还是G的概率是多少？<br>\n  -请注意生物学并没有改变，只有家庭停止生孩子的条件有所改变。每一次怀孕生男孩和生女孩的可能性均为50%。</p>\n<h2 id=\"题目描述-7\">题目描述<a title=\"#题目描述-7\" href=\"#题目描述-7\"></a></h2>\n<p><font size=4>  有栋建筑物高100层，若从第N层或更高的楼层扔下来，鸡蛋就会破碎；若从第N层以下的楼层扔下来则不会破碎。给你两个鸡蛋，请找出N，并要求最差情况下扔鸡蛋的次数为最少。（提示在后面）</font></p>\n<h2 id=\"个人思路-7\">个人思路<a title=\"#个人思路-7\" href=\"#个人思路-7\"></a></h2>\n<p>  只有两个鸡蛋，为了防止一次全部破碎，只能从最底层往上试验。最多可以相隔一个楼层。比如说，一个从1楼，一个从3楼，如果没碎，就抬高到4，6楼。如果3楼的碎了，剩下的那个从2楼扔下便知道N是2还是1。</p>\n<h2 id=\"题目解析-7\">题目解析<a title=\"#题目解析-7\" href=\"#题目解析-7\"></a></h2>\n<p>  我们发现，无论怎么扔鸡蛋1（Egg 1），鸡蛋2（Egg 2）都必须在“破碎那一层”和下一个不会破碎的最高楼层之间，逐层扔下楼（从最低的到最高的）。例如，若鸡蛋1从第5层和第10层扔下没破碎，但从第15层扔下时破碎了，那么，在最差情况下，鸡蛋2必须尝试从第11、第12、第13和第14层扔下楼。<br>\n  首先，让我们试着从第10层开始扔鸡蛋，然后是第20层，以此类推。<br>\n  如果鸡蛋1第一次扔下楼（第10层）就破碎了，那么，最多需要扔10次。<br>\n  如果鸡蛋1最后一次扔下楼（第100层）才破碎，那么，最多要扔19次（第10层，第20层……第90层，第100层，然后是第91到第99层）。<br>\n  这么做也挺不错，但只考虑了绝对最差情况。我们应该进行“负载均衡”，让这两种情况下扔鸡碎的次数更均匀。<br>\n  我们的目标是设计一种扔鸡蛋的方法，使得扔鸡蛋1时，不论是在第一次还是最后一次扔下楼才破碎，扔鸡蛋的次数尽量一致。<br>\n  (1) 完美负载均衡的方法应该是，扔鸡蛋1的次数加上扔鸡蛋2的次数，不论什么时候都一样，不管鸡蛋1是从哪层楼扔下时破碎的。<br>\n  若有这种扔法，每次鸡蛋1多扔一次，鸡蛋2就可以少扔一次。<br>\n  因此，每扔一次鸡蛋1，就应该减少鸡蛋2可能需要扔下楼的次数。例如，如果鸡蛋1先从第20层扔下楼，然后从第30层扔下楼，此时鸡蛋2可能就要扔9次。若鸡蛋1再扔一次，我们必须让鸡蛋2扔下楼的次数降为8次。这也就是说，我们必须让鸡蛋1从第39层扔下楼。<br>\n  由此可知，鸡蛋1必须从第X层开始往下扔，然后再往上增加X-1层，之后增加X-2层……直至到达第100层。<br>\n  求解X。X+(X-1)+(X-2)+…+1=100X(X+1)/2=100<br>\n  X≈13.65<br>\n  X显然是一个整数值。我们应该向上取整还是向下取整呢？<br>\n  如果向上取整为14，那么需要按照增加14层、增加13层、增加12层的规律向上增加扔鸡蛋的层数。最后增加的数量为4层，届时将达到第99层。如果在此过程中鸡蛋1在任意一层破碎，可以确定已经对最差情况进行了平衡，扔鸡蛋1和鸡蛋2的次数之和最差为14次。如果鸡蛋1在第99层仍没有破碎，那么只需要再扔一次以确定鸡蛋是否会在第100层破碎。无论哪一种方法，扔鸡蛋的次数不会超过14次。<br>\n  如果向下取整为13，那么需要按照增加13层、增加12层、增加11层的规律向上增加扔鸡蛋的层数。最后增加的数量为1层，届时将达到第91层。在此情况下，我们已经扔了13次。第92至100层尚没有进行测试。我们没有办法通过扔一次鸡蛋来确定余下的这些楼层（即没有办法取得和“向上取整”相近的结果）。<br>\n  因此，应该向上取整为14，也就是说，需要先在第14层测试，然后是第27层，接着是第39层……最坏情况下，需要14次测试。<br>\n  正如解决其他许多最大化/最小化的问题一样，这类问题的关键在于“平衡最差情况”。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int breakingPoint &#x3D; 某个数;</span><br><span class=\"line\">int countDrops &#x3D; 0;</span><br><span class=\"line\">bool drop(int floor)&#123;</span><br><span class=\"line\">    countDrops++;</span><br><span class=\"line\">    return floor &gt;&#x3D; breakingPoint;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;参数是楼层数</span><br><span class=\"line\">int findBreakingPoint(int floors)&#123;</span><br><span class=\"line\">    int interval &#x3D; 14;</span><br><span class=\"line\">    int previousFloor &#x3D; 0;</span><br><span class=\"line\">    int egg1 &#x3D; interval;</span><br><span class=\"line\">    &#x2F;&#x2F;递减间隔扔鸡蛋1</span><br><span class=\"line\">    while(!drop(egg1) &amp;&amp; egg1 &lt;&#x3D; floors)&#123;</span><br><span class=\"line\">        interval -&#x3D; 1;</span><br><span class=\"line\">        previousFloor &#x3D; egg1;</span><br><span class=\"line\">        egg1 +&#x3D; interval;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    int egg2 &#x3D; previousFloor + 1;</span><br><span class=\"line\">    &#x2F;&#x2F;每层加1扔鸡蛋2</span><br><span class=\"line\">    while(egg2 &lt; egg1 &amp;&amp; egg2 &lt;&#x3D; floors &amp;&amp; !drop(egg2))&#123;</span><br><span class=\"line\">        egg2 +&#x3D; 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return egg2 &gt; floors ? -1:egg2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反思-3\">反思<a title=\"#反思-3\" href=\"#反思-3\"></a></h2>\n<p>  注意如何优化最坏的情况。</p>\n<h2 id=\"提示：#156，#233，#294，#333，#357，#374，#395\">提示：#156，#233，#294，#333，#357，#374，#395<a title=\"#提示：#156，#233，#294，#333，#357，#374，#395\" href=\"#提示：#156，#233，#294，#333，#357，#374，#395\"></a></h2>\n<p>  -这实际上是一个算法问题，你应该这样做。<strong>给出一个蛮力算法，计算最坏情况下扔鸡蛋的次数，然后尝试优化。</strong><br>\n  -作为第一种方法，你可以尝试类似二分查找的方法。从第50层或第75层，然后到第88层，等等。问题是，**如果鸡蛋1从50层下落破碎，那么你需要从第1层开始往下扔鸡蛋2，逐层往上走。最糟糕的情况下，这可能需要50次（第50层扔，第1层和第2层扔，直到第49层扔）。**你能改进这一情况吗？<br>\n  -实际上，第一次扔要稍低一些。例如，你可以在第10层扔，然后是第20层，再然后是第30层，以此类推。最坏的情况是19次（第10层，第20层……第100层，第91层，第92层……第99层）。你能做得比这更好吗？不要随意猜测不同的解题方案，而是要深入思考。最坏的情况如何定义？每个鸡蛋被扔的次数是怎样被影响的？<br>\n  -如果我们以固定间隔扔鸡蛋1（例如，每10层），这样最坏的情况是：鸡蛋1的最坏情况+鸡蛋2的最坏情况。上述解法的问题在于，即使鸡蛋1做更多的工作，鸡蛋2的工作也不会更少。理想情况下，我们想平衡一下。由于鸡蛋1做了更多的工作（从更多次扔下中幸存），因此鸡蛋2需要做的工作应该更少。这意味着什么？<br>\n  -一开始尝试以较大的间隔扔鸡蛋1，然后逐渐缩小间隔。我们的想法是尽可能保持扔鸡蛋1和扔鸡蛋2次数之和不变。每多扔一次鸡蛋1，鸡蛋2就少扔一次。正确的间隔是多少？<br>\n  -假设X是第一次扔鸡蛋1的层数。如果鸡蛋1破碎，则意味着鸡蛋2会被扔X-1次。我们希望尽可能地保持鸡蛋1和鸡蛋2扔下的次数总和一致。如果鸡蛋1在第二次扔下时破碎，那么鸡蛋2需要被扔X-2次。如果鸡蛋1在第三次扔下时破碎，那么鸡蛋2需要被扔X-3次。这样扔鸡蛋1和鸡蛋2的次数之和恒定。X是多少？<br>\n  -最坏情况我扔了14次。你的最坏情况呢？</p>\n","prev":{"title":"问题1：三步问题","link":"2020/06/28/问题1：三步问题"},"next":{"title":"面试经验汇总","link":"2020/06/27/面试经验汇总"},"plink":"http://Ssssshinji.github.io/2020/06/28/问题合集：逻辑类/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"题目解析","title":"题目解析","index":"3"},{"id":"反思","title":"反思","index":"4"},{"id":"提示","title":"提示","index":"5"},{"id":"题目描述-1","title":"题目描述","index":"6"},{"id":"个人思路-1","title":"个人思路","index":"7"},{"id":"题目解析-1","title":"题目解析","index":"8"},{"id":"提示-1","title":"提示","index":"9"},{"id":"题目描述-2","title":"题目描述","index":"10"},{"id":"个人思路-2","title":"个人思路","index":"11"},{"id":"题目解析-2","title":"题目解析","index":"12"},{"id":"提示：#367，#397","title":"提示：#367，#397","index":"13"},{"id":"题目描述-3","title":"题目描述","index":"14"},{"id":"个人思路-3","title":"个人思路","index":"15"},{"id":"题目解析-3","title":"题目解析","index":"16"},{"id":"提示：#157，#195，#296","title":"提示：#157，#195，#296","index":"17"},{"id":"题目描述-4","title":"题目描述","index":"18"},{"id":"个人思路-4","title":"个人思路","index":"19"},{"id":"题目解析-4","title":"题目解析","index":"20"},{"id":"提示：#149，#379，#400","title":"提示：#149，#379，#400","index":"21"},{"id":"题目描述-5","title":"题目描述","index":"22"},{"id":"个人思路-5","title":"个人思路","index":"23"},{"id":"题目解析-5","title":"题目解析","index":"24"},{"id":"反思-1","title":"反思","index":"25"},{"id":"提示：#218，#282，#341，#370","title":"提示：#218，#282，#341，#370","index":"26"},{"id":"题目描述-6","title":"题目描述","index":"27"},{"id":"个人思路-6","title":"个人思路","index":"28"},{"id":"题目解析-6","title":"题目解析","index":"29"},{"id":"反思-2","title":"反思","index":"30"},{"id":"提示：#154，#160，#171，#188，#201","title":"提示：#154，#160，#171，#188，#201","index":"31"},{"id":"题目描述-7","title":"题目描述","index":"32"},{"id":"个人思路-7","title":"个人思路","index":"33"},{"id":"题目解析-7","title":"题目解析","index":"34"},{"id":"反思-3","title":"反思","index":"35"},{"id":"提示：#156，#233，#294，#333，#357，#374，#395","title":"提示：#156，#233，#294，#333，#357，#374，#395","index":"36"}]}