{"title":"问题1：三步问题","date":"2020-06-28T04:55:16.000Z","date_formatted":{"ll":"Jun 28, 2020","L":"06/28/2020","MM-DD":"06-28"},"link":"2020/06/28/问题1：三步问题","tags":["递归与动态规划"],"categories":["算法练习"],"updated":"2020-06-28T05:53:46.797Z","content":"<h2 id=\"题目描述\">题目描述<a title=\"#题目描述\" href=\"#题目描述\"></a></h2>\n<p><font size=4>  有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。（提示在页尾）</font></p>\n<h2 id=\"个人思路\">个人思路<a title=\"#个人思路\" href=\"#个人思路\"></a></h2>\n<p>  经典斐波拉契数列问题的变形。</p>\n<h2 id=\"个人解答\">个人解答<a title=\"#个人解答\" href=\"#个人解答\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int Count(int n)&#123;</span><br><span class=\"line\">    if(n &lt; 0)return 0;</span><br><span class=\"line\">    else if(n &#x3D;&#x3D; 0)&#123;</span><br><span class=\"line\">        return 1; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else return count(n-1)+count(n-2)+count(n-3);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析\">复杂度分析<a title=\"#复杂度分析\" href=\"#复杂度分析\"></a></h2>\n<p>  每次都有3个分支，经典O(3^n)。</p>\n<h2 id=\"题目解析\">题目解析<a title=\"#题目解析\" href=\"#题目解析\"></a></h2>\n<p>  -<strong>蛮力法:</strong> 用递归法可以很容易就实现这个算法，只需要遵循如下思路，即countWays(n-1)+countWays(n-2)+countWays(n-3)。<br>\n  -<strong>制表法:</strong> 记录已经计算过的结果方式重复计算。（原来也遇到过，又给忘了）<br>\n  重要的一点是，无论是否使用制表法，注意上楼梯的方式总数很快就会突破整数（int型）的上限而溢出。当n=37时，结果就会溢出。使用long可以撑久一点儿，但也不能从根本上解决问题。</p>\n<h2 id=\"标准解答（制表法）\">标准解答（制表法）<a title=\"#标准解答（制表法）\" href=\"#标准解答（制表法）\"></a></h2>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">static int CountWay(int n)&#123;</span><br><span class=\"line\">    int[] memo &#x3D; new int[n+1];</span><br><span class=\"line\">    for(int i &#x3D; 0; i &lt; memo.Length; i++)&#123;</span><br><span class=\"line\">        memo[i] &#x3D; -1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return CountWay(n,memo);</span><br><span class=\"line\">    </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">static int CountWay(int n, int[] memo)&#123;</span><br><span class=\"line\">        if(n &lt; 0)return 0;</span><br><span class=\"line\">        else if(n &#x3D;&#x3D; 0)return 1;</span><br><span class=\"line\">        else if(memo[n] &gt; -1)&#123;</span><br><span class=\"line\">            return memo[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else&#123;</span><br><span class=\"line\">            memo[n] &#x3D; CountWay(n-1,memo) + CountWay(n-2,memo) + CountWay(n-3,memo);</span><br><span class=\"line\">            return memo[n];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"复杂度分析-1\">复杂度分析<a title=\"#复杂度分析-1\" href=\"#复杂度分析-1\"></a></h2>\n<p>  也是经典O(3^n)，不过会快很多。</p>\n<h2 id=\"反思\">反思<a title=\"#反思\" href=\"#反思\"></a></h2>\n<p>  对性能以及算法的可行性不敏感，没有考虑边界问题。</p>\n<h2 id=\"提示：#152，#178，#217，#237，#262，#359\">提示：#152，#178，#217，#237，#262，#359<a title=\"#提示：#152，#178，#217，#237，#262，#359\" href=\"#提示：#152，#178，#217，#237，#262，#359\"></a></h2>\n<p>  -自上而下地处理这个问题。小孩的最后一跳是什么？<br>\n  -如果知道跳到第100级台阶之前的每一级台阶的跳法数量，可以计算第100级台阶的跳法数量吗？<br>\n  -可以通过步数99、98、97的数量，来计算100步的数量。这对应孩子最后迈1步、2步或3步。我们把它们加起来还是相乘？也就是说，它是f(100)=f(99)+f(98)+f(97)或者f(100)=f(99)×f(98)×f(97)吗？<br>\n  -当“我们这样做然后那样做”时，将这些值相乘。当“我们这样做或者那样做”时，将这些值相加。<br>\n  -这个方法的运行时间是多少？仔细想想。你能优化它吗？<br>\n  -尝试用制表法的方式优化效率低下的递归过程。</p>\n","next":{"title":"问题合集：逻辑类","link":"2020/06/28/问题合集：逻辑类"},"plink":"http://Ssssshinji.github.io/2020/06/28/问题1：三步问题/","toc":[{"id":"题目描述","title":"题目描述","index":"1"},{"id":"个人思路","title":"个人思路","index":"2"},{"id":"个人解答","title":"个人解答","index":"3"},{"id":"复杂度分析","title":"复杂度分析","index":"4"},{"id":"题目解析","title":"题目解析","index":"5"},{"id":"标准解答（制表法）","title":"标准解答（制表法）","index":"6"},{"id":"复杂度分析-1","title":"复杂度分析","index":"7"},{"id":"反思","title":"反思","index":"8"},{"id":"提示：#152，#178，#217，#237，#262，#359","title":"提示：#152，#178，#217，#237，#262，#359","index":"9"}]}